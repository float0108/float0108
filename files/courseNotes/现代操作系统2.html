<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>courseNotes：现代操作系统CS2310 （下）存储与文件系统 - 極楽浄土</title>

  
    <meta name="description" content="SJTU-CS2310 现代操作系统 （速效版）">
<meta property="og:type" content="website">
<meta property="og:title" content="现代操作系统CS2310 （下）存储与文件系统">
<meta property="og:url" content="https://float0108.github.io/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2.html">
<meta property="og:site_name" content="極楽浄土">
<meta property="og:description" content="SJTU-CS2310 现代操作系统 （速效版）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316232901.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316235007.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230317005831.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230317005822.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230425102536.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230331010733.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230425022644.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230425022709.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031202.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031456.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031437.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415230811.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231146.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231208.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231245.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231309.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415232426.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416003935.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416004114.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416010327.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416010454.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416012148.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416012023.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416014446.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416020129.png">
<meta property="article:published_time" content="2023-03-10T15:54:37.000Z">
<meta property="article:modified_time" content="2023-04-25T03:03:52.081Z">
<meta property="article:author" content="AleryXiao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316232901.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="極楽浄土" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/site_assets/favicon.jpg">
  

  

  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/site_assets/head.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">極楽浄土</div><div class="sub normal cap">フロトの理发店</div><div class="sub hover cap" style="opacity:0"> @AleryXiao</div></a></div>

<nav class="menu dis-select"><a class="nav-item" href="/">posts</a><a class="nav-item active" href="/wiki/">collection</a><a class="nav-item" href="/about/">about</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/files/courseNotes/" placeholder="在 /files/courseNotes/ 中搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">现代操作系统CS2310 （下）存储与文件系统</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.html#start"><span class="toc-text">计算机系统结构-CS2305</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(8086).html"><span class="toc-text">汇编语言-CS2307</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%80%A7.html"><span class="toc-text">算法与复杂性-CS2308</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1.html"><span class="toc-text">现代操作系统CS2310 （上）进程管理</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2.html"><span class="toc-text">现代操作系统CS2310 （下）存储与文件系统</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">内存与虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Management-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">Memory Management 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Allocation-Table-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%A1%A8"><span class="toc-text">Allocation Table 内存分配表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Contiguous-memory-allocation-%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Contiguous memory allocation  连续式内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-contiguous-memory-allocation-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Non-contiguous memory allocation  非连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Paging-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-text">Paging 内存分页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#The-realization-of-page-table-structure"><span class="toc-text">The realization of page table structure</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Segmentation-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-text">Segmentation 内存分段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Segmentation-and-paging-scheme"><span class="toc-text">Segmentation and paging scheme</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Memory-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">Virtual Memory 虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Replacement-Algorithms-%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">Page-Replacement Algorithms 页面替换算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">大容量存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-%E5%9F%BA%E7%A1%80"><span class="toc-text">Disk 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Scheduling-Algorithms"><span class="toc-text">Disk-Scheduling Algorithms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSD-vs-HDD"><span class="toc-text">SSD vs HDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Space-amp-Disk-Management"><span class="toc-text">Space &amp; Disk Management</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Attachment"><span class="toc-text">Disk Attachment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID"><span class="toc-text">RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-Attached-Storage"><span class="toc-text">Network-Attached Storage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File"><span class="toc-text">File</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-operations"><span class="toc-text">File operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Open-files"><span class="toc-text">Open files</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Structure"><span class="toc-text">Disk Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Directory"><span class="toc-text">File Directory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Allocation-Methods"><span class="toc-text">File Allocation Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Contiguous-Allocation"><span class="toc-text">Contiguous Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linked-Allocation"><span class="toc-text">Linked Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Allocation-Table-FAT"><span class="toc-text">File-Allocation Table (FAT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FAT-vs-linked-allocation"><span class="toc-text">FAT vs linked allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Indexed-Allocation"><span class="toc-text">Indexed Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-node-management"><span class="toc-text">I-node management</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-%E7%B3%BB%E7%BB%9F"><span class="toc-text">I&#x2F;O 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-Hardware"><span class="toc-text">I&#x2F;O Hardware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Addressing-amp-instruction-system"><span class="toc-text">Addressing &amp; instruction system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-system"><span class="toc-text">I&#x2F;O system</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Programmed-I-O"><span class="toc-text">Programmed I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interrupt-Driven-I-O"><span class="toc-text">Interrupt-Driven I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-Memory-Access-DMA"><span class="toc-text">Direct Memory Access (DMA)</span></a></li></ol></li></ol></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3.html"><span class="toc-text">现代操作系统CS2310 （附）虚拟机和分布式</span></a></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">collection</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/files/courseNotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.html">courseNotes</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-04-25T03:03:52.081Z">2023-04-25</time></div></div>

  <article class='md-text content wiki'>
  <h1 class="article-title"><span>现代操作系统CS2310 （下）存储与文件系统</span></h1>
  <h2 id="内存与虚拟内存"><a href="#内存与虚拟内存" class="headerlink" title="内存与虚拟内存"></a>内存与虚拟内存</h2><p>MMU (Memory Management Unit)<br>    Hardware component (通常作为一个主板模块与CPU和内存分别相连)<br>    在CPU发生访问需求时，根据<strong>内存映射表</strong>将CPU中的逻辑内存地址转换成内存中的物理内存地址<br>        每次开机，OS都会从硬盘中读取地址映射表，并将其存储到内存中的特定位置<br>        OS会将这个位置，也就是<strong>地址映射表的基地址</strong>存储在MMU的 relocation register 重定位寄存器。</p>
<h3 id="Memory-Management-内存管理"><a href="#Memory-Management-内存管理" class="headerlink" title="Memory Management 内存管理"></a>Memory Management 内存管理</h3><h4 id="Allocation-Table-内存分配表"><a href="#Allocation-Table-内存分配表" class="headerlink" title="Allocation Table 内存分配表"></a>Allocation Table 内存分配表</h4><p>由于内存分配表的大小通常比较小，而且遍历它的开销相对较低，所以一般的内存管理方法都使用内存分配表来记录内存的分配情况，使OS可以快速查找到可用的内存块并将其分配给进程。</p>
<ul>
<li>记录内存中分区的起始地址、大小、是否已分配等信息</li>
<li>可看作是一个逻辑上的表格，其中每个表项代表一块内存区域</li>
<li>由OS在启动时初始化，分配时动态更新</li>
</ul>
<h4 id="Contiguous-memory-allocation-连续式内存分配"><a href="#Contiguous-memory-allocation-连续式内存分配" class="headerlink" title="Contiguous memory allocation  连续式内存分配"></a>Contiguous memory allocation  连续式内存分配</h4><p><strong>Defination</strong></p>
<ul>
<li>将可用的内存空间视为<strong>连续的地址空间</strong></li>
<li>进程被分配的内存空间也必须是<strong>连续的物理内存空间</strong>。</li>
</ul>
<p><strong>Multiple-partition allocation 多区分配</strong> </p>
<ul>
<li>一种典型的连续式内存分配</li>
<li>维护内存分配表（包含已分配分区和未分配 (holes) 分区的信息）</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230316232901.png" alt=""></p>
<ul>
<li><p><strong>Dynamic Storage-Allocation Problem  动态存储分配问题</strong></p>
<ul>
<li>First-fit</li>
<li>Best-fit<ul>
<li>Allocate the smallest hole that is big enough</li>
<li>must search entire list, unless ordered by size</li>
<li>Produces the smallest leftover hole</li>
</ul>
</li>
<li>Worst-fit<ul>
<li>Similarly<br>First-fit &amp; best-fit better than worst-fit in terms of speed and storage</li>
</ul>
</li>
</ul>
</li>
<li><p>50%规则<br>  使用First fit算法来分配内存时，会发现对于N个块已经被分配，有0.5N个块被浪费在碎片上。其中1/3的碎片可能无法使用，这就是“50%规则”</p>
</li>
</ul>
<p>分配出去的空间释放后大小未必能够匹配后续需分配的内存大小，导致 <strong>内存碎片 (memory fragmentation)</strong>  形成。</p>
<ul>
<li><p><strong>内存碎片 memory fragmentation</strong> </p>
<ul>
<li>内存中零散、未被充分利用的小块空闲内存</li>
<li>外部碎片 (external)<ul>
<li>总内存空间可满足要求，但不连续</li>
</ul>
</li>
<li><p>内部碎片 (internal)</p>
<ul>
<li>分配的空间可能大于需要</li>
<li>分区内部有被分配而未使用的空间</li>
</ul>
</li>
<li><p>过多碎片可能导致内存空间无法有效利用，也会增加分配内存的开销。</p>
</li>
</ul>
</li>
<li><p>解决方案</p>
<ol>
<li>内存紧缩/重排 compaction/shuffle<ul>
<li>效率问题</li>
<li>-&gt; 伙伴系统</li>
</ul>
</li>
<li>允许不连续分配 noncontiguous memory allocation<ul>
<li>内存的分页与分段 paging &amp; segmentation</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>Buddy System 伙伴系统*</strong></p>
<ul>
<li>将内存分成大小相等的块，每个块都有一个大小的指数级别，例如2的幂次方</li>
<li>当分配内存时，伙伴系统会按照2的幂次方去寻找最合适的可用块<ul>
<li>如果找到一个较大的块，它就会被拆分成两个较小的块，并将它们标记为伙伴块</li>
<li>当释放内存时，伙伴系统会将相邻的伙伴块合并成一个更大的块=</li>
</ul>
</li>
<li>可以尽量减少传统连续分配模式产生的内存碎片</li>
<li>使用比较复杂的数据结构管理伙伴关系和未分配内存</li>
<li>Linux</li>
</ul>
<h4 id="Non-contiguous-memory-allocation-非连续式内存分配"><a href="#Non-contiguous-memory-allocation-非连续式内存分配" class="headerlink" title="Non-contiguous memory allocation  非连续式内存分配"></a>Non-contiguous memory allocation  非连续式内存分配</h4><ul>
<li>allow noncontiguous physical address space</li>
</ul>
<h5 id="Paging-内存分页"><a href="#Paging-内存分页" class="headerlink" title="Paging 内存分页"></a>Paging 内存分页</h5><p><strong>Defination</strong></p>
<ul>
<li>FRAMES 框<ul>
<li>将物理内存分为固定大小的块<ul>
<li>大小为2的因数，512b-16MB</li>
<li>最小空间占用单位（依然可能存在内部碎片）</li>
</ul>
</li>
</ul>
</li>
<li>PAGES 页<ul>
<li>将逻辑内存分为同样大小的块</li>
</ul>
</li>
<li>运行方式<ul>
<li>需要N页内存以运行程序 = 寻找N个空闲页框</li>
</ul>
</li>
<li>PAGE TABLE 页表<ul>
<li>一种特殊的内存分配表，跟踪页与框的分配情况</li>
<li>将逻辑页的地址翻译为物理框的地址 (page id -&gt; frame id)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230316235007.png" alt=""></li>
</ul>
</li>
</ul>
<p><strong>Implementation</strong></p>
<ul>
<li><p>逻辑地址表示为 \<page-number, page offset></p>
<ul>
<li>divided by CPU</li>
<li>page number (p)<ul>
<li>页表中的页编号</li>
</ul>
</li>
<li>page offset (d)<ul>
<li>对应页/框内部所需信息的偏移量</li>
</ul>
</li>
</ul>
</li>
<li><p>Keep a page table</p>
<ul>
<li>PTBR: Page-table base register in CPU<ul>
<li>records the address of the table</li>
</ul>
</li>
<li>PTLR: Page-table length register in CPU<ul>
<li>indicates the length of the table</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Obviously, every data/instruction access requires 2 memory accesses  (access the table and allocate the unit according to the table)</p>
<ul>
<li>Add a <strong>TLB</strong> to accelerate<ul>
<li>translation lookaside buffer</li>
<li>record recent accessed table item</li>
<li>HIT<ul>
<li>fast access</li>
</ul>
</li>
<li>MISS<ul>
<li>load to TLB, try to hit next time</li>
</ul>
</li>
<li>EAT (Effective Access Time)<ul>
<li>Associative Lookup = ε time / unit</li>
<li>Hi ration = α</li>
<li>EAT = (1 + ε) α + (2 + ε)(1 – α) </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="The-realization-of-page-table-structure"><a href="#The-realization-of-page-table-structure" class="headerlink" title="The realization of page table structure"></a>The realization of page table structure</h5><p><strong>Hierarchical Page Tables 多层表</strong></p>
<p>将虚拟地址分成多个部分，每个部分都有一个表。</p>
<ul>
<li>windows</li>
<li>eg. 2-level paging table -&gt; forward-mapped page table<ul>
<li>10-bit page num*2 + 12-bit offset</li>
</ul>
</li>
</ul>
<p><strong>Hashed Page Tables 哈希页表</strong></p>
<ul>
<li>虚拟页号在虚拟地址中被哈希到哈希表中。</li>
<li>FreeBSD, Solaris</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230317005831.png" alt=""></p>
<p><strong>Inverted Page Tables 全局页表</strong></p>
<ul>
<li>由操作系统维护，用于所有进程的页表。</li>
<li>条目数等于主存中的帧数。</li>
<li>与传统的页表相比具有更小的内存占用（比较直接），但查找时间更长。</li>
<li>Linux</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230317005822.png" alt=""></p>
<h5 id="Segmentation-内存分段"><a href="#Segmentation-内存分段" class="headerlink" title="Segmentation 内存分段"></a>Segmentation 内存分段</h5><p>Memory-management scheme that supports user view of memory</p>
<ul>
<li><p>可以认为段是一种大小不固定的“页”</p>
</li>
<li><p>Logical address defined as <strong><segment-number, offset></strong></p>
<ul>
<li>( in paging scheme, we use <page-number, offset> )</li>
</ul>
</li>
<li><p>Segment table 分段表</p>
<ul>
<li>maps two-dimensional physical addresses</li>
</ul>
</li>
<li><p>each table entry has</p>
<ul>
<li>base<ul>
<li>contains the starting physical address where the segments reside in memory</li>
</ul>
</li>
<li>limit<ul>
<li>specifies the length of the segment  </li>
</ul>
</li>
</ul>
</li>
<li><p>Simularly keeping the <strong>Segment-Table</strong></p>
<ul>
<li>Segment-table base register (STBR)<ul>
<li>segment table’s location in memory  </li>
</ul>
</li>
<li>Segment-table length register (STLR) <ul>
<li>indicates number of segments  </li>
<li>used by a program:<ul>
<li>segment number s is legal if s &lt; STLR</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Segmentation-and-paging-scheme"><a href="#Segmentation-and-paging-scheme" class="headerlink" title="Segmentation and paging scheme"></a>Segmentation and paging scheme</h4><ul>
<li>Windows</li>
</ul>
<h3 id="Virtual-Memory-虚拟内存"><a href="#Virtual-Memory-虚拟内存" class="headerlink" title="Virtual Memory 虚拟内存"></a>Virtual Memory 虚拟内存</h3><ul>
<li><p>Virtual Address Space 虚拟地址空间</p>
<ul>
<li>Enables sparse address spaces with holes left for growth, dynamically  linked libraries, etc</li>
<li>easily shared during fork()</li>
<li>COW (Copy-on-write)</li>
<li>Lazy Swapper (Pager)<ul>
<li>never swaps a page into memory unless page will be needed</li>
</ul>
</li>
</ul>
</li>
<li><p>Valid-Invalid Bit</p>
<ul>
<li>each table entry associates with a ~ bit</li>
<li>v -&gt; memory resident ({address} v) </li>
<li>i -&gt; not-in-memory (i)</li>
<li>entry is i -&gt; <strong>page fault</strong></li>
</ul>
</li>
<li><p>Dirty bit</p>
<ul>
<li>each table entry associates with a ~ bit</li>
<li>if needed to be written to the disk, dirty bit = 1</li>
<li>reduce overhead of page transfers</li>
</ul>
</li>
<li><p>Page Fault 内存缺页</p>
<ul>
<li>if there is a reference to a page and the page is not in memory (i), the  reference will <strong>trap</strong> to operating system</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>Operating system looks at page table to decide:<br> Invalid reference -&gt; abort  / Just not in memory  </li>
<li><strong>Get</strong> empty frame  </li>
<li><strong>Swap</strong> page into frame via scheduled disk operation  </li>
<li>Reset tables to indicate page now in memory  (Set validation bit = v)</li>
<li>Restart the instruction that caused the page fault</li>
</ol>
</blockquote>
<p> -&gt; 如果不存在空闲页框？</p>
<ul>
<li>Page replacement 页面置换<ul>
<li>目标：找到一种会导致最少的内存缺页 page faults 的算法</li>
</ul>
</li>
</ul>
<ol>
<li>确定来源页在磁盘上的位置</li>
<li>试着找到一个空闲页框<ul>
<li>有 -&gt; 用</li>
<li>没有 -&gt; 使用页面置换算法找一个victime frame</li>
<li>Write victim frame to disk if dirty</li>
</ul>
</li>
<li>Bring the desired page into the (newly) free frame; update the page and frame tables  </li>
<li>Continue the process by restarting the instruction that caused the trap</li>
</ol>
<p>怎么选择 the desired page？</p>
<h4 id="Page-Replacement-Algorithms-页面替换算法"><a href="#Page-Replacement-Algorithms-页面替换算法" class="headerlink" title="Page-Replacement Algorithms 页面替换算法"></a>Page-Replacement Algorithms 页面替换算法</h4><p><strong>FIFO</strong></p>
<ul>
<li>First-In, First-Out</li>
<li>记录页表项进入TLB的时间戳</li>
<li>将最早进入TLB的页面替换出去</li>
</ul>
<p><strong>LRU</strong></p>
<ul>
<li>Least Recently Used</li>
<li>记录页表项在TLB中最后一次被访问的时间戳</li>
<li>将访问时间最早的页表项替换出去</li>
</ul>
<p><strong>Second-chance page replacement algorithm</strong></p>
<ul>
<li>给页表项附加一个引用位 reference bit（0/1）</li>
<li>当需要发生替换时，对于每个被遍历到的页表项：<ul>
<li>如果引用位为1，则设置为0并检查下一个页面<ul>
<li>每次替换都从上次结束的位置继续</li>
</ul>
</li>
<li>如果引用位为0，则进行替换并初始化引用位为1</li>
</ul>
</li>
</ul>
<h2 id="大容量存储系统"><a href="#大容量存储系统" class="headerlink" title="大容量存储系统"></a>大容量存储系统</h2><h3 id="Disk-基础"><a href="#Disk-基础" class="headerlink" title="Disk 基础"></a>Disk 基础</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230425102536.png" alt=""><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230331010733.png" alt=""></p>
<p><strong>Hard Disk Drive (HDD)</strong></p>
<ul>
<li>Overview<ul>
<li>Drives rotate at 60 to 250 times per second  </li>
<li>Transfer rate is rate at which data flows between drive and computer  </li>
<li><strong>Positioning time (random-access time)</strong> is time to move disk arm to <strong>desired cylinder (seek time)</strong> and <strong>time for desired sector to rotate under  the disk head (rotational latency)</strong></li>
</ul>
</li>
</ul>
<ol>
<li><p>柱面 (cylinder) &amp; 磁道（track）</p>
<ul>
<li>一个盘片的同心圆轨道称为track，所有盘片上的Track组成的一个柱面状的物理结构程伟cylinder</li>
<li>在同一Cylinder上的所有track可以同时被磁头访问</li>
<li>按cylinder编号不按track编号</li>
<li>（SSD不存在这两个概念）</li>
</ul>
</li>
<li><p>扇区 (sector)</p>
<ul>
<li>一个盘片的同心圆轨道内的一个扇形区域</li>
<li>扇区0是第一个磁道的第一块扇区</li>
<li>每个track的扇区数不固定，与磁盘设计时的角速度有关</li>
</ul>
</li>
<li><p>块（block）：</p>
<ul>
<li>由多个扇区组成，大小由OS决定</li>
</ul>
</li>
<li>簇（cluster）：<ul>
<li>一组相邻的扇区的集合，大小可以由用户修改</li>
<li>大多数文件系统会将多个块组成一个簇（cluster）进行管理。簇是文件系统中的最小单位，也可以被视为文件系统与磁盘交互的基本单位。</li>
</ul>
</li>
</ol>
<ul>
<li>逻辑地址的编码<ul>
<li>large 1-d arrays of logical blocks (smallest unit)</li>
<li>is mapped into the sectors of the disk sequentially  </li>
<li>Mapping proceeds in order through that track, <strong>then the rest of the tracks in that cylinder</strong>, and then through the rest of the cylinders from outermost to innermost  </li>
<li>Difficulty in mapping from logical to physical address</li>
<li>Except for bad sectors  <ul>
<li>操作系统检查坏块并在编码时排除</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Solid-State Disks (SSD)</strong></p>
<ol>
<li>页（page）<ul>
<li>页是SSD中最小的可寻址单元，大小由SSD自身决定，通常为4KB或8KB。</li>
</ul>
</li>
<li>块（block）<ul>
<li>类似HHD。由多个页构成，大小由SSD自身决定</li>
<li>为了增大擦除时一次性操作的块的大小延长寿命，在SSD中通常更大，通常为128KB或256KB大小。（理由后面细说）</li>
</ul>
</li>
</ol>
<h3 id="Disk-Scheduling-Algorithms"><a href="#Disk-Scheduling-Algorithms" class="headerlink" title="Disk-Scheduling Algorithms"></a>Disk-Scheduling Algorithms</h3><p>Idle disk can immediately work on I/O request<br>Busy disk means work must be queued<br>(Optimization algorithms only make sense when a queue exists)</p>
<ul>
<li><p>FCFS<br>  按queue处理</p>
</li>
<li><p>SSTF (Shortest Seek Time First)<br>  selects the request with the minimum seek time  from the current head position (当前最近)</p>
</li>
<li><p>SCAN<br>  The disk arm starts <strong>at one end of the disk</strong>, and <strong>moves toward the other end</strong>,<br>  <strong>servicing</strong> requests <strong>until it gets to the other end of the disk</strong>, where the head<br>  movement is reversed and service continues.</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230425022644.png" alt=""></p>
<ul>
<li><p>C-SCAN<br>  The head moves <strong>from one end of the disk to the other,</strong> servicing requests as it goes. When it reaches the other end, it <strong>immediately returns</strong> to the beginning of the disk, <strong>without servicing</strong> any requests on the return trip.</p>
</li>
<li><p>C-LOOK<br>  Similar to C-SCAN, but doesn’t reach the two ends.<br>  Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230425022709.png" alt=""></p>
<p>-》 <strong>in C-XXXX</strong> , arm services always <strong>occur in one direction.</strong> when they are moving are the opposite direction, they ‘<strong>immediately returns</strong>‘.</p>
<h3 id="SSD-vs-HDD"><a href="#SSD-vs-HDD" class="headerlink" title="SSD vs HDD"></a>SSD vs HDD</h3><ul>
<li><p>Nonvolatile memory devices 非易失性存储器设备</p>
</li>
<li><p>Storage capacity / price<br>  capacity: HDD usually &gt; SSD</p>
<pre><code>  magnetic disks (HDD) hold much more data.
</code></pre><p>  price : SDD usually &gt; HDD (per MB)</p>
</li>
<li><p>Reliability</p>
<ul>
<li>SSD &gt; HDD</li>
<li>SSDs have no moving parts (like magnetic disks and read/write heads)<ul>
<li>less possible to damage</li>
</ul>
</li>
</ul>
</li>
<li><p>Lifespan</p>
<ul>
<li>SSD &lt;&lt; HDD</li>
<li>-&gt; SSD need to be <strong>carefully</strong> managed (storage units have a certain erasing and writing life) -&gt; <strong>disk management</strong></li>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
<li><p>Speed</p>
<ul>
<li>SSD &gt;&gt; HDD</li>
<li>No moving parts, so no seek time or rotational latency</li>
</ul>
</li>
<li><p>Bus speed</p>
<ul>
<li>SSD requires a direct connection to a high-speed bus (such as PCI) for maximum performance</li>
<li>(while HDDs are not subject to this limitation)</li>
</ul>
</li>
<li><p>==Disk management &amp; Space management==</p>
<ul>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
</ul>
<h3 id="Space-amp-Disk-Management"><a href="#Space-amp-Disk-Management" class="headerlink" title="Space &amp; Disk Management"></a>Space &amp; Disk Management</h3><p><strong>HDD</strong></p>
<ul>
<li>-&gt; Dividing a disk into <strong>sectors</strong> that the disk controller can read and write  <ul>
<li>Each sector can hold header information + data + error correction code (<strong>ECC</strong>)  </li>
<li>Usually 512b data but can be selectable  </li>
</ul>
</li>
<li>OS needs to record its own data structures on the disk  <ul>
<li>Part groups of cylinders, each treated as a logical disk  </li>
<li><strong>Logical formatting</strong> or “making a file system”  </li>
<li>To increase efficiency most file systems <strong>group blocks into clusters</strong><br>  Disk I/O done in blocks ; File I/O done in clusters</li>
</ul>
</li>
<li>Boot block initializes system<ul>
<li>The bootstrap is stored in ROM  </li>
<li><strong>Bootstrap loader</strong> program stored in boot blocks of boot partition  </li>
</ul>
</li>
<li>Methods such as <strong>sector sparing</strong> used to handle bad blocks</li>
</ul>
<p>MBR</p>
<ul>
<li>Boot code + partition table (contains pointer to boot partition)</li>
</ul>
<p><strong>SSD</strong></p>
<ul>
<li>Read and written in <strong>“page”</strong> increments (think sector) <ul>
<li>==but can’t overwrite in place==<ul>
<li>Must first be erased, and erases happen in larger “block” increments</li>
<li>要修改或擦除一个页，需要先将整个块读取到内存中，然后进行修改或擦除，最后再将整个块写回SSD。(所以SSD的块常常比HHD大的多，以增大每次擦写的大小、减小擦写次数)</li>
</ul>
</li>
<li>Can only be erased a limited number of times before worn out ~ 100,000  </li>
<li>Life span measured in drive writes per day (<strong>DWPD</strong>)  <ul>
<li>A 1TB NAND drive with rating of 5DWPD is expected to have 5TB per day written within warrantee period without failing</li>
</ul>
</li>
<li>块级别的操作对于SSD的性能和寿命管理是非常重要的。-》</li>
</ul>
</li>
</ul>
<p><strong>NAND Flash Controller Algorithms</strong>  </p>
<ul>
<li>With no overwrite, pages end up with mix of valid and invalid data. We need ways  to manage them: <ul>
<li>flash translation layer (FTL) table (a part of NAND flash)<ul>
<li>Track which logical blocks are valid</li>
</ul>
</li>
<li>TRIM (a instruction involving SSD and OS)<ul>
<li>inform which logical blocks are invalid more flexibly and timely</li>
</ul>
</li>
<li>Garbage collection (GC)<ul>
<li>Allocates overprovisioning to provide working space for GC  </li>
<li>垃圾回收是SSD内部的一种自动化操作，用于清理和整理闲置和无效的页。当文件被删除或修改时，SSD的页可能会变得闲置或无效，但这些页实际上仍然占据着宝贵的存储空间。垃圾回收操作会定期或在需要时将这些闲置和无效的页整理到一起，并执行擦除操作，以便可以重新分配给新的数据，从而提高SSD的存储效率。</li>
</ul>
</li>
</ul>
</li>
<li>Write Wear Leveling (均衡写入耗损) <ul>
<li>Each cell has lifespan, try to write equally to all cells</li>
<li>这可以通过在写入新数据时选择尽可能少使用写入次数较多的块，或将写入数据随机分布到多个块中来实现。</li>
</ul>
</li>
</ul>
<h3 id="Disk-Attachment"><a href="#Disk-Attachment" class="headerlink" title="Disk Attachment"></a>Disk Attachment</h3><ul>
<li>Drive attached to computer via I/O bus  <ul>
<li>Host controller in computer uses bus to <strong>talk to disk controller</strong> built into drive  </li>
<li>Busses vary (protocols vary)<ul>
<li>接口协议规定了硬件设备之间的通信协议和通信方式，而数据总线BUS则是物理连接这些设备之间的通信通道。</li>
<li>including EIDE, ATA, SATA, USB, SCSI, Fiber Channel, SAS, Firewire…</li>
<li>家用计算机的CPU多使用PCI、SATA等接口协议，FC更多用于企业计算机和数据中心环境。</li>
</ul>
</li>
</ul>
</li>
<li><strong>SCSI</strong>（Small Computer System Interface）<ul>
<li>过去比较常见</li>
<li>a bus, up to 16 devices on one cable</li>
<li>SCSI initiator 发起器 requests operation 发送操作请求 and SCSI targets 目标设备 perform tasks</li>
<li>Each target can have up to 8 logical units (disks attached to device controller)  </li>
</ul>
</li>
<li><strong>FC</strong> （Fiber Channel） 光纤通道 <ul>
<li>a <strong>high</strong>-speed serial architecture  </li>
<li>Can be switched fabric with 24-bit address space – the basis of storage area networks (SANs 存储区域网络) in which many hosts attach to many storage  units</li>
<li>通常用于需要大规模存储和高速数据传输的应用场景</li>
</ul>
</li>
</ul>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><ul>
<li>Redundant Arrays of Independent Disks (RAIDs)  </li>
<li>RAID– multiple disk drives provides reliability via redundancy  <ul>
<li>Mirroring  ( -&gt; a second copy)<ul>
<li>duplicate every disk  </li>
</ul>
</li>
<li>Parity bit  ( -&gt; error-correcting bit)</li>
</ul>
</li>
<li>Parallel access to multiple disk improves performance  <ul>
<li>bit-level striping  <ul>
<li>split the bits of each byte across multiple disks  </li>
</ul>
</li>
<li>block-level striping  <ul>
<li>blocks of a file are striped across multiple disks  </li>
</ul>
</li>
</ul>
</li>
<li>RAID is arranged into seven or more different levels</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415031202.png" alt=""></p>
<p>RAID 6: P + Q redundancy  </p>
<ul>
<li>Reed-Solomon codes  <ul>
<li>2 bits of redundant data are stored for every 4 bits of data  </li>
<li>在RAID6中，数据被分布式地存储在多个磁盘驱动器中，同时通过计算奇偶校验信息对数据进行冗余存储。RAID6采用两个奇偶校验盘（P和Q盘）来存储奇偶校验信息，从而实现了对两个磁盘驱动器的故障容忍。</li>
</ul>
</li>
</ul>
<h3 id="Network-Attached-Storage"><a href="#Network-Attached-Storage" class="headerlink" title="Network-Attached Storage"></a>Network-Attached Storage</h3><ul>
<li>Network-attached storage (NAS) is storage made available over a network rather than over a local connection (such as a bus)  <ul>
<li>Remotely attaching to file systems  </li>
</ul>
</li>
<li>Implemented via remote procedure calls (RPCs) between host and storage over typically TCP or UDP on IP network  </li>
<li>iSCSI protocol uses IP network to carry the SCSI protocol  <ul>
<li>Remotely attaching to devices (blocks) -&gt; virtual disks</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415031456.png" alt=""></p>
<ul>
<li>Storage Area Network（SAN）存储区域网络<ul>
<li>Common in large storage environments  </li>
<li>Multiple hosts attached to multiple storage arrays - flexible</li>
<li>use high-speed buses，like Fibre Channel or iSCSI</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415031437.png" alt=""></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>A file is a named collection of related information that is recorded on<br>secondary storage.  </p>
<ul>
<li><strong>Attributes</strong><ul>
<li>Name</li>
<li><strong>Identifier</strong> - unique tag(num) identifies file within file sys</li>
<li>Type<ul>
<li>Text  </li>
<li>Source/object programs  </li>
<li>Executable programs  </li>
<li>Database records  </li>
<li>Graphic images  </li>
<li>Multimedia</li>
</ul>
</li>
<li>Location<ul>
<li>pointer to file location on device</li>
</ul>
</li>
<li>Size</li>
<li>Protection<ul>
<li>controls who can do reading, writing, executing</li>
</ul>
</li>
<li>Time, Date, User identification</li>
</ul>
</li>
<li>Information about files are kept in the directory structure, which is maintained on the disk</li>
</ul>
<h3 id="File-operations"><a href="#File-operations" class="headerlink" title="File operations"></a>File operations</h3><ul>
<li>Create  </li>
<li>Write  </li>
<li>Read  </li>
<li>Reposition within file  </li>
<li>Delete  </li>
<li><p>Truncate  </p>
</li>
<li><p>The other operations can be implemented by the primitive ones.</p>
</li>
</ul>
<h4 id="Open-files"><a href="#Open-files" class="headerlink" title="Open files"></a>Open files</h4><p>Several pieces of data are needed to manage open files.</p>
<ul>
<li><strong>Open-file table</strong><ul>
<li>tracks open files  </li>
</ul>
</li>
<li><strong>File pointer</strong><ul>
<li>pointer to last read/write location, per process that has the file open  </li>
</ul>
</li>
<li>File-open <strong>count</strong><ul>
<li>counter of number of <strong>times</strong> a file is opened</li>
<li>allow removal of data from open-file table when last process closes it</li>
</ul>
</li>
<li>Disk <strong>location</strong> of the file<ul>
<li>stores data access information</li>
</ul>
</li>
<li><strong>Access rights</strong><ul>
<li>provides per-process access mode information</li>
<li><strong>Protection</strong>: decide access rights<ul>
<li>File owner/creator should be able to control:<ul>
<li>what can be done  </li>
<li>by whom  </li>
</ul>
</li>
<li>Types of access  <ul>
<li><strong>Read</strong>  </li>
<li><strong>Write</strong>  </li>
<li><strong>Execute</strong>  </li>
<li>Append  </li>
<li>Delete  </li>
<li>List</li>
</ul>
</li>
<li>Three classes of users<ul>
<li>owner, group, public (in unix/linux)<br>（windows: owner, group, others  -&gt; different names)</li>
<li>you can define the right by:<ul>
<li><code>chgrp G game</code></li>
<li>g is a unique group name, you attach it to the file</li>
<li><code>chmod 761 game</code></li>
<li>7 for owner, 6 for group, 1 for public</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Access methods</strong><ul>
<li>Sequential access<ul>
<li>read/write next</li>
<li>reset</li>
</ul>
</li>
<li>Direct access<ul>
<li>read/write n (n = relative block/byte number)</li>
<li>position to n<ul>
<li>read/write next</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Disk-Structure"><a href="#Disk-Structure" class="headerlink" title="Disk Structure"></a>Disk Structure</h3><ul>
<li>Disk can be subdivided into <strong>partitions</strong> 分区 (minidisks, slices)<ul>
<li>Disks/partitions can be RAID protected against failure</li>
<li>Disks/partitions can be used <strong>raw</strong> <ul>
<li>raw: without a file system, or formatted with a file system</li>
</ul>
</li>
</ul>
</li>
<li>Entity 实体 containing file system known as a <strong>volume</strong> 卷<ul>
<li>Each <strong>volume</strong> tracks file system’s info in <strong>device directory</strong> 设备目录 or <strong>volume table of contents</strong> 卷目录</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415230811.png" alt=""></p>
<h3 id="File-Directory"><a href="#File-Directory" class="headerlink" title="File Directory"></a>File Directory</h3><p>Organize the Directory (Logically) to Obtain  </p>
<ul>
<li>Efficiency – locating a file quickly  </li>
<li>Naming – convenient to users  <ul>
<li>Two users can have same name for different files  </li>
<li>The same file can have several different names  </li>
</ul>
</li>
<li>Grouping – logical grouping of files by properties, (e.g., all Java programs, all games, …)</li>
</ul>
<p><strong>Single-Level Directory</strong>  </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415231146.png" alt=""></p>
<ul>
<li>A single directory for all users  </li>
<li>Efficiency problem  </li>
<li>Naming problem  </li>
<li>Protection of users’ private files  </li>
<li>Grouping problem</li>
</ul>
<p><strong>Two-Level Directory</strong>  </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415231208.png" alt=""></p>
<ul>
<li>Separate directory for each user  </li>
<li>Can have the same file name for different user  </li>
<li>A little bit more efficient searching  </li>
<li>Path name  </li>
<li>No grouping capability</li>
</ul>
<p><strong>Tree-Stuctured Directory</strong><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415231245.png" alt=""><br><strong>Acyclic-Graph Directories</strong></p>
<p>Have shared subdirectories and files<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415231309.png" alt=""><em>**</em></p>
<ul>
<li>Two different names (aliasing)</li>
<li>New directory entry type<ul>
<li>Link – another name (pointer) to an existing file</li>
<li>Resolve the link – follow pointer to locate the file</li>
</ul>
</li>
<li><p>If dict deletes count -&gt; dangling pointer</p>
</li>
<li><p>Solutions</p>
<ul>
<li>Backpointers, so we can delete all pointers</li>
<li>Entry-hold-count solution</li>
</ul>
</li>
</ul>
<p><strong>General Graph Directory</strong></p>
<h3 id="File-Allocation-Methods"><a href="#File-Allocation-Methods" class="headerlink" title="File Allocation Methods"></a>File Allocation Methods</h3><p>An allocation method refers to how disk blocks are allocated for files  </p>
<h4 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h4><ul>
<li>连续分配 each file occupies a set of contiguous blocks  <ul>
<li>Simple<ul>
<li>starting location (block #)</li>
<li>length (number of blocks)</li>
</ul>
</li>
<li>Best performance in most cases  </li>
<li>Problems：<ul>
<li>Finding space for file  </li>
<li>Knowing file <strong>size</strong>  </li>
<li>External fragmentation 外部碎片<ul>
<li>need for compaction off-line (downtime) or on-line 需要离线（停机）整理碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415232426.png" alt=""></p>
<h4 id="Linked-Allocation"><a href="#Linked-Allocation" class="headerlink" title="Linked Allocation"></a>Linked Allocation</h4><p>Each file is a linked list of disk blocks: blocks may be scattered<br>anywhere on the disk<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416003935.png" alt=""></p>
<p>each file is a linked list of blocks  </p>
<ul>
<li>Each block <ul>
<li>a pointer to next block  </li>
<li>file ends at nil pointer  </li>
</ul>
</li>
<li>No external fragmentation  </li>
<li>Free space management system called when new block needed  </li>
<li>Improve efficiency by clustering blocks into groups but increases  internal fragmentation</li>
<li>Problem<ul>
<li>Reliability</li>
<li>Locating a block can take many I/Os and disk seeks</li>
</ul>
</li>
</ul>
<h4 id="File-Allocation-Table-FAT"><a href="#File-Allocation-Table-FAT" class="headerlink" title="File-Allocation Table (FAT)"></a>File-Allocation Table (FAT)</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416004114.png" alt=""></p>
<ul>
<li>Beginning of volume has a table, indexed by block number <ul>
<li>Records allocation information and status of file blocks or clusters<ul>
<li>Occupied<ul>
<li>Uses a linked list structure to link the occupied file blocks or clusters</li>
</ul>
</li>
<li>Unallocated<ul>
<li>Marked with corresponding status flags</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Much like a linked list, but faster on disk and cacheable  </li>
<li><p>New block allocation simple </p>
</li>
<li><p>DOS / Windows</p>
</li>
</ul>
<h4 id="FAT-vs-linked-allocation"><a href="#FAT-vs-linked-allocation" class="headerlink" title="FAT vs linked allocation"></a>FAT vs linked allocation</h4><ul>
<li>存储方式<ul>
<li>FAT文件系统<ul>
<li>将整个文件的分配情况记录在文件分配表中</li>
<li>一次性读取整个文件的所有文件块地址到队列中，从而更好地进行访问规划</li>
<li>这对于机械硬盘等需要顺序访问且对等待队列的优化敏感的存储设备来说尤为重要</li>
</ul>
</li>
<li>链式分配文件系统<ul>
<li>逐个读取文件块，并且每个文件块只记录下一个文件块的位置信息。</li>
<li>需要不断地从磁盘读取下一个文件块的位置</li>
</ul>
</li>
</ul>
</li>
<li>如何找空格子<ul>
<li>都需要遍历获取已占用的格子的信息<ul>
<li>FAT：查询文件分配表直到找到未分配的块</li>
<li>链式分配：从文件系统的起始位置开始，沿着链表遍历已占用的文件块，直到找到一个未占用的文件块</li>
<li>这时，FAT就显著比链式分配快</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Indexed-Allocation"><a href="#Indexed-Allocation" class="headerlink" title="Indexed Allocation"></a>Indexed Allocation</h4><p>Each file has its own index block(s) of pointers to its data blocks </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416010327.png" alt=""></p>
<ul>
<li>Random access  </li>
<li>Without external fragmentation  </li>
<li>Need index table</li>
</ul>
<h5 id="I-node-management"><a href="#I-node-management" class="headerlink" title="I-node management"></a>I-node management</h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416010454.png" alt=""></p>
<ul>
<li>I-nodes have limited size, so we need mutiple I-nodes linked</li>
</ul>
<p>-&gt; <strong>EXAMPLE</strong></p>
<ul>
<li>Suppose a file system is constructed using blocks of 32 bytes. A pointer needs 4 bytes. The I-node structure is as follows (word, value):</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>num</th>
<th>content</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>permission word</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>direct block</td>
<td>linked to content directly</td>
</tr>
<tr>
<td>2</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>single-indirect</td>
<td>linked to another block</td>
</tr>
<tr>
<td>7</td>
<td>double-indirect</td>
<td>linked to a block which each 8 bytes points to a such unit</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>Assume that free blocks are allocated in logical order starting with block 11. Also it has been determined that blocks 17 and 32 are <strong>bad</strong> and cannot be allocated.  </p>
</li>
<li><p>Draw a block diagram showing the structure of the I-node and the blocks that are allocated for  </p>
<ul>
<li>Original file size of <strong>3 blocks</strong>  (IN THE 1ST NODE)</li>
<li>Adding 4 blocks   (single-indirect is enough)</li>
<li>Adding 17 blocks (need double-indirect)</li>
</ul>
</li>
</ul>
<p>3+4blocks (4 in first I-node and 3 in single-indirect)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416012148.png" alt=""></p>
<p>3+4+17blocks (4 in first I-node, 8 in single-indirect,11 in double-indirect )</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416012023.png" alt=""></p>
<p><strong>Quiz</strong></p>
<p>Suppose a file system is constructed using blocks of 32 bytes. A pointer<br>needs 4 bytes. The I-node structure is as follows (word, value):  </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>num</th>
<th>content</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>permission word</td>
</tr>
<tr>
<td>1</td>
<td>file size</td>
</tr>
<tr>
<td>2</td>
<td>direct block</td>
</tr>
<tr>
<td>3</td>
<td>direct block</td>
</tr>
<tr>
<td>4</td>
<td>direct block</td>
</tr>
<tr>
<td>5</td>
<td>single-indirect</td>
</tr>
<tr>
<td>6</td>
<td>double-indirect</td>
</tr>
<tr>
<td>7</td>
<td>triple-indirect</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Assume that free blocks are allocated in logical order starting with block 100. Also it has been determined that blocks 107, 108, 109, and 112 are bad and cannot be allocated.  </li>
<li>Draw a block diagram showing the structure of the I-node and the blocks that are allocated for<ul>
<li>Original file size of 3 blocks  </li>
<li>Adding 7 blocks</li>
<li>Adding 24 blocks</li>
<li>Adding 64 blocks </li>
</ul>
</li>
</ul>
<h2 id="I-O-系统"><a href="#I-O-系统" class="headerlink" title="I/O 系统"></a>I/O 系统</h2><h3 id="I-O-Hardware"><a href="#I-O-Hardware" class="headerlink" title="I/O Hardware"></a>I/O Hardware</h3><ul>
<li><p>Incredible variety of I/O devices  </p>
<ul>
<li>Storage devices <ul>
<li>(disks, tapes)  </li>
</ul>
</li>
<li>Transmission devices <ul>
<li>(network interface, Bluetooth)  </li>
</ul>
</li>
<li>Human-interface devices <ul>
<li>(screen, keyboard, mouse, audio in and out)  </li>
</ul>
</li>
</ul>
</li>
<li><p>Common concepts – signals from I/O devices interface with computer  </p>
<ul>
<li>Port 端口<ul>
<li>connection point for device  </li>
</ul>
</li>
<li>Bus – a set of wires and a strictly defined protocol  <ul>
<li>Daisy chain  链式连接 <ul>
<li>（PC -&gt; device A -&gt; device B -&gt; device C…)</li>
</ul>
</li>
<li>Shared direct access 共享直接访问<ul>
<li>I/O设备共用数据总线</li>
</ul>
</li>
</ul>
</li>
<li>Controller (host adapter 主机适配器)<ul>
<li>electronics that operate port, bus, device</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>PCIE example<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416014446.png" alt=""></p>
<ul>
<li><p>Hardware structure</p>
</li>
<li><p>registers</p>
<ul>
<li>place data/addr/commands</li>
</ul>
</li>
</ul>
<h3 id="Addressing-amp-instruction-system"><a href="#Addressing-amp-instruction-system" class="headerlink" title="Addressing &amp; instruction system"></a>Addressing &amp; instruction system</h3><ol>
<li><p>Memory mapped I/O<br> share address space with computer’s memory<br> r/w I/O just like memory<br> no special commands</p>
</li>
<li><p>Isolated I/O<br> seperate address space<br> need I/O &amp; memory select lines<br> special commands</p>
</li>
</ol>
<p><strong>(以下段落内容与计算机组成重复)</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416020129.png" alt=""></p>
<h3 id="I-O-system"><a href="#I-O-system" class="headerlink" title="I/O system"></a>I/O system</h3><p>when cpu issues I/O request, cpu may have to wait for response? (low efficiency)</p>
<p>-&gt;</p>
<p><strong>INTERRUPTS</strong> -&gt; use interrupt handler to free cpu</p>
<ul>
<li>Checked by processor after each instruction  <ul>
<li>Interrupt handler receives interrupts</li>
</ul>
</li>
<li>Nonmaskable<ul>
<li>reserved for events such as unrecoverable memory errors  </li>
</ul>
</li>
<li>Maskable<ul>
<li>can be ignored or delayed, for device controllers to request service  </li>
</ul>
</li>
<li>Interrupt vector to dispatch interrupt to correct handler  <ul>
<li>Context switch at start and end  </li>
<li>Interrupt chaining  </li>
<li>Based on priority</li>
</ul>
</li>
</ul>
<h4 id="Programmed-I-O"><a href="#Programmed-I-O" class="headerlink" title="Programmed I/O"></a>Programmed I/O</h4><p>the CPU directly controls I/O hardware<br>Cpu:<br>    issues request<br>    continuously check response<br>     read and write</p>
<h4 id="Interrupt-Driven-I-O"><a href="#Interrupt-Driven-I-O" class="headerlink" title="Interrupt-Driven I/O"></a>Interrupt-Driven I/O</h4><p>free CPU from I/O event</p>
<p>Cpu:<br>    issue request<br>    be interrupted when I/O module is ok<br>    check read status and read, and write to memory</p>
<h4 id="Direct-Memory-Access-DMA"><a href="#Direct-Memory-Access-DMA" class="headerlink" title="Direct Memory Access (DMA)"></a>Direct Memory Access (DMA)</h4><p>free CPU from I/O event &amp; <strong>data writing</strong></p>
<p>Cpu:<br>    tells DMA the request<br>    DMA interrupts Cpu when OK, and tells Cpu</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Interactionwith I/O Device</th>
<th>Programmed I/O</th>
<th>Interrupt-Driven I/O</th>
<th>Direct Memory Access</th>
</tr>
</thead>
<tbody>
<tr>
<td>waiting for the device</td>
<td>software(instructions on cpu)</td>
<td>hardware</td>
<td>hardware</td>
</tr>
<tr>
<td>transfer device data to mem</td>
<td>software</td>
<td>software</td>
<td>hardware</td>
</tr>
</tbody>
</table>
</div>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1.html">现代操作系统CS2310 （上）进程管理</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3.html">现代操作系统CS2310 （附）虚拟机和分布式</a></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      <p>评论区仅供交流~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="aleryxiao/aleryxiao.github.io" data-repo-id="R_kgDOIdw0jw" data-category="Announcements" data-category-id="DIC_kwDOIdw0j84CTXeH" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/categories">分类</a><a href="/tags">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs14">整理</span><a href="/wiki">文件夹</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friend">友链</a><a href="/guestbook">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about">关于</a><a target="_blank" rel="noopener" href="https://github.com/aleryxiao">GitHub</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://space.bilibili.com/19610138">@AleryXiao</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
