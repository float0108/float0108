<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>courseNotes：现代操作系统2-CS2310 - 極楽浄土</title>

  
    <meta name="description" content="SJTU-CS2310 现代操作系统 课程笔记2">
<meta property="og:type" content="website">
<meta property="og:title" content="现代操作系统2-CS2310">
<meta property="og:url" content="https://float0108.github.io/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2.html">
<meta property="og:site_name" content="極楽浄土">
<meta property="og:description" content="SJTU-CS2310 现代操作系统 课程笔记2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316232506.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316232901.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316235007.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230317005831.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230317005822.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230331010733.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031202.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031456.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031437.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415230811.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231146.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231208.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231245.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415231309.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415232426.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416003935.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416004114.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416010327.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416010454.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416012148.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416012023.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416014446.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416020129.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416022332.png">
<meta property="article:published_time" content="2023-03-10T15:54:37.000Z">
<meta property="article:modified_time" content="2024-02-19T02:16:53.117Z">
<meta property="article:author" content="AleryXiao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316232506.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="極楽浄土" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/site_assets/favicon.jpg">
  

  

  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/site_assets/head.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">極楽浄土</div><div class="sub normal cap">フロトの理发店</div><div class="sub hover cap" style="opacity:0"> @AleryXiao</div></a></div>

<nav class="menu dis-select"><a class="nav-item" href="/">posts</a><a class="nav-item active" href="/wiki/">collection</a><a class="nav-item" href="/about/">about</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/files/courseNotes/" placeholder="在 /files/courseNotes/ 中搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">现代操作系统2-CS2310</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.html#start"><span class="toc-text">计算机系统结构-CS2305</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(8086).html"><span class="toc-text">计算机组成-汇编语言-CS2307</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%80%A7.html"><span class="toc-text">算法与复杂性-CS2308</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1.html"><span class="toc-text">现代操作系统CS2310 （上）进程管理</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2.html"><span class="toc-text">现代操作系统2-CS2310</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides8-Memory"><span class="toc-text">Slides8 Memory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Management"><span class="toc-text">Memory Management</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Contiguous-memory-allocation"><span class="toc-text">Contiguous memory allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Multiple-partition-allocation"><span class="toc-text">Multiple-partition allocation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-contiguous-memory-allocation"><span class="toc-text">Non-contiguous memory allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Defination"><span class="toc-text">Defination</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Implement"><span class="toc-text">Implement</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Page-table-structure"><span class="toc-text">Page table structure</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Segmentation"><span class="toc-text">Segmentation</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides9-Virtual-Memory"><span class="toc-text">Slides9 Virtual Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides10-Mass-Storage-Systems"><span class="toc-text">Slides10 Mass-Storage Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-stucture"><span class="toc-text">Disk stucture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview-of-Mass-Storage-Structure"><span class="toc-text">Overview of Mass Storage Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Scheduling-Algorithms"><span class="toc-text">Disk-Scheduling Algorithms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSD-vs-HDD"><span class="toc-text">SSD vs HDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Space-amp-Disk-Management"><span class="toc-text">Space &amp; Disk Management</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#More-About-Clusters-Blocks-and-Tracks-%E2%80%A6"><span class="toc-text">More About Clusters, Blocks and Tracks …</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HDD"><span class="toc-text">HDD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSD"><span class="toc-text">SSD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Attachment"><span class="toc-text">Disk Attachment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID"><span class="toc-text">RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-Attached-Storage"><span class="toc-text">Network-Attached Storage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides11-File-System"><span class="toc-text">Slides11 File System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File"><span class="toc-text">File</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-operations"><span class="toc-text">File operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Open-files"><span class="toc-text">Open files</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Structure"><span class="toc-text">Disk Structure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Directory"><span class="toc-text">File Directory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Allocation-Methods"><span class="toc-text">File Allocation Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Contiguous-Allocation"><span class="toc-text">Contiguous Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linked-Allocation"><span class="toc-text">Linked Allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#File-Allocation-Table-FAT"><span class="toc-text">File-Allocation Table (FAT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FAT-vs-linked-allocation"><span class="toc-text">FAT vs linked allocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Indexed-Allocation"><span class="toc-text">Indexed Allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#I-node-management"><span class="toc-text">I-node management</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides12-I-O-System"><span class="toc-text">Slides12 I&#x2F;O System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-Hardware"><span class="toc-text">I&#x2F;O Hardware</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Addressing-amp-instruction-system"><span class="toc-text">Addressing &amp; instruction system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O-system"><span class="toc-text">I&#x2F;O system</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Programmed-I-O"><span class="toc-text">Programmed I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interrupt-Driven-I-O"><span class="toc-text">Interrupt-Driven I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Direct-Memory-Access-DMA"><span class="toc-text">Direct Memory Access (DMA)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides13-Virtual-Machines"><span class="toc-text">Slides13 Virtual Machines</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Overview"><span class="toc-text">Overview</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides14-Distributed-System-Structures"><span class="toc-text">Slides14 Distributed System Structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Slides15-Distributed-System-Systems"><span class="toc-text">Slides15 Distributed System Systems</span></a></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F0.html"><span class="toc-text">现代操作系统CS2310 速效版</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3.html"><span class="toc-text">现代操作系统CS2310 （附）虚拟机和分布式</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2022(2)/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><span class="toc-text">高级数据结构-SE2322</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2023(1)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"><span class="toc-text">CS3311 计算机网络</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2023(1)/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80.html"><span class="toc-text">密码学与信息安全基础-CS3314</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/2023(1)/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%88B%E7%B1%BB%EF%BC%89.html"><span class="toc-text">人工智能-CS3317</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95.html"><span class="toc-text">软件测试-SE3336</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.html"><span class="toc-text">软件测试-SE3336</span></a></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">collection</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/files/courseNotes/2022(2)/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.html">courseNotes</a></div><div id="post-meta">更新于&nbsp;<time datetime="2024-02-19T02:16:53.117Z">2024-02-19</time></div></div>

  <article class='md-text content wiki'>
  <h1 class="article-title"><span>现代操作系统2-CS2310</span></h1>
  <h2 id="Slides8-Memory"><a href="#Slides8-Memory" class="headerlink" title="Slides8 Memory"></a>Slides8 Memory</h2><p>MMU<br>    relocation register<br>    CPU -(Logical Addr)&gt; MMU -(Physical Address)&gt; memory</p>
<h3 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h3><h4 id="Contiguous-memory-allocation"><a href="#Contiguous-memory-allocation" class="headerlink" title="Contiguous memory allocation"></a>Contiguous memory allocation</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230316232506.png" alt=""></p>
<h5 id="Multiple-partition-allocation"><a href="#Multiple-partition-allocation" class="headerlink" title="Multiple-partition allocation"></a>Multiple-partition allocation</h5><ul>
<li>When a process arrives, it is allocated memory from a hole large enough to accommodate it</li>
<li>Process exiting frees its partition, adjacent free partitions combined</li>
<li>Operating system maintains information about:  <ul>
<li>a) allocated partitions </li>
<li>b) free partitions (hole)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230316232901.png" alt=""><h6 id="Dynamic-Storage-Allocation-Problem"><a href="#Dynamic-Storage-Allocation-Problem" class="headerlink" title="Dynamic Storage-Allocation Problem"></a>Dynamic Storage-Allocation Problem</h6></li>
</ul>
</li>
<li>First-fit</li>
<li>Best-fit<ul>
<li>Allocate the smallest hole that is big enough</li>
<li>must search entire list, unless ordered by size</li>
<li>Produces the smallest leftover hole</li>
</ul>
</li>
<li>Worst-fit<ul>
<li>Similarly<br>First-fit &amp; best-fit better than worst-fit in terms of <strong>speed and storage  utilization</strong>. <h6 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h6></li>
</ul>
</li>
<li>External Fragmentation – total memory space exists to satisfy a request,<br>but it is not contiguous  </li>
<li>Internal Fragmentation <ul>
<li>allocated memory may be slightly larger than requested memory; this size difference is memory internal to a partition, but not being used  </li>
</ul>
</li>
<li>First fit analysis reveals that given N blocks allocated, another 0.5 N blocks  lost to fragmentation  <ul>
<li>1/3 may be unusable -&gt; 50-percent rule</li>
</ul>
</li>
<li>A solution : Compaction -&gt; reduce external fragmentation<ul>
<li>shuffle memory</li>
<li>possible only if relocation is dynamic, done at execution time</li>
</ul>
</li>
<li>Another solution : Permit <strong>noncontiguous memory allocation</strong><ul>
<li>-&gt; paging &amp; segmentation<h4 id="Non-contiguous-memory-allocation"><a href="#Non-contiguous-memory-allocation" class="headerlink" title="Non-contiguous memory allocation"></a>Non-contiguous memory allocation</h4><h5 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h5></li>
</ul>
</li>
<li>allow noncontiguous physical address space</li>
<li>divide physical memory into fix-sized blocks —FRAMES<ul>
<li>size is power of 2, 512b - 16Mb</li>
<li>keep track of all free frames</li>
</ul>
</li>
<li>divide logical memory into same sized blocks —PAGES</li>
<li>to run a program of N pages -&gt; find N free frames</li>
<li>maintain a page table to translate addresses<br>(still have internal fragmentation)<br>-&gt; P -&gt; F translator<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230316235007.png" alt=""><h5 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h5></li>
<li>Address generated by CPU is divided into:  <ul>
<li>Page number (p)<ul>
<li>used as an index into a page table, which contains base address of each page in physical memory  </li>
</ul>
</li>
<li>Page offset (d)<ul>
<li>combined with base address to define the physical<br>memory address that is sent to the memory unit<br>Page table is kept in main memory  </li>
</ul>
</li>
</ul>
</li>
<li>Page-table base register (PTBR) points to the page table  </li>
<li>Page-table length register (PTLR) indicates size of the page table  </li>
<li>In this scheme every data/instruction access requires <strong>two</strong> memory<br>accesses<br>-&gt;</li>
<li>associative memory or translation lookaside buffers <strong>(TLBs)</strong><ul>
<li>hit -&gt; fast access</li>
<li>miss -&gt; load to TLB</li>
<li>Effective Access Time (EAT)<ul>
<li>Associative Lookup = ε time unit</li>
<li>Hi ration = α</li>
<li>EAT = (1 + ε) α + (2 + ε)(1 – α)  <h5 id="Page-table-structure"><a href="#Page-table-structure" class="headerlink" title="Page table structure"></a>Page table structure</h5><h6 id="Hierarchical-Page-Tables"><a href="#Hierarchical-Page-Tables" class="headerlink" title="Hierarchical Page Tables"></a>Hierarchical Page Tables</h6></li>
</ul>
</li>
</ul>
</li>
<li>eg. 2-level paging table -&gt; forward-mapped page table<ul>
<li>10-bit page num*2 + 12-bit offset<h6 id="Hashed-Page-Tables"><a href="#Hashed-Page-Tables" class="headerlink" title="Hashed Page Tables"></a>Hashed Page Tables</h6><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230317005831.png" alt=""><h6 id="Inverted-Page-Tables"><a href="#Inverted-Page-Tables" class="headerlink" title="Inverted Page Tables"></a>Inverted Page Tables</h6><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230317005822.png" alt=""><br><strong>まとめ</strong><br>Hierarchical Page Tables，Hashed Page Tables和Inverted Page Tables都是操作系统中用于将<strong>虚拟地址映射到物理地址的数据结构</strong>。<br>Hierarchical Page Tables是一种多层表，将虚拟地址分成多个部分，每个部分都有一个表。<br>Hashed Page Tables是一种哈希页表，虚拟页号在虚拟地址中被哈希到哈希表中。<br>Inverted Page Tables是一种全局页表，由操作系统维护，用于所有进程。在Inverted Page Tables中，条目数等于主存中的帧数。与传统的页表相比，Inverted Page Tables具有更小的内存占用，但查找时间更长。<br>这些数据结构在许多操作系统中都有使用。例如，Linux使用了Inverted Page Tables，而Windows使用了Hierarchical Page Tables。Hashed Page Tables也被许多操作系统使用，例如FreeBSD和Solaris。<h5 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h5>Memory-management scheme that supports user view of memory<br>Logical address consists of a two tuple:  <strong><segment-number, offset></strong></li>
</ul>
</li>
<li>Segment table – maps two-dimensional physical addresses; </li>
<li>each table entry has:  <ul>
<li>base: contains the starting physical address where the segments<br>reside in memory  </li>
<li>limit: specifies the length of the segment  </li>
</ul>
</li>
<li>Segment-table base register (STBR) -&gt; segment table’s location in memory  </li>
<li>Segment-table length register (STLR) indicates number of segments<br>used by a program; segment number s is legal if s &lt; STLR<h2 id="Slides9-Virtual-Memory"><a href="#Slides9-Virtual-Memory" class="headerlink" title="Slides9 Virtual Memory"></a>Slides9 Virtual Memory</h2></li>
<li>Virtual Address Space<ul>
<li>Enables sparse address spaces with holes left for growth, dynamically  linked libraries, etc</li>
<li>easily shared during fork()</li>
<li>COW(Copy-on-write)</li>
<li>Lazy Swapper (Pager) ：never swaps a page into memory unless page will<br>be needed</li>
</ul>
</li>
<li>Valid-Invalid Bit<ul>
<li>each table entry associates with a ~ bit</li>
<li>V -&gt; memory resident ({address} v) , i -&gt; not-in-memory ({\ i})</li>
<li>entry is i -&gt; <strong>page fault</strong></li>
</ul>
</li>
<li>Page Fault<ul>
<li>if there is a reference to a page and the page is not in memory (i), the<br>reference will trap to operating system</li>
</ul>
</li>
</ul>
<ol>
<li>Operating system looks at page table to decide:<br> Invalid reference -&gt; abort  / Just not in memory  </li>
<li><strong>Get</strong> empty frame  </li>
<li><strong>Swap</strong> page into frame via scheduled disk operation  </li>
<li>Reset tables to indicate page now in memory  (Set validation bit = v)</li>
<li>Restart the instruction that caused the page fault<br>-&gt; what if there’s no Free Frame? </li>
</ol>
<ul>
<li>Page replacement<br>an algorithm which will result in minimum number of page faults</li>
</ul>
<ol>
<li>Find the location of the desired page on disk  </li>
<li>Find a free frame:  <ul>
<li>If there is a free frame, use it  </li>
<li>If there is no free frame, use a page replacement algorithm to select a<br>victim frame  </li>
<li><strong>Write victim frame to disk if dirty (Use modify (dirty) bit to reduce overhead of page transfers)</strong>  </li>
</ul>
<ol>
<li>Bring the desired page into the (newly) free frame; update the page and<br>frame tables  </li>
</ol>
</li>
<li>Continue the process by restarting the instruction that caused the trap</li>
</ol>
<ul>
<li>How to choose ‘desired pages’ : Page-Replacement Algorithms<ul>
<li>FIFO</li>
</ul>
</li>
</ul>
<h2 id="Slides10-Mass-Storage-Systems"><a href="#Slides10-Mass-Storage-Systems" class="headerlink" title="Slides10 Mass-Storage Systems"></a>Slides10 Mass-Storage Systems</h2><h3 id="Disk-stucture"><a href="#Disk-stucture" class="headerlink" title="Disk stucture"></a>Disk stucture</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230331010733.png" alt=""><br> -&gt; addressed as large 1-d arrays of logical blocks (smallest unit)</p>
<ol>
<li>The 1-dimensional array of logical blocks is mapped into the sectors of the disk sequentially  </li>
</ol>
<ul>
<li>Sector 0 is the first sector of the first track on the outermost cylinder  </li>
<li>Mapping proceeds in order through that track, then the rest of the tracks in that cylinder, and then through the rest of the cylinders from outermost to innermost  </li>
<li>Difficulty in mapping from logical to physical address:  </li>
<li>Except for bad sectors  </li>
<li>Non-constant # of sectors per track via constant angular velocity<h3 id="Overview-of-Mass-Storage-Structure"><a href="#Overview-of-Mass-Storage-Structure" class="headerlink" title="Overview of Mass Storage Structure"></a>Overview of Mass Storage Structure</h3></li>
<li>Magnetic disks provide bulk of secondary storage of modern computers  <ul>
<li>Drives rotate at 60 to 250 times per second  </li>
<li>Transfer rate is rate at which data flows between drive and computer  </li>
<li><strong>Positioning time (random-access time)</strong> is time to move disk arm to <strong>desired cylinder (seek time)</strong> and <strong>time for desired sector to rotate under  the disk head (rotational latency)</strong><h3 id="Disk-Scheduling-Algorithms"><a href="#Disk-Scheduling-Algorithms" class="headerlink" title="Disk-Scheduling Algorithms"></a>Disk-Scheduling Algorithms</h3>Idle disk can immediately work on I/O request, busy disk means work must<br>be queued  (Optimization algorithms only make sense when a queue exists)</li>
</ul>
</li>
<li>FCFS<br>按queue处理</li>
<li>SSTF<br>Shortest Seek Time First selects the request with the minimum seek time  from the current head position (当前最近)</li>
<li>SCAN<br>The disk arm starts <strong>at one end of the disk</strong>, and <strong>moves toward the other end</strong>,<br><strong>servicing</strong> requests <strong>until it gets to the other end of the disk</strong>, where the head<br>movement is reversed and service continues.</li>
<li>C-SCAN<br>The head moves <strong>from one end of the disk to the other,</strong> servicing requests as it goes. When it reaches the other end, it <strong>immediately returns</strong> to the beginning of the disk, <strong>without servicing</strong> any requests on the return trip.</li>
<li>C-LOOK<br>Similar to C-SCAN, but doesn’t reach the two ends.<br>Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk<br>-》 <strong>in C-XXXX</strong> , arm services always occur in one direction. when they are moving are the opposite direction, they ‘<strong>immediately returns</strong>‘.</li>
</ul>
<h3 id="SSD-vs-HDD"><a href="#SSD-vs-HDD" class="headerlink" title="SSD vs HDD"></a>SSD vs HDD</h3><p><strong>Nonvolatile memory devices</strong></p>
<ul>
<li>disk-drive like -&gt; solid-state disks (SSD)</li>
</ul>
<ul>
<li>(Other forms include USB drives (thumb drive, flash drive), DRAM stick, and main storage in devices like smartphones  )</li>
<li>Storage capacity / price<br>  capacity: HDD usually &gt; SSD<pre><code>  magnetic disks (HDD) hold much more data.
</code></pre>  price : SDD usually &gt; HDD (per MB)</li>
<li>Reliability<ul>
<li>SSD &gt; HDD<ul>
<li>SSDs have no moving parts (like magnetic disks and read/write heads) -&gt;less possible to damage</li>
</ul>
</li>
</ul>
</li>
<li>==Lifespan==<ul>
<li>SSD &lt;&lt; HDD</li>
<li>-&gt; SSD need to be <strong>carefully</strong> managed (storage units have a certain erasing and writing life) -&gt; <strong>disk management</strong></li>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
<li>Speed<ul>
<li>SSD &gt;&gt; HDD</li>
<li>No moving parts, so no seek time or rotational latency</li>
</ul>
</li>
<li>Bus speed<ul>
<li>SSD requires a direct connection to a high-speed bus (such as PCI) for maximum performance</li>
<li>(while HDDs are not subject to this limitation)</li>
</ul>
</li>
<li>==Disk management==<ul>
<li>SSDs need to implement complex flash controller algorithms, such as garbage collection, wear leveling, etc., to manage storage space. </li>
<li>HDDs, on the other hand, require low-level formatting (physical formatting) and logical formatting (logical formatting) to create file systems and deal with problems such as bad blocks.</li>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
<li>==Space management==<ul>
<li>In HDD, the file system usually uses clusters (簇) to manage disk space, and the size of the cluster is usually fixed. </li>
<li>In SSD, due to the complexity of its internal data management method, the file system usually needs to adopt different space management strategies, such as TRIM command and garbage collection (Garbage Collection), etc., to maintain the performance and lifespan of SSD.</li>
<li><strong>LET’S TALK ABOUT IT LATER</strong><h3 id="Space-amp-Disk-Management"><a href="#Space-amp-Disk-Management" class="headerlink" title="Space &amp; Disk Management"></a>Space &amp; Disk Management</h3></li>
</ul>
</li>
</ul>
<h4 id="More-About-Clusters-Blocks-and-Tracks-…"><a href="#More-About-Clusters-Blocks-and-Tracks-…" class="headerlink" title="More About Clusters, Blocks and Tracks …"></a>More About Clusters, Blocks and Tracks …</h4><p>HDD </p>
<ol>
<li>簇（cluster）：簇是一组相邻的扇区（sector）的集合，<strong>是文件系统中的最小单位。</strong> </li>
<li>块（block）：块是磁盘上用于<strong>存储数据的逻辑单位</strong>，通常由<strong>多个扇区</strong>组成。块是文件系统管理磁盘空间的基本单位（读写数据的基本单位）。</li>
<li>磁道（track）：磁道是磁盘上的一个圆形轨道，由多个扇区组成。磁道是磁盘上进行数据读写的基本单位，磁头（head）在磁道上移动，可以读取或写入扇区中的数据。（只属于HDD的物理概念，SSD不存在这个概念）<br>SSD</li>
<li>页（page）：页是SSD中最小的可读写单元，通常为4KB或8KB大小。</li>
<li>块（block）类似HHD。由多个页构成。为了增大擦除时一次性操作的块的大小延长寿命，在SSD中通常更大，通常为128KB或256KB大小。（理由后面细说）</li>
</ol>
<h4 id="HDD"><a href="#HDD" class="headerlink" title="HDD"></a>HDD</h4><ul>
<li>-&gt; Dividing a disk into <strong>sectors</strong> that the disk controller can read and write  <ul>
<li>Each sector can hold header information + data + error correction code (<strong>ECC</strong>)  </li>
<li>Usually 512b data but can be selectable  </li>
</ul>
</li>
<li>OS needs to record its own data structures on the disk  <ul>
<li>Part groups of cylinders, each treated as a logical disk  </li>
<li><strong>Logical formatting</strong> or “making a file system”  </li>
<li>To increase efficiency most file systems <strong>group blocks into clusters</strong><br>  Disk I/O done in blocks ; File I/O done in clusters</li>
</ul>
</li>
<li>Boot block initializes system<ul>
<li>The bootstrap is stored in ROM  </li>
<li><strong>Bootstrap loader</strong> program stored in boot blocks of boot partition  </li>
</ul>
</li>
<li>Methods such as <strong>sector sparing</strong> used to handle bad blocks</li>
</ul>
<p>MBR</p>
<ul>
<li>Boot code + partition table (contains pointer to boot partition)</li>
</ul>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><ul>
<li>Read and written in <strong>“page”</strong> increments (think sector) <ul>
<li>==but can’t overwrite in place==<ul>
<li>Must first be erased, and erases happen in larger “block” increments</li>
<li>要修改或擦除一个页，需要先将整个块读取到内存中，然后进行修改或擦除，最后再将整个块写回SSD。(所以SSD的块常常比HHD大的多，以增大每次擦写的大小、减小擦写次数)</li>
</ul>
</li>
<li>Can only be erased a limited number of times before worn out ~ 100,000  </li>
<li>Life span measured in drive writes per day (<strong>DWPD</strong>)  <ul>
<li>A 1TB NAND drive with rating of 5DWPD is expected to have 5TB per day written within warrantee period without failing</li>
</ul>
</li>
<li>块级别的操作对于SSD的性能和寿命管理是非常重要的。-》</li>
</ul>
</li>
</ul>
<p><strong>NAND Flash Controller Algorithms</strong>  </p>
<ul>
<li>With no overwrite, pages end up with mix of valid and invalid data. We need ways  to manage them: <ul>
<li>flash translation layer (FTL) table (a part of NAND flash)<ul>
<li>Track which logical blocks are valid</li>
</ul>
</li>
<li>TRIM (a instruction involving SSD and OS)<ul>
<li>inform which logical blocks are invalid more flexibly and timely</li>
</ul>
</li>
<li>Garbage collection (GC)<ul>
<li>Allocates overprovisioning to provide working space for GC  </li>
<li>垃圾回收是SSD内部的一种自动化操作，用于清理和整理闲置和无效的页。当文件被删除或修改时，SSD的页可能会变得闲置或无效，但这些页实际上仍然占据着宝贵的存储空间。垃圾回收操作会定期或在需要时将这些闲置和无效的页整理到一起，并执行擦除操作，以便可以重新分配给新的数据，从而提高SSD的存储效率。</li>
</ul>
</li>
</ul>
</li>
<li>Write Wear Leveling (均衡写入耗损) <ul>
<li>Each cell has lifespan, try to write equally to all cells</li>
<li>这可以通过在写入新数据时选择尽可能少使用写入次数较多的块，或将写入数据随机分布到多个块中来实现。</li>
</ul>
</li>
</ul>
<h3 id="Disk-Attachment"><a href="#Disk-Attachment" class="headerlink" title="Disk Attachment"></a>Disk Attachment</h3><ul>
<li>Drive attached to computer via I/O bus  <ul>
<li>Host controller in computer uses bus to <strong>talk to disk controller</strong> built into drive  </li>
<li>Busses vary (protocols vary)<ul>
<li>接口协议规定了硬件设备之间的通信协议和通信方式，而数据总线BUS则是物理连接这些设备之间的通信通道。</li>
<li>including EIDE, ATA, SATA, USB, SCSI, Fiber Channel, SAS, Firewire…</li>
<li>家用计算机的CPU多使用PCI、SATA等接口协议，FC更多用于企业计算机和数据中心环境。</li>
</ul>
</li>
</ul>
</li>
<li><strong>SCSI</strong>（Small Computer System Interface）<ul>
<li>过去比较常见</li>
<li>a bus, up to 16 devices on one cable</li>
<li>SCSI initiator 发起器 requests operation 发送操作请求 and SCSI targets 目标设备 perform tasks</li>
<li>Each target can have up to 8 logical units (disks attached to device controller)  </li>
</ul>
</li>
<li><strong>FC</strong> （Fiber Channel） 光纤通道 <ul>
<li>a <strong>high</strong>-speed serial architecture  </li>
<li>Can be switched fabric with 24-bit address space – the basis of storage area networks (SANs 存储区域网络) in which many hosts attach to many storage  units</li>
<li>通常用于需要大规模存储和高速数据传输的应用场景</li>
</ul>
</li>
</ul>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><ul>
<li>Redundant Arrays of Independent Disks (RAIDs)  </li>
<li>RAID– multiple disk drives provides reliability via redundancy  <ul>
<li>Mirroring  ( -&gt; a second copy)<ul>
<li>duplicate every disk  </li>
</ul>
</li>
<li>Parity bit  ( -&gt; error-correcting bit)</li>
</ul>
</li>
<li>Parallel access to multiple disk improves performance  <ul>
<li>Bit-level striping  <ul>
<li>split the bits of each byte across multiple disks  </li>
</ul>
</li>
<li>block-level striping  <ul>
<li>blocks of a file are striped across multiple disks  </li>
</ul>
</li>
</ul>
</li>
<li>RAID is arranged into seven or more different levels</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415031202.png" alt=""></p>
<p>RAID 6: P + Q redundancy  </p>
<ul>
<li>Reed-Solomon codes  <ul>
<li>2 bits of redundant data are stored for every 4 bits of data  </li>
<li>在RAID6中，数据被分布式地存储在多个磁盘驱动器中，同时通过计算奇偶校验信息对数据进行冗余存储。RAID6采用两个奇偶校验盘（P和Q盘）来存储奇偶校验信息，从而实现了对两个磁盘驱动器的故障容忍。</li>
</ul>
</li>
</ul>
<p>交织分布奇偶校验（如RAID 5）和复制（如RAID 1）是两种不同的数据保护策略，它们在数据存储和容错方式上有以下区别：</p>
<ol>
<li>存储方式：交织分布奇偶校验将奇偶校验信息分布存储在多个数据盘中，与原始数据分散存储在不同的盘上，从而实现数据和奇偶校验信息的分离存储。而复制方式则是将数据完全复制到多个独立的盘上，从而实现数据的冗余存储。</li>
<li>存储效率：交织分布奇偶校验在存储效率方面较为高效，因为它只需要使用一个额外的奇偶校验盘来存储校验信息，而原始数据可以充分利用所有的数据盘进行存储，从而提供了较高的存储容量。而复制方式则需要将数据完全复制到多个盘上，因此存储效率较低，通常只能提供50%的存储容量。</li>
<li>容错能力：交织分布奇偶校验和复制方式在容错能力上有所不同。交织分布奇偶校验可以容忍单个数据盘的故障，通过从其他数据盘和奇偶校验盘中恢复数据。而复制方式可以容忍多个数据盘的故障，因为数据被完全复制到多个盘上，只要其中一个副本可用，数据就可以被访问。</li>
<li>性能：交织分布奇偶校验和复制方式在性能方面也有所不同。交织分布奇偶校验在读性能上通常比较高，因为可以并行地从多个数据盘读取数据。但在写性能上可能受到奇偶校验盘的限制，因为写操作需要同时更新数据和奇偶校验信息。而复制方式在读性能上可能较低，因为需要从多个副本中选择一个进行读取，但在写性能上通常较高，因为数据只需要写入一个副本。</li>
</ol>
<p>假设有一个包含4个数据盘和1个奇偶校验盘的RAID 5阵列，其中数据盘分别标记为D1、D2、D3、D4，奇偶校验盘标记为P。当一个数据盘出现故障时，可以通过从其他数据盘和奇偶校验盘中恢复数据。<br>例如，当D2数据盘出现故障时，需要从其他数据盘和奇偶校验盘中恢复D2上的数据。RAID 5使用异或（XOR）运算来生成奇偶校验信息，该运算具有可逆性，可以用于数据恢复。<br>假设D1、D3和D4上的数据分别为A、B和C，而P上的奇偶校验信息为A XOR B XOR C。现在需要恢复D2上的数据B，可以通过执行以下步骤：</p>
<ol>
<li>从D1、D3和D4中读取对应位置上的数据，得到A、B和C的值。</li>
<li>从奇偶校验盘P中读取对应位置上的奇偶校验信息，得到A XOR B XOR C的值。</li>
<li>通过对已知的A、B和C的值以及A XOR B XOR C的值执行异或运算，即 (A XOR B XOR C) XOR (A XOR C) = B，得到D2上的数据B的值。</li>
<li>将得到的B的值写入到替换后的新数据盘D2上，完成数据恢复。</li>
</ol>
<p>这样，通过从其他数据盘和奇偶校验盘中恢复数据，可以在某个数据盘出现故障时保护数据的完整性，并维持RAID 5阵列的可靠性和可用性。</p>
<h3 id="Network-Attached-Storage"><a href="#Network-Attached-Storage" class="headerlink" title="Network-Attached Storage"></a>Network-Attached Storage</h3><ul>
<li>Network-attached storage (NAS) is storage made available over a network rather than over a local connection (such as a bus)  <ul>
<li>Remotely attaching to file systems  </li>
</ul>
</li>
<li>Implemented via remote procedure calls (RPCs) between host and storage over typically TCP or UDP on IP network  </li>
<li>iSCSI protocol uses IP network to carry the SCSI protocol  <ul>
<li>Remotely attaching to devices (blocks) -&gt; virtual disks</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415031456.png" alt=""></p>
<p>Storage Area Network（SAN）存储区域网络</p>
<pre><code>- Common in large storage environments  
- Multiple hosts attached to multiple storage arrays - flexible
- use high-speed buses，like Fibre Channel or iSCSI
</code></pre><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415031437.png" alt=""></p>
<h2 id="Slides11-File-System"><a href="#Slides11-File-System" class="headerlink" title="Slides11 File System"></a>Slides11 File System</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>A file is a named collection of related information that is recorded on<br>secondary storage.  </p>
<ul>
<li><strong>Attributes</strong><ul>
<li>Name</li>
<li><strong>Identifier</strong> - unique tag(num) identifies file within file sys</li>
<li>Type<ul>
<li>Text  </li>
<li>Source/object programs  </li>
<li>Executable programs  </li>
<li>Database records  </li>
<li>Graphic images  </li>
<li>Multimedia</li>
</ul>
</li>
<li>Location<ul>
<li>pointer to file location on device</li>
</ul>
</li>
<li>Size</li>
<li>Protection<ul>
<li>controls who can do reading, writing, executing</li>
</ul>
</li>
<li>Time, Date, User identification</li>
</ul>
</li>
<li>Information about files are kept in the directory structure, which is<br>maintained on the disk</li>
</ul>
<h3 id="File-operations"><a href="#File-operations" class="headerlink" title="File operations"></a>File operations</h3><ul>
<li>Create  </li>
<li>Write  </li>
<li>Read  </li>
<li>Reposition within file  </li>
<li>Delete  </li>
<li><p>Truncate  </p>
</li>
<li><p>The other operations can be implemented by the primitive ones.</p>
</li>
</ul>
<h4 id="Open-files"><a href="#Open-files" class="headerlink" title="Open files"></a>Open files</h4><p>Several pieces of data are needed to manage open files.</p>
<ul>
<li><strong>Open-file table</strong><ul>
<li>tracks open files  </li>
</ul>
</li>
<li><strong>File pointer</strong><ul>
<li>pointer to last read/write location, per process that has the file open  </li>
</ul>
</li>
<li>File-open <strong>count</strong><ul>
<li>counter of number of <strong>times</strong> a file is opened</li>
<li>allow removal of data from open-file table when last process closes it</li>
</ul>
</li>
<li>Disk <strong>location</strong> of the file<ul>
<li>stores data access information</li>
</ul>
</li>
<li><strong>Access rights</strong><ul>
<li>provides per-process access mode information</li>
<li><strong>Protection</strong>: decide access rights<ul>
<li>File owner/creator should be able to control:<ul>
<li>what can be done  </li>
<li>by whom  </li>
</ul>
</li>
<li>Types of access  <ul>
<li><strong>Read</strong>  </li>
<li><strong>Write</strong>  </li>
<li><strong>Execute</strong>  </li>
<li>Append  </li>
<li>Delete  </li>
<li>List</li>
</ul>
</li>
<li>Three classes of users<ul>
<li>owner, group, public (in unix/linux)<br>（windows: owner, group, others  -&gt; different names)</li>
<li>you can define the right by:<ul>
<li><code>chgrp G game</code></li>
<li>g is a unique group name, you attach it to the file</li>
<li><code>chmod 761 game</code></li>
<li>7 for owner, 6 for group, 1 for public</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Access methods</strong><ul>
<li>Sequential access<ul>
<li>read/write next</li>
<li>reset</li>
</ul>
</li>
<li>Direct access<ul>
<li>read/write n (n = relative block/byte number)</li>
<li>position to n<ul>
<li>read/write next</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Disk-Structure"><a href="#Disk-Structure" class="headerlink" title="Disk Structure"></a>Disk Structure</h3><ul>
<li>Disk can be subdivided into <strong>partitions</strong> 分区 (minidisks, slices)<ul>
<li>Disks/partitions can be RAID protected against failure</li>
<li>Disks/partitions can be used <strong>raw</strong> <ul>
<li>raw: without a file system, or formatted with a file system</li>
</ul>
</li>
</ul>
</li>
<li>Entity 实体 containing file system known as a <strong>volume</strong> 卷<ul>
<li>Each <strong>volume</strong> tracks file system’s info in <strong>device directory</strong> 设备目录 or <strong>volume table of contents</strong> 卷目录</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415230811.png" alt=""></p>
<h3 id="File-Directory"><a href="#File-Directory" class="headerlink" title="File Directory"></a>File Directory</h3><p>Organize the Directory (Logically) to Obtain  </p>
<ul>
<li>Efficiency – locating a file quickly  </li>
<li>Naming – convenient to users  <ul>
<li>Two users can have same name for different files  </li>
<li>The same file can have several different names  </li>
</ul>
</li>
<li>Grouping – logical grouping of files by properties, (e.g., all Java programs, all games, …)</li>
</ul>
<p><strong>Single-Level Directory</strong><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415231146.png" alt=""></p>
<ul>
<li>A single directory for all users  </li>
<li>Efficiency problem  </li>
<li>Naming problem  </li>
<li>Protection of users’ private files  </li>
<li>Grouping problem</li>
</ul>
<p><strong>Two-Level Directory</strong>  </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415231208.png" alt=""></p>
<ul>
<li>Separate directory for each user  </li>
<li>Can have the same file name for different user  </li>
<li>A little bit more efficient searching  </li>
<li>Path name  </li>
<li>No grouping capability</li>
</ul>
<p><strong>Tree-Stuctured Directory</strong><br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415231245.png" alt=""><br><strong>Acyclic-Graph Directories</strong></p>
<p>Have shared subdirectories and files<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415231309.png" alt=""><em>**</em></p>
<ul>
<li>Two different names (aliasing)</li>
<li>New directory entry type<ul>
<li>Link – another name (pointer) to an existing file</li>
<li>Resolve the link – follow pointer to locate the file</li>
</ul>
</li>
<li><p>If dict deletes count -&gt; dangling pointer</p>
</li>
<li><p>Solutions</p>
<ul>
<li>Backpointers, so we can delete all pointers</li>
<li>Entry-hold-count solution</li>
</ul>
</li>
</ul>
<p><strong>General Graph Directory</strong></p>
<h3 id="File-Allocation-Methods"><a href="#File-Allocation-Methods" class="headerlink" title="File Allocation Methods"></a>File Allocation Methods</h3><p>An allocation method refers to how disk blocks are allocated for files  </p>
<ul>
<li>Contiguous allocation  </li>
<li>Linked allocation  </li>
<li>Indexed allocation</li>
</ul>
<h4 id="Contiguous-Allocation"><a href="#Contiguous-Allocation" class="headerlink" title="Contiguous Allocation"></a>Contiguous Allocation</h4><ul>
<li>连续分配 each file occupies a set of contiguous blocks  <ul>
<li>Simple<ul>
<li>starting location (block #)</li>
<li>length (number of blocks)</li>
</ul>
</li>
<li>Best performance in most cases  </li>
<li>Problems：<ul>
<li>Finding space for file  </li>
<li>Knowing file <strong>size</strong>  </li>
<li>External fragmentation 外部碎片<ul>
<li>need for compaction off-line (downtime) or on-line 需要离线（停机）整理碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230415232426.png" alt=""></p>
<h4 id="Linked-Allocation"><a href="#Linked-Allocation" class="headerlink" title="Linked Allocation"></a>Linked Allocation</h4><p>Each file is a linked list of disk blocks: blocks may be scattered<br>anywhere on the disk<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416003935.png" alt=""></p>
<p>each file is a linked list of blocks  </p>
<ul>
<li>Each block <ul>
<li>a pointer to next block  </li>
<li>file ends at nil pointer  </li>
</ul>
</li>
<li>No external fragmentation  </li>
<li>Free space management system called when new block needed  </li>
<li>Improve efficiency by clustering blocks into groups but increases  internal fragmentation</li>
<li>Problem<ul>
<li>Reliability</li>
<li>Locating a block can take many I/Os and disk seeks</li>
</ul>
</li>
</ul>
<h4 id="File-Allocation-Table-FAT"><a href="#File-Allocation-Table-FAT" class="headerlink" title="File-Allocation Table (FAT)"></a>File-Allocation Table (FAT)</h4><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416004114.png" alt=""></p>
<ul>
<li>Beginning of volume has a table, indexed by block number <ul>
<li>Records allocation information and status of file blocks or clusters<ul>
<li>Occupied<ul>
<li>Uses a linked list structure to link the occupied file blocks or clusters</li>
</ul>
</li>
<li>Unallocated<ul>
<li>Marked with corresponding status flags</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Much like a linked list, but faster on disk and cacheable  </li>
<li><p>New block allocation simple </p>
</li>
<li><p>DOS / Windows</p>
</li>
</ul>
<h4 id="FAT-vs-linked-allocation"><a href="#FAT-vs-linked-allocation" class="headerlink" title="FAT vs linked allocation"></a>FAT vs linked allocation</h4><ul>
<li>存储方式<ul>
<li>FAT文件系统<ul>
<li>将整个文件的分配情况记录在文件分配表中</li>
<li>一次性读取整个文件的所有文件块地址到队列中，从而更好地进行访问规划</li>
<li>这对于机械硬盘等需要顺序访问且对等待队列的优化敏感的存储设备来说尤为重要</li>
</ul>
</li>
<li>链式分配文件系统<ul>
<li>逐个读取文件块，并且每个文件块只记录下一个文件块的位置信息。</li>
<li>需要不断地从磁盘读取下一个文件块的位置</li>
</ul>
</li>
</ul>
</li>
<li>如何找空格子<ul>
<li>都需要遍历获取已占用的格子的信息<ul>
<li>FAT：查询文件分配表直到找到未分配的块</li>
<li>linked allocation：从文件系统的起始位置开始，沿着链表遍历已占用的文件块，直到找到一个未占用的文件块</li>
<li>这时，FAT就显著比linked allocation快</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Indexed-Allocation"><a href="#Indexed-Allocation" class="headerlink" title="Indexed Allocation"></a>Indexed Allocation</h4><p>Each file has its own index block(s) of pointers to its data blocks </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416010327.png" alt=""></p>
<ul>
<li>Random access  </li>
<li>Without external fragmentation  </li>
<li>Need index table</li>
</ul>
<h5 id="I-node-management"><a href="#I-node-management" class="headerlink" title="I-node management"></a>I-node management</h5><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416010454.png" alt=""></p>
<ul>
<li>I-nodes have limited size, so we need mutiple I-nodes linked</li>
</ul>
<p>-&gt; <strong>EXAMPLE</strong></p>
<ul>
<li>Suppose a file system is constructed using blocks of 32 bytes. A pointer needs 4 bytes. The I-node structure is as follows (word, value):</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>num</th>
<th>content</th>
<th>#</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>permission word</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>direct block</td>
<td>linked to content directly</td>
</tr>
<tr>
<td>2</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>direct block</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>single-indirect</td>
<td>linked to another block</td>
</tr>
<tr>
<td>7</td>
<td>double-indirect</td>
<td>linked to a block which each 8 bytes points to a such unit</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Assume that free blocks are allocated in logical order starting with block 11. Also it has been determined that blocks 17 and 32 are <strong>bad</strong> and cannot be allocated.<br>  - </li>
<li>Draw a block diagram showing the structure of the I-node and the blocks that are allocated for  <ul>
<li>Original file size of <strong>3 blocks</strong>  (IN THE 1ST NODE)</li>
<li>Adding 4 blocks   (single-indirect is enough)</li>
<li>Adding 17 blocks (need double-indirect)</li>
</ul>
</li>
</ul>
<p>3+4blocks (4 in first I-node and 3 in single-indirect)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416012148.png" alt=""></p>
<p>3+4+17blocks (4 in first I-node, 8 in single-indirect,11 in double-indirect )</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416012023.png" alt=""></p>
<p><strong>Quiz</strong><br>Suppose a file system is constructed using blocks of 32 bytes. A pointer<br>needs 4 bytes. The I-node structure is as follows (word, value):<br>num|content<br>—|—<br>0|permission word<br>1|file size<br>2|direct block<br>3|direct block<br>4|direct block<br>5|single-indirect<br>6|double-indirect<br>7|triple-indirect</p>
<ul>
<li>Assume that free blocks are allocated in logical order starting with block 100. Also it has been determined that blocks 107, 108, 109, and 112 are bad and cannot be allocated.  </li>
<li>Draw a block diagram showing the structure of the I-node and the blocks that are allocated for  <ul>
<li>Original file size of 3 blocks  </li>
<li>Adding 7 blocks  </li>
<li>Adding 24 blocks  </li>
<li>Adding 64 blocks  </li>
</ul>
</li>
</ul>
<h2 id="Slides12-I-O-System"><a href="#Slides12-I-O-System" class="headerlink" title="Slides12 I/O System"></a>Slides12 I/O System</h2><h3 id="I-O-Hardware"><a href="#I-O-Hardware" class="headerlink" title="I/O Hardware"></a>I/O Hardware</h3><ul>
<li><p>Incredible variety of I/O devices  </p>
<ul>
<li>Storage devices <ul>
<li>(disks, tapes)  </li>
</ul>
</li>
<li>Transmission devices <ul>
<li>(network interface, Bluetooth)  </li>
</ul>
</li>
<li>Human-interface devices <ul>
<li>(screen, keyboard, mouse, audio in and out)  </li>
</ul>
</li>
</ul>
</li>
<li><p>Common concepts – signals from I/O devices interface with computer  </p>
<ul>
<li>Port 端口<ul>
<li>connection point for device  </li>
</ul>
</li>
<li>Bus – a set of wires and a strictly defined protocol  <ul>
<li>Daisy chain  链式连接 <ul>
<li>（PC -&gt; device A -&gt; device B -&gt; device C…)</li>
</ul>
</li>
<li>Shared direct access 共享直接访问<ul>
<li>I/O设备共用数据总线</li>
</ul>
</li>
</ul>
</li>
<li>Controller (host adapter 主机适配器)<ul>
<li>electronics that operate port, bus, device</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>PCIE example<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416014446.png" alt=""></p>
<ul>
<li><p>Hardware structure</p>
</li>
<li><p>registers</p>
<ul>
<li>place data/addr/commands</li>
</ul>
</li>
</ul>
<h3 id="Addressing-amp-instruction-system"><a href="#Addressing-amp-instruction-system" class="headerlink" title="Addressing &amp; instruction system"></a>Addressing &amp; instruction system</h3><ol>
<li><p>Memory mapped I/O<br> share address space with computer’s memory<br> r/w I/O just like memory<br> no special commands</p>
</li>
<li><p>Isolated I/O<br> seperate address space<br> need I/O &amp; memory select lines<br> special commands</p>
</li>
</ol>
<p><strong>(以下段落内容与计算机组成重复)</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416020129.png" alt=""></p>
<h3 id="I-O-system"><a href="#I-O-system" class="headerlink" title="I/O system"></a>I/O system</h3><p>when cpu issues I/O request, cpu may have to wait for response? (low efficiency)</p>
<p>-&gt;</p>
<p><strong>INTERRUPTS</strong> -&gt; use interrupt handler to free cpu</p>
<ul>
<li>Checked by processor after each instruction  <ul>
<li>Interrupt handler receives interrupts</li>
</ul>
</li>
<li>Nonmaskable<ul>
<li>reserved for events such as unrecoverable memory errors  </li>
</ul>
</li>
<li>Maskable<ul>
<li>can be ignored or delayed, for device controllers to request service  </li>
</ul>
</li>
<li>Interrupt vector to dispatch interrupt to correct handler  <ul>
<li>Context switch at start and end  </li>
<li>Interrupt chaining  </li>
<li>Based on priority</li>
</ul>
</li>
</ul>
<h4 id="Programmed-I-O"><a href="#Programmed-I-O" class="headerlink" title="Programmed I/O"></a>Programmed I/O</h4><p>the CPU directly controls I/O hardware<br>Cpu:<br>    issues request<br>    continuously check response<br>     read and write</p>
<h4 id="Interrupt-Driven-I-O"><a href="#Interrupt-Driven-I-O" class="headerlink" title="Interrupt-Driven I/O"></a>Interrupt-Driven I/O</h4><p>free CPU from I/O event</p>
<p>Cpu:<br>    issue request<br>    be interrupted when I/O module is ok<br>    check read status and read, and write to memory</p>
<h4 id="Direct-Memory-Access-DMA"><a href="#Direct-Memory-Access-DMA" class="headerlink" title="Direct Memory Access (DMA)"></a>Direct Memory Access (DMA)</h4><p>free CPU from I/O event &amp; <strong>data writing</strong></p>
<p>Cpu:<br>    tells DMA the request<br>    DMA interrupts Cpu when OK, and tells Cpu</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Interactionwith I/O Device</th>
<th>Programmed I/O</th>
<th>Interrupt-Driven I/O</th>
<th>Direct Memory Access</th>
</tr>
</thead>
<tbody>
<tr>
<td>waiting for the device</td>
<td>software(instructions on cpu)</td>
<td>hardware</td>
<td>hardware</td>
</tr>
<tr>
<td>transfer device data to mem</td>
<td>software</td>
<td>software</td>
<td>hardware</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Slides13-Virtual-Machines"><a href="#Slides13-Virtual-Machines" class="headerlink" title="Slides13 Virtual Machines"></a>Slides13 Virtual Machines</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><ul>
<li>Fundamental idea<ul>
<li>abstract hardware of a single computer into several different execution environments  </li>
<li>Similar to layered approach</li>
<li>But layer creates virtual system (virtual machine, or VM) on which operation systems or applications can run  </li>
</ul>
</li>
<li>Several components<ul>
<li>Host 宿主机<ul>
<li>underlying hardware system where VM runs  </li>
</ul>
</li>
<li>Virtual machine manager (VMM) 虚拟机管理器  / hypervisor (hyper-V) 虚拟化监控程序<ul>
<li>creates and runs virtual machines by providing interface that is identical to the host </li>
<li>(except in the case of paravirtualization 部分虚拟化)  </li>
</ul>
</li>
<li>Guest 客户机<ul>
<li>process provided with virtual copy 虚拟副本 of the host  </li>
<li>usually an operating system </li>
</ul>
</li>
</ul>
</li>
<li>Single physical machine can run multiple operating systems concurrently 同时, each in its own virtual machine<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020230416022332.png" alt=""></li>
</ul>
<h2 id="Slides14-Distributed-System-Structures"><a href="#Slides14-Distributed-System-Structures" class="headerlink" title="Slides14 Distributed System Structures"></a>Slides14 Distributed System Structures</h2><h2 id="Slides15-Distributed-System-Systems"><a href="#Slides15-Distributed-System-Systems" class="headerlink" title="Slides15 Distributed System Systems"></a>Slides15 Distributed System Systems</h2>
  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1.html">现代操作系统CS2310 （上）进程管理</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/files/courseNotes/2022(2)/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F0.html">现代操作系统CS2310 速效版</a></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      <p>评论区仅供交流~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="aleryxiao/aleryxiao.github.io" data-repo-id="R_kgDOIdw0jw" data-category="Announcements" data-category-id="DIC_kwDOIdw0j84CTXeH" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/categories">分类</a><a href="/tags">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs14">整理</span><a href="/wiki">文件夹</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friend">友链</a><a href="/guestbook">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about">关于</a><a target="_blank" rel="noopener" href="https://github.com/aleryxiao">GitHub</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://space.bilibili.com/19610138">@AleryXiao</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
