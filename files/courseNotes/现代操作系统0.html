<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>courseNotes：现代操作系统CS2310 速效版 - 極楽浄土</title>

  
    <meta name="description" content="SJTU-CS2310 现代操作系统 （速效版）">
<meta property="og:type" content="website">
<meta property="og:title" content="现代操作系统CS2310 速效版">
<meta property="og:url" content="https://float0108.github.io/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F0.html">
<meta property="og:site_name" content="極楽浄土">
<meta property="og:description" content="SJTU-CS2310 现代操作系统 （速效版）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421210300.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320014833.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320014441.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421210020.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320012314.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320012354.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320011903.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320013040.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230320013107.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416183850.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230416183846.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230224141118.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230224141611.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421190005.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421190035.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421190323.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421190619.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421190711.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421190800.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421191431.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421194801.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421205857.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230315211405.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421203130.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316232901.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230316235007.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230317005831.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230317005822.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230331010733.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031202.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031456.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020230415031437.png">
<meta property="article:published_time" content="2023-03-10T15:54:37.000Z">
<meta property="article:modified_time" content="2023-04-23T17:25:19.988Z">
<meta property="article:author" content="AleryXiao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://float0108.github.io/assets/Pasted%20image%2020230421210300.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="極楽浄土" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/site_assets/favicon.jpg">
  

  

  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='wiki'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/site_assets/head.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">極楽浄土</div><div class="sub normal cap">フロトの理发店</div><div class="sub hover cap" style="opacity:0"> @AleryXiao</div></a></div>

<nav class="menu dis-select"><a class="nav-item" href="/">posts</a><a class="nav-item active" href="/wiki/">collection</a><a class="nav-item" href="/about/">about</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/files/courseNotes/" placeholder="在 /files/courseNotes/ 中搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>




<widget class="widget-wrapper toc multi" id="data-toc"><div class="widget-header cap dis-select"><span class="name">现代操作系统CS2310 速效版</span></div><div class="widget-body fs14"><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.html#start"><span class="toc-text">计算机系统结构-CS2305</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(8086).html"><span class="toc-text">计算机组成-汇编语言-CS2307</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%AE%97%E6%B3%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%80%A7.html"><span class="toc-text">算法与复杂性-CS2308</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1.html"><span class="toc-text">现代操作系统CS2310 （上）进程管理</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2.html"><span class="toc-text">现代操作系统2-CS2310</span></a></div><div class="doc-tree active"><a class="doc-tree-link active" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F0.html"><span class="toc-text">现代操作系统CS2310 速效版</span></a><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-text">操作系统基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">进&#x2F;线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-amp-%E5%B9%B6%E8%A1%8C"><span class="toc-text">并发 &amp; 并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-amp-%E7%BA%BF%E7%A8%8B"><span class="toc-text">进程 &amp; 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-user-threads-amp-%E6%A0%B8%E7%BA%BF%E7%A8%8B-kernel-threads"><span class="toc-text">用户线程 (user threads) &amp; 核线程 (kernel threads)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-process"><span class="toc-text">进程 process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E8%B0%83%E5%BA%A6-cpu-scheduling"><span class="toc-text">CPU调度 cpu scheduling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0-preemptive-%E5%92%8C-%E9%9D%9E%E6%8A%A2%E5%8D%A0-nonpreemptive"><span class="toc-text">抢占 preemptive 和 非抢占 nonpreemptive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCPU%E8%B0%83%E5%BA%A6"><span class="toc-text">什么是CPU调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8-Dispatcher"><span class="toc-text">调度器 Dispatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#FCFS-First-Come-First-Served%EF%BC%89"><span class="toc-text">FCFS (First-Come, First-Served）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SJF-P-NP"><span class="toc-text">SJF (P&#x2F;NP)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6-PS-P-NP"><span class="toc-text">优先级调度 PS (P&#x2F;NP)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6-RR-P-NP"><span class="toc-text">时间片轮转调度 RR (P&#x2F;NP)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%A5%A5%E9%A5%BF"><span class="toc-text">关于饥饿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6-Multilevel-Queue-Scheduling"><span class="toc-text">多级队列调度 Multilevel Queue Scheduling</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-Multilevel-Feedback-Queue-Scheduling"><span class="toc-text">多级反馈队列 Multilevel Feedback Queue Scheduling</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%AE%A1%E7%90%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%89"><span class="toc-text">锁管理（进程同步）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-Process-Synchronization"><span class="toc-text">进程同步 Process Synchronization</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-text">如何实现同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-Atomic"><span class="toc-text">原语 &#x2F; 原子操作 Atomic</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Test-amp-Set-TAS"><span class="toc-text">Test&amp;Set (TAS)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Swap"><span class="toc-text">Swap</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutex"><span class="toc-text">Mutex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Samophore"><span class="toc-text">Samophore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98-Deadlock"><span class="toc-text">死锁问题 Deadlock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deadlock-Characterization"><span class="toc-text">Deadlock Characterization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resource-Allocation-Graph-algorithm"><span class="toc-text">Resource-Allocation Graph algorithm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Safe-mode-amp-safe-sequence"><span class="toc-text">Safe mode &amp; safe sequence</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Safe-mode"><span class="toc-text">Safe mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Safe-sequence"><span class="toc-text">Safe sequence</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#The-banker%E2%80%99s-algorithm"><span class="toc-text">The banker’s algorithm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sum-up-deadlock-handling"><span class="toc-text">Sum up: deadlock handling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PREVENTION"><span class="toc-text">PREVENTION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AVOIDANCE"><span class="toc-text">AVOIDANCE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DETECTION"><span class="toc-text">DETECTION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RECOVERY"><span class="toc-text">RECOVERY</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">内存与虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Management-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">Memory Management 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Allocation-Table-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%A1%A8"><span class="toc-text">Allocation Table 内存分配表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Contiguous-memory-allocation-%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Contiguous memory allocation  连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Multiple-partition-allocation-%E5%A4%9A%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-text">Multiple-partition allocation 多区分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Buddy-System-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-text">Buddy System 伙伴系统*</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-contiguous-memory-allocation-%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%BC%8F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">Non-contiguous memory allocation  非连续式内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Paging-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-text">Paging 内存分页</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hierarchical-Page-Tables-%E5%A4%9A%E5%B1%82%E8%A1%A8"><span class="toc-text">Hierarchical Page Tables 多层表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hashed-Page-Tables-%E5%93%88%E5%B8%8C%E9%A1%B5%E8%A1%A8"><span class="toc-text">Hashed Page Tables 哈希页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Inverted-Page-Tables-%E5%85%A8%E5%B1%80%E9%A1%B5%E8%A1%A8"><span class="toc-text">Inverted Page Tables 全局页表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Segmentation-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-text">Segmentation 内存分段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Segmentation-and-paging-scheme"><span class="toc-text">Segmentation and paging scheme</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-text">大容量存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-%E5%9F%BA%E7%A1%80"><span class="toc-text">Disk 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HDD"><span class="toc-text">HDD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSD"><span class="toc-text">SSD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Scheduling-Algorithms"><span class="toc-text">Disk-Scheduling Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FCFS"><span class="toc-text">FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSTF"><span class="toc-text">SSTF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SCAN"><span class="toc-text">SCAN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-SCAN"><span class="toc-text">C-SCAN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-LOOK"><span class="toc-text">C-LOOK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSD-vs-HDD"><span class="toc-text">SSD vs HDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Space-amp-Disk-Management"><span class="toc-text">Space &amp; Disk Management</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HDD-1"><span class="toc-text">HDD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SSD-1"><span class="toc-text">SSD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Attachment"><span class="toc-text">Disk Attachment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RAID"><span class="toc-text">RAID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network-Attached-Storage"><span class="toc-text">Network-Attached Storage</span></a></li></ol></li></ol></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3.html"><span class="toc-text">现代操作系统CS2310 （附）虚拟机和分布式</span></a></div><div class="doc-tree"><a class="doc-tree-link" href="/files/courseNotes/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html"><span class="toc-text">高级数据结构-SE2322</span></a></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      

  
  
<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" id="home" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" id="menu" href="/wiki/">collection</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/files/courseNotes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.html">courseNotes</a></div><div id="post-meta">更新于&nbsp;<time datetime="2023-04-23T17:25:19.988Z">2023-04-24</time></div></div>

  <article class='md-text content wiki'>
  <h1 class="article-title"><span>现代操作系统CS2310 速效版</span></h1>
  <h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><ul>
<li>关于抽象abstaction<ul>
<li>（计算机组成的重要概念）</li>
<li>层次化抽象</li>
<li>将系统划分成多个层次，每个层次都对下层屏蔽了具体实现细节，只向上层提供了一组简单的接口，从而简化了系统的设计和维护。</li>
<li>对于计算机系统结构，可以抽象为硬件层、操作系统层、系统程序层、应用程序层、用户层。每个层次都对下层屏蔽了具体实现细节，只提供了一组简单的接口。</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421210300.png" alt=""></p>
<ul>
<li>虚拟机 (Vitural machines) <ul>
<li>==virtualization layer==<ul>
<li>vitural cpu &amp; memory &amp; devices<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320014833.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>什么是计算机操作系统 (Operating system / OS) ？</p>
<ul>
<li>一种介于计算机用户与计算机应用间的“程序”</li>
<li>一个系统资源的分配者、其它程序的控制者</li>
</ul>
</li>
<li><p>系统调用 (System Call) </p>
<ul>
<li>OS提供的可编程接口<ul>
<li>比如 fork() exit() wait() (unix) 等</li>
</ul>
</li>
<li>比起使用系统调用，OS也向各类服务提供应用程序接口 ( Application program interface / Api) -&gt; 可以视为一种对系统调用的封装和抽象<ul>
<li>简单，易移植</li>
<li>eg. Win32 API, POSIX API(UNIX, Linux, Mac OS), Java API(JVM)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320014441.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>提供服务</p>
<ul>
<li>GUI</li>
<li>program execution</li>
<li>IO operations</li>
<li>File-system manipulation</li>
<li>communications</li>
<li>error detection</li>
<li>resource allocation</li>
<li>accouting</li>
<li>protection &amp; security</li>
</ul>
</li>
<li><p>Outline</p>
<ul>
<li>进程管理<ul>
<li>进程/线程/同步/死锁</li>
</ul>
</li>
<li>内存管理<ul>
<li>内存/虚拟内存</li>
</ul>
</li>
<li>存储管理<ul>
<li>文件系统/大容量存储结构/IO系统</li>
</ul>
</li>
<li>分布式系统结构</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421210020.png" alt=""></p>
<h2 id="进-线程调度"><a href="#进-线程调度" class="headerlink" title="进/线程调度"></a>进/线程调度</h2><h4 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发 &amp; 并行"></a>并发 &amp; 并行</h4><ul>
<li>并发 Concurrency  <ul>
<li>时分复用：多个任务在同一时段内共享资源，交替运行</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320012314.png" alt=""></p>
<ul>
<li>并行  Parallelism  (multi-core system)<ul>
<li>多个任务在（通过多个处理单元）同一时刻同时执行，互相独立<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320012354.png" alt=""></li>
</ul>
</li>
</ul>
<h4 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h4><div class="table-container">
<table>
<thead>
<tr>
<th>进程 process</th>
<th>线程 threads</th>
</tr>
</thead>
<tbody>
<tr>
<td>独立存在</td>
<td>作为进程子集存在</td>
</tr>
<tr>
<td>携带更多状态信息</td>
<td><strong>共享内存.系统资源</strong></td>
</tr>
<tr>
<td>独立地址空间</td>
<td>共享地址空间</td>
</tr>
<tr>
<td>仅通过IPC通信交互</td>
<td>更多方式</td>
</tr>
<tr>
<td>上下文切换比较慢</td>
<td>同进程内切换速度很快</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>线程是进程内的执行单元，不能独立于进程存在，而只能在进程中产生。</li>
<li>每个线程都共享了进程的地址空间、文件描述符表和其他系统资源。</li>
<li>可以认为正因为线程之间共享了部分资源，如代码段、数据段和文件描述符表等，因此在线程之间进行切换时，不需要像进程切换那样复制和恢复整个地址空间，这使得线程<strong>切换速度更快</strong>。</li>
<li>同时，由于线程之间共享了相同的地址空间，因此线程之间的<strong>通信更加容易和高效</strong>。线程可以直接访问同一进程内的共享内存，无需通过进程间通信（IPC）的方式进行数据传递，这减少了通信的开销和复杂性。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320011903.png" alt=""></p>
<h4 id="用户线程-user-threads-amp-核线程-kernel-threads"><a href="#用户线程-user-threads-amp-核线程-kernel-threads" class="headerlink" title="用户线程 (user threads) &amp; 核线程 (kernel threads)"></a>用户线程 (user threads) &amp; 核线程 (kernel threads)</h4><ul>
<li><strong>Many-to-one</strong><br>多个用户线程对核隐藏，映射到一个内核级线程上，由内核级线程来执行<br>单个用户线程出现问题会导致同组线程都出问题；不能并行运行</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320013040.png" alt=""></p>
<ul>
<li><strong>One-to-one</strong><br><strong>高并行支持</strong><br>创建kernel thread有开销<br>Linux, windows NT/XP/2000, Solaris 9+</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230320013107.png" alt=""></p>
<ul>
<li><strong>Many-to-many</strong><br>操作系统重构一定数量核线程<br>Windows NT with the ThreadFiber package<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416183850.png" alt=""></li>
<li><strong>Two-level</strong><br>在Many-to-many的基础上运行用户线程与核线程1对1绑定<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230416183846.png" alt=""></li>
</ul>
<h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程 process"></a>进程 process</h3><ul>
<li><p>进程 process  ( = job 作业)</p>
<ul>
<li><strong>program</strong> becomes <strong>process</strong> when the exe file is <strong>loaded into memory</strong><ul>
<li>开始运行的程序被载入内存，成为进程（此处的“内存”、之后的“组分”与<strong>虚拟内存</strong>有关）</li>
</ul>
</li>
<li>1 program can be <strong>several</strong> processes<ul>
<li>一个程序可以产生多个进程</li>
</ul>
</li>
</ul>
</li>
<li><p>一个进程的组成部分 conposition: </p>
<ul>
<li><strong>栈 stack</strong></li>
<li>…</li>
<li><strong>堆 heap</strong><ul>
<li>memroy dynamically allocated during run time</li>
</ul>
</li>
<li>数据 data</li>
<li>文本 text<ul>
<li>programme code</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>PCB</strong> (Process control block)</p>
<ul>
<li>state</li>
<li>num</li>
<li>counter</li>
<li>registers</li>
<li>mem limits</li>
<li>list of open files</li>
<li>…<br>—&gt; 包含进程的状态;控制;上下文切换;通信和同步;优先级管理信息</li>
</ul>
</li>
<li><p>进程的状态 process state</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../../assets/Pasted%20image%2020230224141118.png" alt=""></p>
<ul>
<li>一个新的进程的一生：<ul>
<li><strong>创建</strong> (new)</li>
<li><strong>就绪</strong> (ready)<ul>
<li>进程就绪，等待处理器分配资源</li>
<li>比如CPU正在忙着处理别的进程，可能新的进程就要等待</li>
</ul>
</li>
<li><strong>运行</strong> (run)<ul>
<li>执行指令</li>
</ul>
</li>
<li><strong>等待</strong> (wait)<ul>
<li>进程未就绪，等待事件的发生或完成</li>
<li>比如等待键盘输入字符</li>
</ul>
</li>
<li><strong>终止</strong> (terminated)</li>
</ul>
</li>
</ul>
<ul>
<li>CPU的进程切换过程</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../../assets/Pasted%20image%2020230224141611.png" alt=""></p>
<ul>
<li>保存当前进程的上下文(-&gt;PCB0)</li>
<li>切换到新进程的上下文(&lt;-PCB1)</li>
<li>…更新控制信息，开始执行新进程</li>
<li>结束执行新进程</li>
<li>保存新进程的上下文(-&gt;PCB1)</li>
<li>切换到原进程的上下文(&lt;-PCB0)</li>
<li>…</li>
</ul>
<h3 id="CPU调度-cpu-scheduling"><a href="#CPU调度-cpu-scheduling" class="headerlink" title="CPU调度 cpu scheduling"></a>CPU调度 cpu scheduling</h3><h4 id="抢占-preemptive-和-非抢占-nonpreemptive"><a href="#抢占-preemptive-和-非抢占-nonpreemptive" class="headerlink" title="抢占 preemptive 和 非抢占 nonpreemptive"></a>抢占 preemptive 和 非抢占 nonpreemptive</h4><ul>
<li>一个处于Run状态的进程是否可根据调度规则在运行过程中被其它进程<strong>中断</strong>？<ul>
<li>能 -&gt; 抢占式：允许中断</li>
<li>不能 -&gt; 非抢占式：除非进程结束或者进入等待状态，即释放CPU资源，不允许另一个进程获取其CPU资源</li>
</ul>
</li>
</ul>
<h4 id="什么是CPU调度"><a href="#什么是CPU调度" class="headerlink" title="什么是CPU调度"></a>什么是CPU调度</h4><p>在进程的状态发生以下变化时，CPU可能作“调度”决策</p>
<ol>
<li>run -&gt; wait</li>
<li>run -&gt; ready </li>
<li>wait -&gt; ready (I/O完成等event发生，等待资源分配)</li>
<li>terminates</li>
</ol>
<p>在1.4时做决策 -&gt; 非抢占 (处理进程的等待和结束)<br>在2.3时做决策 -&gt; 抢占 (处理新的ready进程)</p>
<h4 id="调度器-Dispatcher"><a href="#调度器-Dispatcher" class="headerlink" title="调度器 Dispatcher"></a>调度器 Dispatcher</h4><ul>
<li><p>控制CPU</p>
<ul>
<li>切换上下文</li>
<li>切换进程</li>
<li>切换用户/管理员权限</li>
<li>用户程序重启</li>
</ul>
</li>
<li><p>调度延迟 Dispatch latency</p>
</li>
</ul>
<p>time it takes for the dispatcher to <strong>stop one process and start another running.</strong> </p>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><p>均为人为定义，可能会有版本差别。<br>可以将一切调度理解为队列的设计、出入队规则的设计。<br>一般不标注可抢占时，认为不可抢占。</p>
<p><em>先有四种基础决策。</em></p>
<h5 id="FCFS-First-Come-First-Served）"><a href="#FCFS-First-Come-First-Served）" class="headerlink" title="FCFS (First-Come, First-Served）"></a>FCFS (First-Come, First-Served）</h5><ul>
<li>Convoy effect - short process behind long process</li>
<li>非常基础和朴素的安排方法</li>
<li>短进程不友好</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421190005.png" alt=""></p>
<h5 id="SJF-P-NP"><a href="#SJF-P-NP" class="headerlink" title="SJF (P/NP)"></a>SJF (P/NP)</h5><p>Shortest-Job-First</p>
<ul>
<li>先处理（预估的）总耗时最短的工作<ul>
<li>SJF(P) <ul>
<li>-&gt; 先处理（预估的）剩余耗时最短的工作</li>
<li>小心地处理新进程和被抢占的进程的顺序</li>
</ul>
</li>
</ul>
</li>
<li>理论最优解</li>
<li>事实上，难点在于很难预测到底耗时多久（ -&gt; 预测方案）</li>
<li><p><strong>会导致饥饿</strong></p>
<ul>
<li>等电梯。你住在高楼层。电梯总优先服务低楼层的人下楼。</li>
<li>低楼层总有人按电梯。</li>
<li>你永远等不到电梯。</li>
<li>类似地，优先级调度也会导致饥饿。</li>
</ul>
</li>
<li><p>Example of SJF (NP)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421190035.png" alt=""></p>
</li>
<li><p>Example of SJF (P)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421190323.png" alt=""></p>
</li>
</ul>
<h5 id="优先级调度-PS-P-NP"><a href="#优先级调度-PS-P-NP" class="headerlink" title="优先级调度 PS (P/NP)"></a>优先级调度 PS (P/NP)</h5><p>Priority Scheduling (高度类似SJF，仅更改判断条件)</p>
<ul>
<li>先处理高优先级进程</li>
<li>注意同优先级进程的处理方式</li>
</ul>
<h5 id="时间片轮转调度-RR-P-NP"><a href="#时间片轮转调度-RR-P-NP" class="headerlink" title="时间片轮转调度 RR (P/NP)"></a>时间片轮转调度 RR (P/NP)</h5><p>Round-Robin Scheduling<br>在RR(quatum=q)算法下，每个进程获得一个时间片time slice，长度为q。</p>
<ul>
<li><p>关于q</p>
<ul>
<li>当取quatum为一个极大的值，相当于FCFS，对短进程不友好</li>
<li>当取quatum为一个极小的值，符合RR的意图，但是会消耗大量时间用于进程切换</li>
<li>需要一个较为合适的取值</li>
</ul>
</li>
<li><p>Example of RR<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421190619.png" alt=""></p>
</li>
</ul>
<h5 id="关于饥饿"><a href="#关于饥饿" class="headerlink" title="关于饥饿"></a>关于饥饿</h5><ul>
<li>FCFS 不会导致饥饿</li>
<li>SJF, PS均会导致饥饿</li>
<li>RR 可以有效避免饥饿</li>
</ul>
<p><em>以下为混合决策，更加自定义化，请认真查看题目说明。</em></p>
<h5 id="多级队列调度-Multilevel-Queue-Scheduling"><a href="#多级队列调度-Multilevel-Queue-Scheduling" class="headerlink" title="多级队列调度 Multilevel Queue Scheduling"></a>多级队列调度 Multilevel Queue Scheduling</h5><p>multiques, eg. foreground &amp; background</p>
<ul>
<li>each queue has own scheduling algo 每个队列都有独立的出队规则</li>
<li>schedule between queues: <ul>
<li>eg1. fixed prority 规定出队优先级<ul>
<li>serve all from queue1, then 2</li>
<li>may cause starvation</li>
</ul>
</li>
<li>eg2. time slice 轮转从两个队列调取进程<ul>
<li>each queue has a time slice<br>…</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="多级反馈队列-Multilevel-Feedback-Queue-Scheduling"><a href="#多级反馈队列-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="多级反馈队列 Multilevel Feedback Queue Scheduling"></a>多级反馈队列 Multilevel Feedback Queue Scheduling</h5><p>a kind of ↑</p>
<ul>
<li>structure:<ul>
<li>queues 多少队列</li>
<li>each queue’s sche algo 每个队列的出队规则</li>
<li>method<ul>
<li>when to upgrade/demote jobs 任务的转移规则</li>
<li>which queue a process will enter when that process needs service 进入时的初始队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>classic example:</strong><br>  Q1(RR(8))-&gt;Q2(RR(16))-&gt;Q3(FCFS)<br>  In Q1/Q2, not completed -&gt; degrade and queue<br>  If not used up and not degrade, requeue ( &amp; get a new time slice)</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421190711.png" alt=""></p>
<ul>
<li>Example of MFQ<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421190800.png" alt=""></li>
</ul>
<h2 id="锁管理（进程同步）"><a href="#锁管理（进程同步）" class="headerlink" title="锁管理（进程同步）"></a>锁管理（进程同步）</h2><h3 id="进程同步-Process-Synchronization"><a href="#进程同步-Process-Synchronization" class="headerlink" title="进程同步 Process Synchronization"></a>进程同步 Process Synchronization</h3><ul>
<li>producer - consumer problem<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421191431.png" alt=""></li>
</ul>
<ul>
<li><p>Critical Section Problem</p>
<ul>
<li>临界资源：每个进程的访问互斥<br>(When one process is in <strong>critical section</strong>, no other processes may be in its critical section) </li>
<li>find protocol to solve 防止竞争的==协议==</li>
</ul>
</li>
<li><p>Critical Section</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;  </span><br><span class="line">entry section  // 资源保护开始</span><br><span class="line">	== critical section ==</span><br><span class="line">exit section  //资源保护结束</span><br><span class="line">	remainder section  </span><br><span class="line">&#125; while (TRUE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>To solve this</p>
<ul>
<li>Mutual Exclusion 互斥</li>
<li>Progress<ul>
<li>work when OK and don’t postpone indefinitely</li>
</ul>
</li>
<li>Bounded Waiting 有限等待<ul>
<li>Sequential Access 顺序访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="如何实现同步"><a href="#如何实现同步" class="headerlink" title="如何实现同步"></a>如何实现同步</h4><h4 id="原语-原子操作-Atomic"><a href="#原语-原子操作-Atomic" class="headerlink" title="原语 / 原子操作 Atomic"></a>原语 / 原子操作 Atomic</h4><p>Many systems provide <strong>hardware</strong> support for critical section code  </p>
<ul>
<li>Some machines provide special <strong>atomic hardware instructions</strong>  （原语）<ul>
<li>Atomic = non-interruptable  </li>
</ul>
</li>
</ul>
<h5 id="Test-amp-Set-TAS"><a href="#Test-amp-Set-TAS" class="headerlink" title="Test&amp;Set (TAS)"></a>Test&amp;Set (TAS)</h5><p>Either test memory word and set value: TestAndSet ()  </p>
<ul>
<li><p>Definition (由硬件实现)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean TestAndSet (boolean *target)  </span><br><span class="line">&#123;  </span><br><span class="line">	boolean rv = *target;  </span><br><span class="line">	*target = TRUE;  </span><br><span class="line">	return rv:  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example (share bool Lock(False))</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Solution:</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> ( TestAndSet ( &amp;lock ))</span><br><span class="line">	;   <span class="comment">// do nothing</span></span><br><span class="line">	<span class="comment">//    critical section</span></span><br><span class="line">	lock = FALSE;</span><br><span class="line">	<span class="comment">//    remainder section</span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>-&gt;(Add bounded-waiting) ：<br>    每个进程在一段时间内只能获取一定次数的testandset操作资源，如果达到阈值，就等待一定时间后再尝试获取<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;  </span><br><span class="line">	waiting[i] = TRUE;  </span><br><span class="line">	key = TRUE;  </span><br><span class="line">	<span class="keyword">while</span> (waiting[i] &amp;&amp; key)  </span><br><span class="line">		key = TestAndSet(&amp;lock);  </span><br><span class="line">	waiting[i] = FALSE;  </span><br><span class="line">		<span class="comment">// critical section  </span></span><br><span class="line">	j = (i + <span class="number">1</span>) % n;  </span><br><span class="line">	<span class="keyword">while</span> ((j != i) &amp;&amp; !waiting[j])  </span><br><span class="line">		j = (j + <span class="number">1</span>) % n;  </span><br><span class="line">	<span class="keyword">if</span> (j == i)  </span><br><span class="line">		lock = FALSE;  </span><br><span class="line">	<span class="keyword">else</span>  </span><br><span class="line">		waiting[j] = FALSE;  </span><br><span class="line">		<span class="comment">// remainder section  </span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);  </span><br></pre></td></tr></table></figure></p>
<h5 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h5><p>swap contents of two memory words: Swap() — 安全地交换两个内存单元内的数据</p>
<ul>
<li>Example<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;  </span><br><span class="line">	key = TRUE;  </span><br><span class="line">	<span class="keyword">while</span> ( key == TRUE)  </span><br><span class="line">		Swap (&amp;lock, &amp;key );  </span><br><span class="line">			<span class="comment">// critical section  </span></span><br><span class="line">		lock = FALSE;  </span><br><span class="line">			<span class="comment">// remainder section  </span></span><br><span class="line">&#125; <span class="keyword">while</span> (TRUE);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h4><ul>
<li>一种轻量级的同步机制</li>
<li>实现两种基本操作：lock和unlock。</li>
<li>在lock()和unlock()之间的临界区域内同一时间只有一个进程可以访问共享资源，其他进程必须等待锁被释放才能进入临界区域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_function</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex); <span class="comment">// 加锁Mutex </span></span><br><span class="line">	<span class="comment">// ... critical part</span></span><br><span class="line">	pthread_mutex_unlock(&amp;mutex); <span class="comment">// 解锁Mutex</span></span><br><span class="line">	<span class="comment">// ... remainder </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Samophore"><a href="#Samophore" class="headerlink" title="Samophore"></a>Samophore</h4><ul>
<li>一种用于线程同步的机制，可以用于多线程编程中控制访问共享资源。</li>
<li>维护一个计数器和等待队列</li>
</ul>
<p>Semaphore提供了两个主要的操作：wait（等待）和signal（发信号）。Semaphore的值为整数，初始值可以是任意的正整数，表示可用的资源数目。Semaphore的值只能在wait和signal操作中改变，且改变是原子的，所以可以避免竞态条件。</p>
<p>在C语言中，Semaphore是通过系统提供的sem_t类型来表示的。</p>
<ol>
<li>wait（等待）：当一个线程<strong>想要使用</strong>Semaphore代表的共享资源时，它需要调用wait操作。</li>
</ol>
<p>如果Semaphore的值为正数，则该线程可以使用该资源，同时Semaphore的值减1；<br>如果Semaphore的值为0，则该线程将被阻塞，直到有其他线程释放资源并增加Semaphore的值为止。</p>
<p><code>int sem_wait(sem_t *sem);</code></p>
<ol>
<li>signal（发信号）：当一个线程<strong>使用完</strong>Semaphore代表的共享资源时，它需要调用signal操作。</li>
</ol>
<p>这将增加Semaphore的值，并唤醒等待该Semaphore的线程，以便它们可以继续使用资源。</p>
<p><code>int sem_post(sem_t *sem);</code></p>
<p>Semaphore还有其他一些操作，例如初始化、销毁等。在使用Semaphore时，需要注意避免死锁等问题，通常需要仔细考虑线程的同步关系，避免资源竞争等问题。</p>
<h3 id="死锁问题-Deadlock"><a href="#死锁问题-Deadlock" class="headerlink" title="死锁问题 Deadlock"></a>死锁问题 Deadlock</h3><h4 id="Deadlock-Characterization"><a href="#Deadlock-Characterization" class="headerlink" title="Deadlock Characterization"></a>Deadlock Characterization</h4><ul>
<li>Mutual exclusion 资源互斥<br>  only one process at a time can use a resource  </li>
<li>Hold and wait<br>  process holding at least one resource is waiting to  acquire additional resources held by other processes 享有资源的进程等待其它资源 </li>
<li>No preemption<br>  a resource can be released only voluntarily by the process holding it, after that process has completed its task  不允许抢占其它进程享有的资源</li>
<li>Circular wait 互相等待形成环</li>
</ul>
<p>哲学家吃饭都拿左边筷子</p>
<ul>
<li>Each process utilizes a resource as follows:  <ul>
<li>request  </li>
<li>use  </li>
<li>release</li>
</ul>
</li>
</ul>
<h4 id="Resource-Allocation-Graph-algorithm"><a href="#Resource-Allocation-Graph-algorithm" class="headerlink" title="Resource-Allocation Graph algorithm"></a>Resource-Allocation Graph algorithm</h4><p>-&gt; DEADLOCK AVOIDANCE</p>
<p>通过画资源分配图，检查是否存在死锁，以及确定导致死锁的进程和资源，进而解除死锁 (avoidance) ; 也可以用于避免死锁（在分配前检查是否可能导致死锁）</p>
<ul>
<li>The graph represents the relationships between resources and processes in the system. 用资源分配图可以表示当前的资源和进程关系</li>
<li><p>常用于每个资源仅有1instance的情况（多个instance时，环路和死锁未必相关）</p>
</li>
<li><p>V: </p>
<ul>
<li>P: P1,P2… (process list)</li>
<li>R: R1,R2… (resource list)</li>
</ul>
</li>
<li>E:<ul>
<li>request edges ( process -&gt; resource )</li>
<li>assignment edges ( resource -&gt; process )</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421194801.png" alt=""></p>
<ul>
<li><p>Judge deadlock by graph</p>
<ul>
<li>no circle -&gt; no deadlock</li>
<li>1 circle -&gt; <ul>
<li>1 instance / resource type -&gt; deadlock</li>
<li>-&gt;1 instance / … -&gt; possibility of deadlock</li>
</ul>
</li>
</ul>
</li>
<li><p>upgraded resource-allocation graph: </p>
<ul>
<li>Each process must a priori claim maximum use</li>
<li>claim edge 有向虚线：进程P可能请求资源R （P-&gt;R）</li>
<li>request edge 实线（P-&gt;R）</li>
<li>assignment edge 实线 （R-&gt;P）</li>
</ul>
</li>
<li><p>In other words, the request can be granted only if converting the request edge to an assignment edge does not result in the formation of <strong>a circle in the resource allocation graph</strong>. </p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421205857.png" alt=""></p>
<h3 id="Safe-mode-amp-safe-sequence"><a href="#Safe-mode-amp-safe-sequence" class="headerlink" title="Safe mode &amp; safe sequence"></a>Safe mode &amp; safe sequence</h3><h4 id="Safe-mode"><a href="#Safe-mode" class="headerlink" title="Safe mode"></a>Safe mode</h4><ul>
<li><p>system check if allocation leaves the system in a <strong>safe mode</strong> to prevent from dead lock 在分配请求发生时检查是否存在安全队列以预防死锁</p>
</li>
<li><p>defination: 系统中每个进程都能够按照它所需的顺序获得资源，执行完自己的任务并释放资源，而不会发生死锁。</p>
<ul>
<li>If Pi’s resource needs are not immediately available, then Pi can wait until all Pj have finished  </li>
<li>When all Pj are finished, Pi can obtain needed resources, execute, return allocated resources, and terminate  </li>
<li>When Pi terminates, Pi+1 can obtain its needed resources, and so on</li>
<li>Otherwise, system is in <strong>unsafe state</strong></li>
</ul>
</li>
<li><p>If a system is in safe state -&gt; no deadlocks  </p>
</li>
<li>If a system is in unsafe state -&gt; possibility of deadlock  <ul>
<li>starvation 饥饿 …</li>
</ul>
</li>
<li><strong>Avoidance</strong> -&gt; ensure that a system will never enter an unsafe state.<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230315211405.png" alt=""><h4 id="Safe-sequence"><a href="#Safe-sequence" class="headerlink" title="Safe sequence"></a>Safe sequence</h4></li>
<li>eg: find a safe sequence with available resource = 3<br>| |maximum needs|holds|needs|<br>|—|—|—|—|<br>|P0|10|5|5|<br>|P1|4|2|2|<br>|P2|9|2|7|</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Avai</th>
<th>P1+</th>
<th>P1-</th>
<th>P0+</th>
<th>P0-</th>
<th>P2+</th>
<th>P2-</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>1</td>
<td>5</td>
<td>0</td>
<td>10</td>
<td>3</td>
<td>12</td>
</tr>
</tbody>
</table>
</div>
<p>P1 -&gt; P0 -&gt; P2<br>每一步寻找可运行的process，完成后释放process和它的所有资源。<br>如果找不到可运行的process，则出现unsafe state。</p>
<h5 id="The-banker’s-algorithm"><a href="#The-banker’s-algorithm" class="headerlink" title="The banker’s algorithm"></a>The banker’s algorithm</h5><ul>
<li><p>适用于资源有mutiple instances的情况</p>
</li>
<li><p>Defination<br>n = number of processes<br>m = number of resources types.</p>
</li>
<li><p><strong>Available</strong>: Vector of length m. </p>
<pre><code>If available\[j] = k, there are k instances of resource type Rj available  
</code></pre></li>
<li><strong>Max</strong>: n x m matrix. <pre><code>If Max\[i,j] = k, then process Pi may request at  most k instances of resource type Rj  
</code></pre></li>
<li><strong>Allocation</strong>: n x m matrix. <pre><code>If Allocation\[i,j] = k then Pi is currently allocated k instances of Rj  
</code></pre></li>
<li><p><strong>Need</strong>: n x m matrix. </p>
<pre><code>If Need\[i,j] = k, then Pi may need k more instances of Rj to complete its task 
Need\[i,j] = Max\[i,j] – Allocation\[i,j]**
</code></pre></li>
<li><p>The algorithm</p>
<ol>
<li>work := available, finish[i] = false</li>
<li>find i that<ul>
<li>finish[i] = false</li>
</ul>
<ol>
<li>need[i] &lt;= work</li>
<li>if i = -1, go to 4</li>
</ol>
</li>
<li>work = work + allocation[i], finish[i] = true, go to 2</li>
<li>if finish[i] = true for all i -&gt; ok, else !ok</li>
</ol>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230421203130.png" alt=""></p>
<p><strong>Simulation</strong><br>+P1-&gt;[2,1,0]-&gt;-P1-&gt;[5,3,2]<br>+P3-&gt;[5,2,1]-&gt;-P3-&gt;[7,4,3]<br>+P0-&gt;[0,0,0]-&gt;-P0-&gt;[7,5,3]<br>+P2-&gt;[1,5,3]-&gt;-P2-&gt;[10,5,5]<br>+P4-&gt;[12,2,4]-&gt;-P4-&gt;[10,5,7]</p>
<h3 id="Sum-up-deadlock-handling"><a href="#Sum-up-deadlock-handling" class="headerlink" title="Sum up: deadlock handling"></a>Sum up: deadlock handling</h3><h4 id="PREVENTION"><a href="#PREVENTION" class="headerlink" title="PREVENTION"></a>PREVENTION</h4><h6 id="restrain-the-ways-request-can-be-made"><a href="#restrain-the-ways-request-can-be-made" class="headerlink" title="restrain the ways request can be made"></a>restrain the ways request can be made</h6><p>shown in [deadlock characterization]</p>
<h4 id="AVOIDANCE"><a href="#AVOIDANCE" class="headerlink" title="AVOIDANCE"></a>AVOIDANCE</h4><p>入职检查<br>Whenever a process requests a resource, the request is granted only if the allocation leaves the system in a safe state.</p>
<p><strong>Help system to add priori info</strong></p>
<ul>
<li>Prepare for checking: each process declare <strong>max of resources needed</strong> </li>
<li>Dynamically check if there’ll be circular-wait condition<ul>
<li>be defined by available/allocated resourvces, max demands of processes</li>
<li>safe state checking (bank algo/…) ; circle check</li>
</ul>
</li>
</ul>
<h4 id="DETECTION"><a href="#DETECTION" class="headerlink" title="DETECTION"></a>DETECTION</h4><p>similar to avoidance</p>
<h4 id="RECOVERY"><a href="#RECOVERY" class="headerlink" title="RECOVERY"></a>RECOVERY</h4><ul>
<li><p>precess termination 进程终结</p>
<ul>
<li>abort one or more processes to break the circular wait</li>
<li>abort all deadlock ones / one at a time until ok</li>
</ul>
</li>
<li><p>resource preemption 资源抢占</p>
<ul>
<li>preempt some resources from one or more of the deadlocked processes</li>
<li>selecting a victim / rollback 回滚</li>
<li>ATTENTION: starvation</li>
</ul>
</li>
</ul>
<h2 id="内存与虚拟内存"><a href="#内存与虚拟内存" class="headerlink" title="内存与虚拟内存"></a>内存与虚拟内存</h2><p>MMU (Memory Management Unit)<br>    Hardware component (通常作为一个主板模块与CPU和内存分别相连)<br>    在CPU发生访问需求时，根据<strong>内存映射表</strong>将CPU中的逻辑内存地址转换成内存中的物理内存地址<br>        每次开机，OS都会从硬盘中读取地址映射表，并将其存储到内存中的特定位置<br>        OS会将这个位置，也就是<strong>地址映射表的基地址</strong>存储在MMU的 relocation register 重定位寄存器。</p>
<h3 id="Memory-Management-内存管理"><a href="#Memory-Management-内存管理" class="headerlink" title="Memory Management 内存管理"></a>Memory Management 内存管理</h3><h4 id="Allocation-Table-内存分配表"><a href="#Allocation-Table-内存分配表" class="headerlink" title="Allocation Table 内存分配表"></a>Allocation Table 内存分配表</h4><p>由于内存分配表的大小通常比较小，而且遍历它的开销相对较低，所以一般的内存管理方法都使用内存分配表来记录内存的分配情况，使OS可以快速查找到可用的内存块并将其分配给进程。</p>
<ul>
<li>记录内存中分区的起始地址、大小、是否已分配等信息</li>
<li>可看作是一个逻辑上的表格，其中每个表项代表一块内存区域</li>
<li>由OS在启动时初始化，分配时动态更新</li>
</ul>
<h4 id="Contiguous-memory-allocation-连续式内存分配"><a href="#Contiguous-memory-allocation-连续式内存分配" class="headerlink" title="Contiguous memory allocation  连续式内存分配"></a>Contiguous memory allocation  连续式内存分配</h4><p><strong>Defination</strong></p>
<ul>
<li>将可用的内存空间视为<strong>连续的地址空间</strong></li>
<li>进程被分配的内存空间也必须是<strong>连续的物理内存空间</strong>。</li>
</ul>
<h5 id="Multiple-partition-allocation-多区分配"><a href="#Multiple-partition-allocation-多区分配" class="headerlink" title="Multiple-partition allocation 多区分配"></a>Multiple-partition allocation 多区分配</h5><ul>
<li>一种典型的连续式内存分配</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230316232901.png" alt=""></p>
<ul>
<li><p>维护内存分配表（包含已分配分区和未分配 (holes) 分区的信息）</p>
</li>
<li><p><strong>Dynamic Storage-Allocation Problem  动态存储分配问题</strong></p>
<ul>
<li>First-fit</li>
<li>Best-fit<ul>
<li>Allocate the smallest hole that is big enough</li>
<li>must search entire list, unless ordered by size</li>
<li>Produces the smallest leftover hole</li>
</ul>
</li>
<li>Worst-fit<ul>
<li>Similarly<br>First-fit &amp; best-fit better than worst-fit in terms of **speed and storage  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分配出去的空间释放后大小未必能够匹配后续需分配的内存大小，导致 <strong>内存碎片 (memory fragmentation)</strong>  形成。</p>
<ul>
<li><strong>内存碎片 memory fragmentation</strong> <ul>
<li>内存中大量的零散、未被充分利用的小块空闲内存</li>
<li>过多碎片可能导致内存空间无法有效利用，也会增加分配内存的开销。</li>
</ul>
</li>
<li>外部碎片 (external)<ul>
<li>total memory space <strong>exists</strong> to satisfy a request, but it is <strong>not contiguous</strong>  </li>
</ul>
</li>
<li>内部碎片 (internal)<ul>
<li>allocated memory may be slightly <strong>larger</strong> than requested memory</li>
<li>allocating memory internal to a partition, but <strong>not being used</strong></li>
</ul>
</li>
</ul>
<p>-》 使用First fit算法来分配内存时，会发现对于N个块已经被分配，有0.5N个块被浪费在碎片上。其中1/3的碎片可能无法使用，这就是“50%规则”</p>
<ul>
<li>解决方案<ol>
<li>内存紧缩/重排 compaction/shuffle<ul>
<li>效率问题</li>
<li>-&gt; 伙伴系统</li>
</ul>
</li>
<li>允许不连续分配 noncontiguous memory allocation<ul>
<li>内存的分页与分段 paging &amp; segmentation</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="Buddy-System-伙伴系统"><a href="#Buddy-System-伙伴系统" class="headerlink" title="Buddy System 伙伴系统*"></a>Buddy System 伙伴系统*</h5><ul>
<li>将内存分成大小相等的块，每个块都有一个大小的指数级别，例如2的幂次方</li>
<li>当分配内存时，伙伴系统会按照2的幂次方去寻找最合适的可用块<ul>
<li>如果找到一个较大的块，它就会被拆分成两个较小的块，并将它们标记为伙伴块</li>
<li>当释放内存时，伙伴系统会将相邻的伙伴块合并成一个更大的块=</li>
</ul>
</li>
<li>可以尽量减少传统连续分配模式产生的内存碎片</li>
<li>使用比较复杂的数据结构管理伙伴关系和未分配内存</li>
<li>Linux</li>
</ul>
<h4 id="Non-contiguous-memory-allocation-非连续式内存分配"><a href="#Non-contiguous-memory-allocation-非连续式内存分配" class="headerlink" title="Non-contiguous memory allocation  非连续式内存分配"></a>Non-contiguous memory allocation  非连续式内存分配</h4><ul>
<li>allow noncontiguous physical address space</li>
</ul>
<h5 id="Paging-内存分页"><a href="#Paging-内存分页" class="headerlink" title="Paging 内存分页"></a>Paging 内存分页</h5><p><strong>Defination</strong></p>
<ul>
<li>FRAMES 框 -&gt; 物理内存切块<ul>
<li>divide <strong>physical memory</strong> into <strong>fix-sized</strong> blocks<ul>
<li>size is power of 2, 512b - 16Mb</li>
<li>keep track of all free frames</li>
</ul>
</li>
</ul>
</li>
<li>PAGES 页  -&gt; 逻辑内存切块<ul>
<li>divide <strong>logical memory</strong> into <strong>same sized</strong> blocks</li>
</ul>
</li>
<li>运行方式<ul>
<li>to run a program of N pages -&gt; find N free frames</li>
</ul>
</li>
<li>PAGE TABLE 页表<ul>
<li>translate addresses (page id -&gt; frame id)<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230316235007.png" alt=""></li>
</ul>
</li>
</ul>
<p>(still have internal fragmentation)</p>
<p><strong>Implementation</strong></p>
<ul>
<li><p>Define a logical address as \<page-number, page offset></p>
<ul>
<li>divided by CPU</li>
<li>page number (p)<ul>
<li>the page’s index in page tables</li>
</ul>
</li>
<li>page offset (d)<ul>
<li>mapping to offset within that page (frame) </li>
</ul>
</li>
</ul>
</li>
<li><p>Keep a page table</p>
<ul>
<li>PTBR: Page-table base register in CPU<ul>
<li>records the address of the table</li>
</ul>
</li>
<li>PTLR: Page-table length register in CPU<ul>
<li>indicates the length of the table</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Obviously, every data/instruction access requires 2 memory accesses  (access the table and allocate the unit according to the table)</p>
<ul>
<li>Add a <strong>TLB</strong> to accelerate<ul>
<li>translation lookaside buffer</li>
<li>record recent accessed table item</li>
<li>HIT<ul>
<li>fast access</li>
</ul>
</li>
<li>MISS 内存缺页<ul>
<li>load to TLB, try to hit next time</li>
</ul>
</li>
<li>EAT (Effective Access Time)<ul>
<li>Associative Lookup = ε time / unit</li>
<li>Hi ration = α</li>
<li>EAT = (1 + ε) α + (2 + ε)(1 – α) </li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="TLB-scheme"><a href="#TLB-scheme" class="headerlink" title="TLB scheme"></a>TLB scheme</h6><ul>
<li>FIFO<ul>
<li>First-In, First-Out</li>
<li>记录页表项进入TLB的时间戳</li>
<li>将最早进入TLB的页面替换出去</li>
</ul>
</li>
<li>LRU<ul>
<li>Least Recently Used</li>
<li>记录页表项在TLB中最后一次被访问的时间戳</li>
<li>将访问时间最早的页表项替换出去</li>
</ul>
</li>
<li><p>Second-chance page replacement algorithm</p>
<ul>
<li>给页表项附加一个引用位 reference bit（0/1）</li>
<li>当需要发生替换时，对于每个被遍历到的页表项：<ul>
<li>如果引用位为1，则设置为0并检查下一个页面<ul>
<li>每次替换都从上次结束的位置继续</li>
</ul>
</li>
<li>如果引用位为0，则进行替换并初始化引用位为1</li>
</ul>
</li>
</ul>
</li>
<li><p>The realization of page table structure</p>
</li>
</ul>
<h5 id="Hierarchical-Page-Tables-多层表"><a href="#Hierarchical-Page-Tables-多层表" class="headerlink" title="Hierarchical Page Tables 多层表"></a>Hierarchical Page Tables 多层表</h5><p>将虚拟地址分成多个部分，每个部分都有一个表。</p>
<ul>
<li>windows</li>
<li>eg. 2-level paging table -&gt; forward-mapped page table<ul>
<li>10-bit page num*2 + 12-bit offset</li>
</ul>
</li>
</ul>
<h5 id="Hashed-Page-Tables-哈希页表"><a href="#Hashed-Page-Tables-哈希页表" class="headerlink" title="Hashed Page Tables 哈希页表"></a>Hashed Page Tables 哈希页表</h5><ul>
<li>虚拟页号在虚拟地址中被哈希到哈希表中。</li>
<li>FreeBSD, Solaris</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230317005831.png" alt=""></p>
<h5 id="Inverted-Page-Tables-全局页表"><a href="#Inverted-Page-Tables-全局页表" class="headerlink" title="Inverted Page Tables 全局页表"></a>Inverted Page Tables 全局页表</h5><ul>
<li>由操作系统维护，用于所有进程的页表。</li>
<li>条目数等于主存中的帧数。</li>
<li>与传统的页表相比具有更小的内存占用（比较直接），但查找时间更长。</li>
<li>Linux</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230317005822.png" alt=""></p>
<h5 id="Segmentation-内存分段"><a href="#Segmentation-内存分段" class="headerlink" title="Segmentation 内存分段"></a>Segmentation 内存分段</h5><p>Memory-management scheme that supports user view of memory</p>
<ul>
<li><p>可以认为段是一种大小不固定的“页”</p>
</li>
<li><p>Logical address defined as <strong><segment-number, offset></strong></p>
<ul>
<li>( in paging scheme, we use <page-number, offset> )</li>
</ul>
</li>
<li><p>Segment table 分段表</p>
<ul>
<li>maps two-dimensional physical addresses</li>
</ul>
</li>
<li><p>each table entry has</p>
<ul>
<li>base<ul>
<li>contains the starting physical address where the segments reside in memory</li>
</ul>
</li>
<li>limit<ul>
<li>specifies the length of the segment  </li>
</ul>
</li>
</ul>
</li>
<li><p>Simularly keeping the <strong>Segment-Table</strong></p>
<ul>
<li>Segment-table base register (STBR)<ul>
<li>segment table’s location in memory  </li>
</ul>
</li>
<li>Segment-table length register (STLR) <ul>
<li>indicates number of segments  </li>
<li>used by a program:<ul>
<li>segment number s is legal if s &lt; STLR</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Segmentation-and-paging-scheme"><a href="#Segmentation-and-paging-scheme" class="headerlink" title="Segmentation and paging scheme"></a>Segmentation and paging scheme</h4><ul>
<li>Windows</li>
</ul>
<h2 id="大容量存储系统"><a href="#大容量存储系统" class="headerlink" title="大容量存储系统"></a>大容量存储系统</h2><h3 id="Disk-基础"><a href="#Disk-基础" class="headerlink" title="Disk 基础"></a>Disk 基础</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230331010733.png" alt=""></p>
<h4 id="HDD"><a href="#HDD" class="headerlink" title="HDD"></a>HDD</h4><ul>
<li>Overview<ul>
<li>Drives rotate at 60 to 250 times per second  </li>
<li>Transfer rate is rate at which data flows between drive and computer  </li>
<li><strong>Positioning time (random-access time)</strong> is time to move disk arm to <strong>desired cylinder (seek time)</strong> and <strong>time for desired sector to rotate under  the disk head (rotational latency)</strong></li>
</ul>
</li>
</ul>
<ol>
<li><p>柱面 (cylinder) &amp; 磁道（track）</p>
<ul>
<li>一个盘片的同心圆轨道称为track，所有盘片上的Track组成的一个柱面状的物理结构程伟cylinder</li>
<li>在同一Cylinder上的所有track可以同时被磁头访问</li>
<li>按cylinder编号不按track编号</li>
<li>（SSD不存在这两个概念）</li>
</ul>
</li>
<li><p>扇区 (sector)</p>
<ul>
<li>一个盘片的同心圆轨道内的一个扇形区域</li>
<li>扇区0是第一个磁道的第一块扇区</li>
<li>每个track的扇区数不固定，与磁盘设计时的角速度有关</li>
</ul>
</li>
<li><p>簇（cluster）：</p>
<ul>
<li>一组相邻的扇区的集合</li>
<li>文件系统中的最小单位</li>
</ul>
</li>
<li>块（block）：<ul>
<li>由多个扇区组成</li>
<li>文件系统管理磁盘空间的基本单位（读写数据的基本单位）。</li>
</ul>
</li>
</ol>
<ul>
<li>逻辑地址的编码<ul>
<li>large 1-d arrays of logical blocks (smallest unit)</li>
<li>is mapped into the sectors of the disk sequentially  </li>
<li>Mapping proceeds in order through that track, <strong>then the rest of the tracks in that cylinder</strong>, and then through the rest of the cylinders from outermost to innermost  </li>
<li>Difficulty in mapping from logical to physical address</li>
<li>Except for bad sectors  <ul>
<li>操作系统检查坏块并在编码时排除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><ol>
<li>页（page）：页是SSD中最小的可读写单元，通常为4KB或8KB大小。</li>
<li>块（block）：类似HHD。由多个页构成。为了增大擦除时一次性操作的块的大小延长寿命，在SSD中通常更大，通常为128KB或256KB大小。（理由后面细说）</li>
</ol>
<h3 id="Disk-Scheduling-Algorithms"><a href="#Disk-Scheduling-Algorithms" class="headerlink" title="Disk-Scheduling Algorithms"></a>Disk-Scheduling Algorithms</h3><p>Idle disk can immediately work on I/O request<br>Busy disk means work must be queued<br>(Optimization algorithms only make sense when a queue exists)</p>
<h4 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h4><p>按queue处理</p>
<h4 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h4><p>Shortest Seek Time First selects the request with the minimum seek time  from the current head position (当前最近)</p>
<h4 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h4><p>The disk arm starts <strong>at one end of the disk</strong>, and <strong>moves toward the other end</strong>,<br><strong>servicing</strong> requests <strong>until it gets to the other end of the disk</strong>, where the head<br>movement is reversed and service continues.</p>
<h4 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h4><p>The head moves <strong>from one end of the disk to the other,</strong> servicing requests as it goes. When it reaches the other end, it <strong>immediately returns</strong> to the beginning of the disk, <strong>without servicing</strong> any requests on the return trip.</p>
<h4 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h4><p>Similar to C-SCAN, but doesn’t reach the two ends.<br>Arm only goes as far as the last request in each direction, then reverses direction immediately, without first going all the way to the end of the disk<br>-》 <strong>in C-XXXX</strong> , arm services always occur in one direction. when they are moving are the opposite direction, they ‘<strong>immediately returns</strong>‘.</p>
<h3 id="SSD-vs-HDD"><a href="#SSD-vs-HDD" class="headerlink" title="SSD vs HDD"></a>SSD vs HDD</h3><p><strong>Nonvolatile memory devices</strong></p>
<ul>
<li>disk-drive like -&gt; solid-state disks (SSD)</li>
</ul>
<ul>
<li>(Other forms include USB drives (thumb drive, flash drive), DRAM stick, and main storage in devices like smartphones  )</li>
<li>Storage capacity / price<br>  capacity: HDD usually &gt; SSD<pre><code>  magnetic disks (HDD) hold much more data.
</code></pre>  price : SDD usually &gt; HDD (per MB)</li>
<li>Reliability<ul>
<li>SSD &gt; HDD<ul>
<li>SSDs have no moving parts (like magnetic disks and read/write heads) -&gt;less possible to damage</li>
</ul>
</li>
</ul>
</li>
<li>==Lifespan==<ul>
<li>SSD &lt;&lt; HDD</li>
<li>-&gt; SSD need to be <strong>carefully</strong> managed (storage units have a certain erasing and writing life) -&gt; <strong>disk management</strong></li>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
<li>Speed<ul>
<li>SSD &gt;&gt; HDD</li>
<li>No moving parts, so no seek time or rotational latency</li>
</ul>
</li>
<li>Bus speed<ul>
<li>SSD requires a direct connection to a high-speed bus (such as PCI) for maximum performance</li>
<li>(while HDDs are not subject to this limitation)</li>
</ul>
</li>
<li>==Disk management==<ul>
<li>SSDs need to implement complex flash controller algorithms, such as garbage collection, wear leveling, etc., to manage storage space. </li>
<li>HDDs, on the other hand, require low-level formatting (physical formatting) and logical formatting (logical formatting) to create file systems and deal with problems such as bad blocks.</li>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
<li>==Space management==<ul>
<li>In HDD, the file system usually uses clusters (簇) to manage disk space, and the size of the cluster is usually fixed. </li>
<li>In SSD, due to the complexity of its internal data management method, the file system usually needs to adopt different space management strategies, such as TRIM command and garbage collection (Garbage Collection), etc., to maintain the performance and lifespan of SSD.</li>
<li><strong>LET’S TALK ABOUT IT LATER</strong></li>
</ul>
</li>
</ul>
<h3 id="Space-amp-Disk-Management"><a href="#Space-amp-Disk-Management" class="headerlink" title="Space &amp; Disk Management"></a>Space &amp; Disk Management</h3><h4 id="HDD-1"><a href="#HDD-1" class="headerlink" title="HDD"></a>HDD</h4><ul>
<li>-&gt; Dividing a disk into <strong>sectors</strong> that the disk controller can read and write  <ul>
<li>Each sector can hold header information + data + error correction code (<strong>ECC</strong>)  </li>
<li>Usually 512b data but can be selectable  </li>
</ul>
</li>
<li>OS needs to record its own data structures on the disk  <ul>
<li>Part groups of cylinders, each treated as a logical disk  </li>
<li><strong>Logical formatting</strong> or “making a file system”  </li>
<li>To increase efficiency most file systems <strong>group blocks into clusters</strong><br>  Disk I/O done in blocks ; File I/O done in clusters</li>
</ul>
</li>
<li>Boot block initializes system<ul>
<li>The bootstrap is stored in ROM  </li>
<li><strong>Bootstrap loader</strong> program stored in boot blocks of boot partition  </li>
</ul>
</li>
<li>Methods such as <strong>sector sparing</strong> used to handle bad blocks</li>
</ul>
<p>MBR</p>
<ul>
<li>Boot code + partition table (contains pointer to boot partition)</li>
</ul>
<h4 id="SSD-1"><a href="#SSD-1" class="headerlink" title="SSD"></a>SSD</h4><ul>
<li>Read and written in <strong>“page”</strong> increments (think sector) <ul>
<li>==but can’t overwrite in place==<ul>
<li>Must first be erased, and erases happen in larger “block” increments</li>
<li>要修改或擦除一个页，需要先将整个块读取到内存中，然后进行修改或擦除，最后再将整个块写回SSD。(所以SSD的块常常比HHD大的多，以增大每次擦写的大小、减小擦写次数)</li>
</ul>
</li>
<li>Can only be erased a limited number of times before worn out ~ 100,000  </li>
<li>Life span measured in drive writes per day (<strong>DWPD</strong>)  <ul>
<li>A 1TB NAND drive with rating of 5DWPD is expected to have 5TB per day written within warrantee period without failing</li>
</ul>
</li>
<li>块级别的操作对于SSD的性能和寿命管理是非常重要的。-》</li>
</ul>
</li>
</ul>
<p><strong>NAND Flash Controller Algorithms</strong>  </p>
<ul>
<li>With no overwrite, pages end up with mix of valid and invalid data. We need ways  to manage them: <ul>
<li>flash translation layer (FTL) table (a part of NAND flash)<ul>
<li>Track which logical blocks are valid</li>
</ul>
</li>
<li>TRIM (a instruction involving SSD and OS)<ul>
<li>inform which logical blocks are invalid more flexibly and timely</li>
</ul>
</li>
<li>Garbage collection (GC)<ul>
<li>Allocates overprovisioning to provide working space for GC  </li>
<li>垃圾回收是SSD内部的一种自动化操作，用于清理和整理闲置和无效的页。当文件被删除或修改时，SSD的页可能会变得闲置或无效，但这些页实际上仍然占据着宝贵的存储空间。垃圾回收操作会定期或在需要时将这些闲置和无效的页整理到一起，并执行擦除操作，以便可以重新分配给新的数据，从而提高SSD的存储效率。</li>
</ul>
</li>
</ul>
</li>
<li>Write Wear Leveling (均衡写入耗损) <ul>
<li>Each cell has lifespan, try to write equally to all cells</li>
<li>这可以通过在写入新数据时选择尽可能少使用写入次数较多的块，或将写入数据随机分布到多个块中来实现。</li>
</ul>
</li>
</ul>
<h3 id="Disk-Attachment"><a href="#Disk-Attachment" class="headerlink" title="Disk Attachment"></a>Disk Attachment</h3><ul>
<li>Drive attached to computer via I/O bus  <ul>
<li>Host controller in computer uses bus to <strong>talk to disk controller</strong> built into drive  </li>
<li>Busses vary (protocols vary)<ul>
<li>接口协议规定了硬件设备之间的通信协议和通信方式，而数据总线BUS则是物理连接这些设备之间的通信通道。</li>
<li>including EIDE, ATA, SATA, USB, SCSI, Fiber Channel, SAS, Firewire…</li>
<li>家用计算机的CPU多使用PCI、SATA等接口协议，FC更多用于企业计算机和数据中心环境。</li>
</ul>
</li>
</ul>
</li>
<li><strong>SCSI</strong>（Small Computer System Interface）<ul>
<li>过去比较常见</li>
<li>a bus, up to 16 devices on one cable</li>
<li>SCSI initiator 发起器 requests operation 发送操作请求 and SCSI targets 目标设备 perform tasks</li>
<li>Each target can have up to 8 logical units (disks attached to device controller)  </li>
</ul>
</li>
<li><strong>FC</strong> （Fiber Channel） 光纤通道 <ul>
<li>a <strong>high</strong>-speed serial architecture  </li>
<li>Can be switched fabric with 24-bit address space – the basis of storage area networks (SANs 存储区域网络) in which many hosts attach to many storage  units</li>
<li>通常用于需要大规模存储和高速数据传输的应用场景</li>
</ul>
</li>
</ul>
<h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><ul>
<li>Redundant Arrays of Independent Disks (RAIDs)  </li>
<li>RAID– multiple disk drives provides reliability via redundancy  <ul>
<li>Mirroring  ( -&gt; a second copy)<ul>
<li>duplicate every disk  </li>
</ul>
</li>
<li>Parity bit  ( -&gt; error-correcting bit)</li>
</ul>
</li>
<li>Parallel access to multiple disk improves performance  <ul>
<li>Bit-level striping  <ul>
<li>split the bits of each byte across multiple disks  </li>
</ul>
</li>
<li>block-level striping  <ul>
<li>blocks of a file are striped across multiple disks  </li>
</ul>
</li>
</ul>
</li>
<li>RAID is arranged into seven or more different levels</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415031202.png" alt=""></p>
<p>RAID 6: P + Q redundancy  </p>
<ul>
<li>Reed-Solomon codes  <ul>
<li>2 bits of redundant data are stored for every 4 bits of data  </li>
<li>在RAID6中，数据被分布式地存储在多个磁盘驱动器中，同时通过计算奇偶校验信息对数据进行冗余存储。RAID6采用两个奇偶校验盘（P和Q盘）来存储奇偶校验信息，从而实现了对两个磁盘驱动器的故障容忍。</li>
</ul>
</li>
</ul>
<p>交织分布奇偶校验（如RAID 5）和复制（如RAID 1）是两种不同的数据保护策略，它们在数据存储和容错方式上有以下区别：</p>
<p>假设有一个包含4个数据盘和1个奇偶校验盘的RAID 5阵列，其中数据盘分别标记为D1、D2、D3、D4，奇偶校验盘标记为P。当一个数据盘出现故障时，可以通过从其他数据盘和奇偶校验盘中恢复数据。<br>例如，当D2数据盘出现故障时，需要从其他数据盘和奇偶校验盘中恢复D2上的数据。RAID 5使用异或（XOR）运算来生成奇偶校验信息，该运算具有可逆性，可以用于数据恢复。<br>假设D1、D3和D4上的数据分别为A、B和C，而P上的奇偶校验信息为A XOR B XOR C。现在需要恢复D2上的数据B，可以通过执行以下步骤：</p>
<ol>
<li>从D1、D3和D4中读取对应位置上的数据，得到A、B和C的值。</li>
<li>从奇偶校验盘P中读取对应位置上的奇偶校验信息，得到A XOR B XOR C的值。</li>
<li>通过对已知的A、B和C的值以及A XOR B XOR C的值执行异或运算，即 (A XOR B XOR C) XOR (A XOR C) = B，得到D2上的数据B的值。</li>
<li>将得到的B的值写入到替换后的新数据盘D2上，完成数据恢复。</li>
</ol>
<p>这样，通过从其他数据盘和奇偶校验盘中恢复数据，可以在某个数据盘出现故障时保护数据的完整性，并维持RAID 5阵列的可靠性和可用性。</p>
<h3 id="Network-Attached-Storage"><a href="#Network-Attached-Storage" class="headerlink" title="Network-Attached Storage"></a>Network-Attached Storage</h3><ul>
<li>Network-attached storage (NAS) is storage made available over a network rather than over a local connection (such as a bus)  <ul>
<li>Remotely attaching to file systems  </li>
</ul>
</li>
<li>Implemented via remote procedure calls (RPCs) between host and storage over typically TCP or UDP on IP network  </li>
<li>iSCSI protocol uses IP network to carry the SCSI protocol  <ul>
<li>Remotely attaching to devices (blocks) -&gt; virtual disks</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415031456.png" alt=""></p>
<ul>
<li>Storage Area Network（SAN）存储区域网络<ul>
<li>Common in large storage environments  </li>
<li>Multiple hosts attached to multiple storage arrays - flexible</li>
<li>use high-speed buses，like Fibre Channel or iSCSI</li>
</ul>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../assets/Pasted%20image%2020230415031437.png" alt=""></p>

  


  </article>
  
<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">回顾上一篇</div><a href="/files/courseNotes/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2.html">现代操作系统2-CS2310</a></div><div class="item" id="next"><div class="note">接下来阅读</div><a href="/files/courseNotes/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html">高级数据结构-SE2322</a></div></section></div>

  

  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      <p>评论区仅供交流~</p>

    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="aleryxiao/aleryxiao.github.io" data-repo-id="R_kgDOIdw0jw" data-category="Announcements" data-category-id="DIC_kwDOIdw0j84CTXeH" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>




      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/categories">分类</a><a href="/tags">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs14">整理</span><a href="/wiki">文件夹</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friend">友链</a><a href="/guestbook">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about">关于</a><a target="_blank" rel="noopener" href="https://github.com/aleryxiao">GitHub</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://space.bilibili.com/19610138">@AleryXiao</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
