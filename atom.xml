<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>極楽浄土</title>
  
  <subtitle>フロトの理发店 | @AleryXiao</subtitle>
  <link href="https://floatdesu.github.io/atom.xml" rel="self"/>
  
  <link href="https://floatdesu.github.io/"/>
  <updated>2023-03-11T17:53:42.715Z</updated>
  <id>https://floatdesu.github.io/</id>
  
  <author>
    <name>AleryXiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>群晖docker部署code-server</title>
    <link href="https://floatdesu.github.io/Engineer/262484b2.html"/>
    <id>https://floatdesu.github.io/Engineer/262484b2.html</id>
    <published>2023-03-10T12:42:08.000Z</published>
    <updated>2023-03-11T17:53:42.715Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>为了更好地使用，或许需要调试用的设备连接SSH。</p><ol><li>在设置中打开SSH功能（默认端口号为22）</li><li>在windows terminal内 输入 <code>SSH &#123;user name&#125;@&#123;IP&#125;:22</code></li><li>选择yes，并输入密码（不会明文在控制台显示）</li><li>控制台的前缀改变，变为{username}@{设备名}，即为连接成功。通用的linux指令可以进行操作，sudo指令可获取管理员权限</li></ol></li><li><p>下载code-server映像</p></li></ol><p>官方接口的链接似乎已经失效。可以自行下载后上传至群晖。<br>``</p><ol><li><p>通过SSH/群晖docker-GUI来指定端口和环境变量等</p><ol><li>端口 8080:8080 TDP （容器默认端口为8080，本地端口只要不冲突都可以用）</li><li>打开自动重启</li><li>环境变量（不配置PUID和PGID，通过直接修改文件权限虽然不安全但是能用）<br> PUID=1000<br> PGID=1000<br> TZ=Asia/Shanghai<br> PASSWORD={password}<br> *如何查找PUID和PGID：连接SSH，<code>cat /etc/passwd</code>查看对应用户行的两个编号</li><li>文件映射<br> 必须要映射的只有config。找个地方分配一个文件夹就好了。<br> <code>&#123;your dir&#125; : /home/coder/.config</code><br> 工作区文件夹也可以随便映射。<br> <code>&#123;your dir&#125; : /home/project</code></li></ol></li><li><p>访问对应IP并输入密码即可登入<br> 第一次打开网页会出现一个密码输入框，输入即可。<br> 密码：初始密码可以用你喜欢的方法从映射的.config文件夹获取<br> SSH命令行的一种方法</p><pre><code> `docker exec -it code-server bash` `vi ~/.config/code-server/config.yaml`</code></pre><p> 群晖访问、下载、打开</p><pre><code> ...</code></pre></li><li><p>其它的可能出现的问题：</p><ol><li><p>只能读取文件，不能修改：</p><pre><code>与群晖的文件读写权限设置有关。一个粗暴但是不安全的方法：连接群晖SSH，直接修改project文件夹的权限`chmod 777 -R &#123;Your dir&#39;s name&#125;`</code></pre></li><li><p>无法安装vscode扩展</p><pre><code>好像就是不能直接从扩展商店安装（对我只有中文插件成功了）可以从扩展商店访问对应扩展的页面并且获取对应版本的链接，下载`.vsix`文件并手动安装</code></pre></li></ol></li><li><p>关于Cpp环境配置：<br> 依次执行（SSH连接）<br> <code>sudo apt-get update</code><br> <code>sudo apt-get install build-essential gdb</code><br> 此时可以安装C插件和code-runner快乐编码了</p></li><li><p>关于python等环境配置</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//切换 root 用户</span><br><span class="line">sudo su</span><br><span class="line"></span><br><span class="line">//更新源</span><br><span class="line">sed -i &quot;s/archive.ubuntu.com/mirrors.aliyun.com/g&quot; /etc/apt/sources.list &amp;&amp; apt update</span><br><span class="line"></span><br><span class="line">//安装 python</span><br><span class="line">apt install -y python</span><br><span class="line"></span><br><span class="line">//安装 nodejs，自行调整版本</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_14.x | sudo bash</span><br><span class="line">apt install -y nodejs</span><br><span class="line"></span><br><span class="line">//安装 jdk</span><br><span class="line">apt install -y openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>最好选用<a href="https://github.com/microsoft/vscode-python/releases?q=2019&amp;expanded=true">19年以前</a>，最新版本的python插件并不兼容</p><p>`</p><ol><li>可以选择更改docker权限</li></ol><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chmod a+rw /run/docker.sock # 或者 chmod a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure><p>即可在docker的terminal内使用sudo指令</p>]]></content>
    
    
    <summary type="html">今天上课moonlight竟然断了，好绝望，或许还是要有个后手才比较好……</summary>
    
    
    
    <category term="Engineer" scheme="https://floatdesu.github.io/categories/Engineer/"/>
    
    
    <category term="linux" scheme="https://floatdesu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>WSL2环境配置</title>
    <link href="https://floatdesu.github.io/Engineer/b1be395e.html"/>
    <id>https://floatdesu.github.io/Engineer/b1be395e.html</id>
    <published>2023-02-15T09:15:44.000Z</published>
    <updated>2023-04-04T00:19:32.675Z</updated>
    
    <content type="html"><![CDATA[<ul><li>注意：功能需要hyper-v，与现下绝大多数的模拟器软件冲突</li></ul><h3 id="1-程序和功能添加（需要重启）"><a href="#1-程序和功能添加（需要重启）" class="headerlink" title="1. 程序和功能添加（需要重启）"></a>1. 程序和功能添加（需要重启）</h3><p>控制面板-程序-启用或关闭windows功能，勾选“适用于Linux的Windows子系统“ 和 “虚拟机平台”</p><h3 id="2-配置WSL"><a href="#2-配置WSL" class="headerlink" title="2. 配置WSL"></a>2. 配置WSL</h3><p>设置WSL2为默认内核，更新WSL并重启WSL服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br><span class="line">wsl --update</span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure><h3 id="3-下载Ubuntu"><a href="#3-下载Ubuntu" class="headerlink" title="3. 下载Ubuntu"></a>3. 下载Ubuntu</h3><p>在应用商城搜索Ubuntu并下载安装对应版本，之后打开即可。<br>（在Windows terminal中，现在在+中也可以添加ubuntu终端了，界面非常漂亮）</p><p>按照提示输入用户名和密码（不需要和windows系统相同。密码输入不会回显）</p><h3 id="4-（可选）映射网络驱动器"><a href="#4-（可选）映射网络驱动器" class="headerlink" title="4. （可选）映射网络驱动器"></a>4. （可选）映射网络驱动器</h3><p>此电脑-映射网络驱动器，文件夹填<code>\\wsl$\Ubuntu-20.04</code>（-对应的版本号，可以先在文件资源管理器进入<code>\\wsl$</code>进行确认）</p><p>不要映射也挺好的，可以在文件资源管理器固定一个快速访问。</p><p><strong>注意！</strong> 这个文件夹只有在ubuntu运行时才能打开。</p><h3 id="5-Vscode配置wsl2终端"><a href="#5-Vscode配置wsl2终端" class="headerlink" title="5. Vscode配置wsl2终端"></a>5. Vscode配置wsl2终端</h3><p>Vscode在插件市场搜索WSL（蓝底白字小企鹅图标）安装，之后侧边栏会出现“远程资源管理器”，点进去新建窗口即可。</p><p>可以先在Ubuntu建立一个工作文件夹、在Vscode中打开。</p><p>要运行代码，需要相应地配置Ubuntu代码环境和Vscode（远程）插件。</p><p>例如：C/C++</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install gcc</span><br><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><p>如果中途出现Y/N选项，输入Y即可。</p><p>用<code>gcc --version</code>检查安装是否成功。</p><p>在Vscode中，也安装C/C++插件（这里的安装和本地vscode是不互通的！而是在工作区目录下新建.vscode文件夹）</p><p>现在，点击运行和调试均可正常运行了！</p><h3 id="6-其它"><a href="#6-其它" class="headerlink" title="6. 其它"></a>6. 其它</h3><ul><li><code>/mnt</code> 是windows磁盘在wsl中的映射</li></ul><h3 id="7-linux代码环境配置"><a href="#7-linux代码环境配置" class="headerlink" title="7. linux代码环境配置"></a>7. linux代码环境配置</h3><ul><li>安装包的过程中出现<code># The following packages have unmet dependencies</code></li></ul><p><a href="https://blog.csdn.net/qq_41566366/article/details/121244177">解决办法</a></p><p>先执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get clean</span><br><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure><p>如果不行再执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt --fix-broken install    //修复系统中已安装的软件包依赖关系的错误，尝试下载并安装缺失的依赖软件包，并解决其他软件包冲突问题。</span><br><span class="line"></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade //这会更新所有软件到最新版本，建议不要使用</span><br><span class="line"></span><br><span class="line">sudo dpkg --configure -a  //重新配置未成功安装的软件包。</span><br><span class="line"></span><br><span class="line">sudo apt-get install -f    //修复已安装的软件包依赖关系错误。当某些软件包在安装或卸载过程中出现问题时，可能会导致软件包依赖关系错误，此时可以执行该命令以修复依赖关系错误。需要注意的是，该命令并不会安装新的软件包，它只会修复已安装的软件包依赖关系错误。如果需要安装新的软件包，应该使用 sudo apt-get install</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>安装包的过程中出现<code>Failed to fetch http://security.ubuntu.com/ubuntu/pool/main/b/binutils/binutils-common_2.30-21ubuntu1~18.04.7_amd64.deb</code></li><li><code>sudo vim /etc/apt/sources.list</code></li><li><p>全部替换</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></li><li><p><code>sudo apt-get update</code></p></li></ul>]]></content>
    
    
    <summary type="html">很简单，记录一下</summary>
    
    
    
    <category term="Engineer" scheme="https://floatdesu.github.io/categories/Engineer/"/>
    
    
    <category term="linux" scheme="https://floatdesu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>蓝叠adb连接并配置网络代理</title>
    <link href="https://floatdesu.github.io/Engineer/95cd8fac.html"/>
    <id>https://floatdesu.github.io/Engineer/95cd8fac.html</id>
    <published>2023-02-15T07:48:36.000Z</published>
    <updated>2023-02-15T08:21:30.807Z</updated>
    
    <content type="html"><![CDATA[<p>说在前面：</p><ol><li>由于配置wsl导致原模拟器失效，选择了蓝叠模拟器（下载安装器后会自动配置为Hyper-v版本）</li><li>蓝叠国际不能自动配置root，需要手动破解，此处选择的是蓝叠中国（二者可以同时安装并共存，也可以单独卸载）</li><li>使用SSR打开局域网共享功能以端口号1080能够成功配置代理，<strong>但是无法进行pac代理</strong>，代理规则和代理模式与代理服务server（主机）<strong>不同步</strong>。感觉不如在模拟器里再装一个SSR……</li></ol><h3 id="1-配置Adb环境"><a href="#1-配置Adb环境" class="headerlink" title="1. 配置Adb环境"></a>1. 配置Adb环境</h3><p>下载（以下链接为最新版本）</p><blockquote><p>ADB和Fastboot for Windows<br><a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip">https://dl.google.com/android/repository/platform-tools-latest-windows.zip</a></p><p>ADB和Fastboot for Mac<br><a href="https://dl.google.com/android/repository/platform-tools-latest-darwin.zip">https://dl.google.com/android/repository/platform-tools-latest-darwin.zip</a></p><p>ADB和Fastboot for Linux<br>   <a href="https://dl.google.com/android/repository/platform-tools-latest-linux.zip">https://dl.google.com/android/repository/platform-tools-latest-linux.zip</a></p></blockquote><p>下载完成后，找个地方解压并添加目录到系统环境变量(Path)，以方便在任意位置用adb指令进行调用</p><h3 id="2-蓝叠Adb环境"><a href="#2-蓝叠Adb环境" class="headerlink" title="2. 蓝叠Adb环境"></a>2. 蓝叠Adb环境</h3><p>在设置-高级选项中打开蓝叠的Adb开关后会出现<code>127.0.0.1:port</code>的地址，如<code>127.0.0.1:51213</code>。</p><p>*：关于<code>127.0.0.1</code>——被称为<strong>本地环回地址(Loopback Address)</strong>，是一个虚拟的地址，可以用localhost代指。（Link：<a href="https://blog.csdn.net/msdnwolaile/article/details/51278867">127.0.0.1和localhost和本机IP三者的区别</a>）</p><p>保存后最好重启模拟器。模拟器每次重启，端口号都会改变。</p><h3 id="3-Adb连接到Bluestacks"><a href="#3-Adb连接到Bluestacks" class="headerlink" title="3. Adb连接到Bluestacks"></a>3. Adb连接到Bluestacks</h3><p>开启模拟器的情况下，在cmd中输入：<br><code>adb connect localhost:[port]</code></p><p>显示connected即已经连接成功，此时用<code>adb devices</code>可以看到端口地址<br><code>adb -s localhost:[port] shell</code></p><p>连接成功的情况下，该指令进入该设备直连的adb环境，cmd接下来的指令都不需要输入adb，而是以[设备码]:/ $ 开头<br>在这个环境下，继续输入指令可以配置设备的各参数。↓</p><h3 id="4-代理修改指令"><a href="#4-代理修改指令" class="headerlink" title="4. 代理修改指令"></a>4. 代理修改指令</h3><p><strong>注意</strong>，代理的错误配置可能导致<strong>无法联网</strong>。<br>用内置chrome打开任意网页发现不能联网的话，就用下面的指令换回默认代理。</p><h5 id="修改为指定代理指令"><a href="#修改为指定代理指令" class="headerlink" title="修改为指定代理指令"></a>修改为指定代理指令</h5><p><code>settings put global http_proxy [ip]:[port]</code></p><p>（据说可以在端口号后加/pac和/direct，试了一下发现虽然不影响联网但是也没有按指定的模式运行……这种代理似乎默认为全局，只要SSR软件在运行，无论是否为直连模式、模拟器都好像走全局代理）</p><h5 id="恢复默认代理指令（不要漏掉-）"><a href="#恢复默认代理指令（不要漏掉-）" class="headerlink" title="恢复默认代理指令（不要漏掉:）"></a>恢复默认代理指令（不要漏掉:）</h5><p><code>settings put global http_proxy :0</code></p><h5 id="如何确认代理中的ip地址"><a href="#如何确认代理中的ip地址" class="headerlink" title="如何确认代理中的ip地址"></a>如何确认代理中的ip地址</h5><p>*修改代理的ip取决于电脑本机ip，通过在cmd新窗口内输入<code>ipconfig /all</code>可以查看本机ip，对于我的电脑而言，该ip为<code>192.168.1.104</code><br>如果不确认哪个ip是对的，可以把查到的各个ip全都试一遍，模拟器中网页对网络代理的情况几乎是实时刷新的。</p><h5 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h5><p>用<code>settings delete global http_proxy</code> 可以删除代理，但是这样会直接连不上网（）<br><code>exit</code>指令可以直接退出adb。</p>]]></content>
    
    
    <summary type="html">流程和踩坑record</summary>
    
    
    
    <category term="Engineer" scheme="https://floatdesu.github.io/categories/Engineer/"/>
    
    
    <category term="Android" scheme="https://floatdesu.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>2022学年第一学期总结</title>
    <link href="https://floatdesu.github.io/Private/ca7300c6.html"/>
    <id>https://floatdesu.github.io/Private/ca7300c6.html</id>
    <published>2023-02-10T10:07:47.000Z</published>
    <updated>2023-02-15T05:21:20.626Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://floatdesu.github.io/Private/ca7300c6.html">使用网页版浏览</a></p><h3 id="大二上学期总结"><a href="#大二上学期总结" class="headerlink" title="大二上学期总结"></a>大二上学期总结</h3><p>学和玩都很愉快的一个学期！</p><p>课上的话，把非常非常非常不擅长的几门物理过了，专业课也能说学到了很多东西。QT的IDE确实差强人意，C++QT差不多会用但是不喜欢，不过借此机会学习了PythonQT，玩得相当开心（）</p><p>课余时间，用家教钱入手了游戏机，在游戏中巩固日语学习（？？？）；学习了很多python相关的内容……</p><h4 id="大二上学期学习情况"><a href="#大二上学期学习情况" class="headerlink" title="大二上学期学习情况"></a>大二上学期学习情况</h4><p>‌‌‌惯例的贴成绩单环节（x）（计算机组成待重考）</p><div class="table-container"><table><thead><tr><th>课程代码</th><th>课程名称</th><th>学分</th><th>分数</th></tr></thead><tbody><tr><td>CS2309</td><td>问题求解与实践</td><td>3</td><td>93</td></tr><tr><td>CS2501</td><td>离散数学</td><td>3</td><td>86</td></tr><tr><td>MATH1207</td><td>概率统计</td><td>3</td><td>93</td></tr><tr><td>PHY1222</td><td>大学物理实验（2）</td><td>1</td><td>88</td></tr><tr><td>MARX1204</td><td>马克思主义基本原理</td><td>3</td><td>87</td></tr><tr><td>MARX1205</td><td>形势与政策</td><td>0.5</td><td>84</td></tr><tr><td>MECH2508</td><td>理论力学</td><td>4</td><td>88</td></tr><tr><td>PHY1252</td><td>大学物理(A类）（2）</td><td>4</td><td>77</td></tr></tbody></table></div><p>‌‌‌2021年总学积分86.84，排位61/102，……，你系的这个分数我真的是受不了了……要是我上学期期末没退远，现在估计要跟致远老师拉扯退远了，问了一下室友专业的均分会觉得难以忍受的程度……你系……哎……</p><p>这学期觉得在这些方面已经挺好了，物理也没挂科，及格多点的卷面分给老师有力捞起，我已经不觉得有很多地方能提高了……或者说，我对这个学习成果本身就没什么不满意的地方，对于排位的话，……反正不能保研的话考多少分也无所谓吧，觉得重要的东西都学到了也行吧。</p><h4 id="尝试的项目（coding相关）"><a href="#尝试的项目（coding相关）" class="headerlink" title="尝试的项目（coding相关）"></a>尝试的项目（coding相关）</h4><p>主要是python，涉及到图像、pdf处理、excel处理、爬虫等等，想用就去了解一下，python也不愧为一个知名的好上手的语言，而且轮子非常多。美中不足做出来即使很小的东西也不得不打一个很大很大的包，按我同学的说法、这种程序就是“程序员之间的小情趣”……</p><p>比较杂，内容不复杂，主要是组装轮子然后调试一下，不过因为我比较菜所以也要花挺多心思的x</p><h5 id="1-Python-文字游戏录屏生成带时间轴的字幕文件"><a href="#1-Python-文字游戏录屏生成带时间轴的字幕文件" class="headerlink" title="1. (Python) 文字游戏录屏生成带时间轴的字幕文件"></a>1. (Python) 文字游戏录屏生成带时间轴的字幕文件</h5><p>涉及三个模块，视频抽帧图片的相似度比较、百度Ocr和EasyOcr两个接口的图片OCR、Excel文档的写处理（xlwt库）</p><blockquote><p>Author: AleryXiao<br>Date: 2022.10.15<br>Title: 抽取视频关键帧(可设置抽样频率和相似程度要求)并批量OCR识别图片并输出文件名和内容到Excel文档(利用百度OCR的Api)<br>Content:</p><pre><code>0. *两个用户可设定参数*    a. 抽帧频率targetFPS (每秒钟抽取几帧)    b. 目标相似度threshold (低于此相似度的图片将会被保存)    更高的targetFPS会消耗更多的时间, 但是会生成更精确的时间码1. 通过弹出的文件资源窗口选择一个或多个视频文件2. 对于每个视频文件：    按给定的每秒帧数进行抽帧(cv2.VideoCapture) 抽取的帧存储在temp.jpg中    对于第0个满足条件的帧, 存储至cache中    对于其它满足条件的帧, 将之与cache作比较:        如果相似度大于threshold  -&gt;储存至本地和cache, 更新cache为这一图片, 输出储存信息            OCR并将OCR结果和名字写入Excel文档 (在控制台输出处理结果)        如果相速度小于threshold  -&gt;输出舍弃信息        (SSIM的运行速度较为有限, 或许可以考虑使用多线程运行？)    完成后, 关闭抽帧相机, 输出完成的信息</code></pre></blockquote><h5 id="2-（Python）青年大学习名单对照和结果梳理"><a href="#2-（Python）青年大学习名单对照和结果梳理" class="headerlink" title="2. （Python）青年大学习名单对照和结果梳理"></a>2. （Python）青年大学习名单对照和结果梳理</h5><p>是帮同学做着玩的小软件！&gt;w&lt;</p><p>文件是.xlsx，导致之前学的xlwt用不了，学习了pandas库和dataframe类型做的。</p><p>正好遇到学习QT，给它做了图形化界面。<br>‌‌</p><h5 id="3-（Python）漫画-小说爬虫"><a href="#3-（Python）漫画-小说爬虫" class="headerlink" title="3. （Python）漫画/小说爬虫"></a>3. （Python）漫画/小说爬虫</h5><p>静态网页用了很经典的美丽汤库，但是漫画网页用了懒加载所以得用selenium库。</p><p>对于漫画，输出结果为结构清晰的文件夹及其内图片，进一步要做处理就是图片-&gt;PDF处理的环节，也顺便试了一下&gt;w&lt;，还加了书签，结果一时之间非常满意（）</p><h5 id="4-（Python）qq空间说说爬虫"><a href="#4-（Python）qq空间说说爬虫" class="headerlink" title="4. （Python）qq空间说说爬虫"></a>4. （Python）qq空间说说爬虫</h5><p>需要用到JS点击，为了方便也直接用selenium做的，输出内容到.md文件。</p><h5 id="5-一些特别简单的"><a href="#5-一些特别简单的" class="headerlink" title="5. 一些特别简单的"></a>5. 一些特别简单的</h5><p>数据绘图、图像批量黑边去除和滤镜、批量删除.md的未引用附件（后来发现obsidian有插件可以直接处理，……），之类的</p><h4 id="其它的事情（coding不那么相关）"><a href="#其它的事情（coding不那么相关）" class="headerlink" title="其它的事情（coding不那么相关）"></a>其它的事情（coding不那么相关）</h4><h5 id="1-做教程视频"><a href="#1-做教程视频" class="headerlink" title="1. 做教程视频"></a>1. 做教程视频</h5><p>其实不是第一次做教程视频，上学期电路理论也在b站做过，这次是做的汇编语言编程相关的x，本意还是给同学做着玩的，但是意外地很受欢迎，几天就上万播放了而且为我的账号带来了+1.5k的粉丝数（草）</p><h5 id="2-个人博客（hexo-github）"><a href="#2-个人博客（hexo-github）" class="headerlink" title="2. 个人博客（hexo+github）"></a>2. 个人博客（hexo+github）</h5><p><a href="floatdesu.github.io">Link</a>：floatdesu.github.io<br>（基本是游戏玩后感就是了x）</p><p>嗯，，，总之就是玩得非常开心，现在也还在用，有很多可以玩的花活<br>说起来这还是我第一次用git，……感觉博大精深。</p><h5 id="3-后续就要到寒假了"><a href="#3-后续就要到寒假了" class="headerlink" title="3. 后续就要到寒假了"></a>3. 后续就要到寒假了</h5><h3 id="寒假"><a href="#寒假" class="headerlink" title="寒假"></a>寒假</h3><p>主要还是在享受生活（不是）</p><p>和同学嚷嚷着啊啊啊啊啊怎么没有一个语言能像C++一样快速又像Python一样有很多包啊、、最好还能有很小巧的封包！同学：那你要不看看golang</p><p>我趣！好东西啊！</p><p>简单学了一下go语言和它的特色（？）结构，比如goroutine channel interface之类的，然后写我的快乐爬虫！（x）</p><p>写完漫画爬虫以后花费几个小时研究go去处理图片-》pdf，发现没有合适的轮子，在issue里发现了遇到同样问题的伙伴，现有的gopdf库的默认dpi会导致图片画质损失，总之就是在这方面和python比不了……</p><p>呜哇，世界上怎么没有完美的编程语言……已经在看Kotlin了在看了在看了（悲）只能说各家语言都有专长吧，技能肯定不是语言的问题，是思路的问题</p><h4 id="尝试的项目"><a href="#尝试的项目" class="headerlink" title="尝试的项目"></a>尝试的项目</h4><h5 id="1-（Go）QQ空间爬虫"><a href="#1-（Go）QQ空间爬虫" class="headerlink" title="1. （Go）QQ空间爬虫"></a>1. （Go）QQ空间爬虫</h5><p><a href="https://floatdesu.github.io/Codes/b854aa89.html">博客页面Link</a></p><p>链接是博客日志x<br>突出一个速度飞快好吧</p><h5 id="2-（Go）漫画爬虫"><a href="#2-（Go）漫画爬虫" class="headerlink" title="2. （Go）漫画爬虫"></a>2. （Go）漫画爬虫</h5><p><a href="https://floatdesu.github.io/Codes/b6f6fe6f.html">博客页面Link</a></p><p>也是速度飞快！封包甚至只有13M（）chromedp是yyds</p><h5 id="3-docker-linux容器搭建QQ原神bot"><a href="#3-docker-linux容器搭建QQ原神bot" class="headerlink" title="3. docker-linux容器搭建QQ原神bot"></a>3. docker-linux容器搭建QQ原神bot</h5><p>挂在我的群晖NAS上&gt;w&lt;</p><p>也不是很难，主要是linux命令行我不是很熟，然后这个bot（Yunzai-V3）的QQ接口并不是很稳定（会被QQ关黑屋），需要很多的尝试和调试……</p><h3 id="学期展望"><a href="#学期展望" class="headerlink" title="学期展望"></a>学期展望</h3><p>看上去硬课还是很多的，感觉要好好学才行呀！开始上日语辅修也蛮期待的，很自信地觉得应该不会花去很多时间精力x新的一天也要开开心心地加油呀！</p><p>（听上去敷衍）主要是我也不知道下学期会有什么想折腾的东西，可能学操作系统就够折腾了（x），不过只要有让我觉得好玩有意义的东西能学就会觉得很开心吧……嗯嗯。按我好朋友的说法就是，要是能一直对coding相关保持热情就好了！希望如此吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://floatdesu.github.io/Private/ca7300c6.html&quot;&gt;使用网页版浏览&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;大二上学期总结&quot;&gt;&lt;a href=&quot;#大二上学期总结&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Private" scheme="https://floatdesu.github.io/categories/Private/"/>
    
    
    <category term="LearningMatome" scheme="https://floatdesu.github.io/tags/LearningMatome/"/>
    
  </entry>
  
  <entry>
    <title>Golang爬取picaComic</title>
    <link href="https://floatdesu.github.io/Codes/b6f6fe6f.html"/>
    <id>https://floatdesu.github.io/Codes/b6f6fe6f.html</id>
    <published>2023-01-30T17:58:19.000Z</published>
    <updated>2023-01-31T09:18:11.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-golang"><a href="#web-golang" class="headerlink" title="web #golang"></a>web #golang</h1><p>第二次的Golang代码！纪念一下~~<br>也是第二次的picaComic爬虫，是之前python程序的再开，但也不算再开，因为做了很多很多的优化，比之前那个性能和稳定性都好得多</p><p>又是一次被迫99%在自己写的代码（）CV工程师已经名不副实了！！</p><h2 id="程序思路复盘"><a href="#程序思路复盘" class="headerlink" title="程序思路复盘"></a>程序思路复盘</h2><p>粗体为比起上次的python程序添加的内容</p><p>在写的过程中，进一步巩固了部分chromedp的函数，学习了chanel和进度条，有机会进一步使用了goroutine（可惜线程池使用失败了，下次再试试），对爬虫的技巧也有了更好一点的理解</p><ol><li>login<ol><li><strong>自动填写</strong>json文件里的用户名的和密码，如果没有就用户手填</li><li><strong>检测</strong>到appcasule框架表示进入了主页，进入下一环节</li></ol></li><li>选择画质<ol><li>本来想做自动选择的但是失败了，弹窗也不能点，原因不明（我怀疑是因为元素在后台的时候是可查询但不可点击的，但在chromedp里似乎没有waitClickable的选项）</li><li>所以放20秒给用户自己点（进入一个漫画页面的左上角就可以改设置）</li><li>没办法做是否选完的检测，除非要求用户发一个信号，太麻烦了不如定时</li></ol></li><li>检查idlist的每一本书，对于每一本书：<ol><li>进入书本主页，获取书本名字，标准化后在savePath（json中设置）中建立一个对应名字的文件夹</li><li>获取<strong>章节数</strong>和<strong>章节名字</strong>，建立子文件夹</li><li>对于每一个章节：<ol><li>进入章节页面，<strong>下拉到页面底部</strong>，重复2-3次检查顶端progressBar的值是否改变（事实上，页面和图片都使用了懒加载，但是图片的懒加载没关系，在标签里可以查询到真实链接），直到到达真正的页面尾部</li><li>查询所有图片元素，获取真实链接，将书的序号、章的序号、图的序号、图的链接绑成一个结构体，把指针送进<strong>下载通道</strong>picChan里</li></ol></li></ol></li><li>下载程序：<ol><li>初始化时就开始运行，监听下载通道中是否有内容，一旦出现内容就创建一个图片下载<strong>进程</strong>，命名按结构体中的序号值来确定</li></ol></li><li><strong>进度条</strong>：vscode自带终端不能在同一行内刷新，cmd运行时正常。<br>本来想试试做多个进度条同时加载（每一章节的图片下载情况），但是考虑到go-progressbar的原理（上下行切换和读取），所以只能用一个条，显示的是浏览器爬取图片真实src的进度而不是图片下载的进度</li></ol><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><ul><li>运行效果很棒！多线程下载也非常给力&gt;w&lt;（虽然没有用线程池，是go自带的线程管理，据说会block）</li><li>比python快，而且封包只有13M，震惊</li><li>不能处理弹窗，有点遗憾，不过不处理弹窗并不影响图片链接的获取，这个还不错（x）</li><li>做了很多上次程序没有做的事情，很开心</li><li>没办法把pdf合成也用go做比较遗憾</li></ul><p>别的</p><ul><li>感觉这次程序的结构可以说是依托答辩，应该多分一点文件的，太长了太乱了！！！下次试试</li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><details class="tag-plugin folding" child="codeblock"><summary><span>main.go</span></summary><div class="body"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;net/url&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;path&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/schollz/progressbar&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/chromedp/cdproto/cdp&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/chromedp/cdproto/page&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/chromedp/chromedp&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/chromedp/chromedp/kb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">homeUrl  <span class="type">string</span> = <span class="string">&quot;https://manhuabika.com/pLogin/&quot;</span></span><br><span class="line">pageUrl  <span class="type">string</span> = <span class="string">&quot;https://manhuabika.com/pcomicview/?cid=&quot;</span></span><br><span class="line">pageUrl2 <span class="type">string</span> = <span class="string">&quot;https://manhuabika.com/pchapter/?cid=&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">account  <span class="type">string</span></span><br><span class="line">password <span class="type">string</span></span><br><span class="line">idList   []<span class="type">string</span></span><br><span class="line">savePath <span class="type">string</span></span><br><span class="line">PROXY    <span class="type">string</span> <span class="comment">//以上从json读取</span></span><br><span class="line">ctx      context.Context</span><br><span class="line">wg       sync.WaitGroup</span><br><span class="line">NmList   [<span class="number">100</span>][<span class="number">100</span>]<span class="type">string</span> <span class="comment">//对于漫画i，[i][0]为书的path，[i][1]-[i][n]为章节的path</span></span><br><span class="line">picChan  <span class="keyword">chan</span> *pic</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pic <span class="keyword">struct</span> &#123; <span class="comment">//图片中包含书编号,章编号,图编号</span></span><br><span class="line">bkNum  <span class="type">int</span></span><br><span class="line">chNum  <span class="type">int</span></span><br><span class="line">picNum <span class="type">int</span></span><br><span class="line">src    <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(idList) == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;no books&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Login() <span class="comment">//登录</span></span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> PicsDownload() <span class="comment">//开启图片监听线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, id := <span class="keyword">range</span> idList &#123;</span><br><span class="line">LoadBook(index, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(picChan)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">standarlizeName</span><span class="params">(oriStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">replacer := strings.NewReplacer(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;|&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;\\&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;:&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;]&quot;</span>, <span class="string">&quot;:&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">return</span> replacer.Replace(oriStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PicsDownload</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">picChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *pic, <span class="number">100000</span>)</span><br><span class="line"><span class="keyword">for</span> picture := <span class="keyword">range</span> picChan &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> PicDownload(picture)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PicDownload</span><span class="params">(picture *pic)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="comment">//HTTP代理</span></span><br><span class="line">proxyAddress, _ := url.Parse(PROXY)</span><br><span class="line">client := &amp;http.Client&#123;Transport: &amp;http.Transport&#123;Proxy: http.ProxyURL(proxyAddress)&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开链接</span></span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, picture.src, <span class="literal">nil</span>)</span><br><span class="line">resp, err := client.Do(req)</span><br><span class="line">Check(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取内容</span></span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">Check(err)</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查路径,保存</span></span><br><span class="line">filePath := NmList[picture.bkNum][picture.chNum] + <span class="string">&quot;/&quot;</span> + fmt.Sprintf(<span class="string">&quot;%02d&quot;</span>, picture.picNum) + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以写|创建的方式打开目标文件(因为文件夹在创建时就已经建好，所以k可以不用检查)</span></span><br><span class="line">f, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line">Check(err)</span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">f.Write(body)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Load</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Navigate(url),</span><br><span class="line">chromedp.WaitVisible(<span class="string">`//div[@class=&#x27;appBottomMenu&#x27;]`</span>))</span><br><span class="line">Check(err)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">//无论如何，等待2秒再进行下一步操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadBook</span><span class="params">(index <span class="type">int</span>, id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">bookNm := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> contentNode []*cdp.Node</span><br><span class="line"></span><br><span class="line">Load(pageUrl + id)</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.TextContent(<span class="string">`//div[@class=&#x27;comic-title text-start&#x27;]`</span>, &amp;bookNm, chromedp.BySearch),</span><br><span class="line">chromedp.Nodes(<span class="string">`//div[@class=&quot;col-3 m-0 mb-1&quot;]`</span>, &amp;contentNode))</span><br><span class="line">Check(err)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;\nStart to process book [%d]%s \n&quot;</span>, index+<span class="number">1</span>, bookNm)</span><br><span class="line"></span><br><span class="line">NmList[index][<span class="number">0</span>] = savePath + <span class="string">&quot;/&quot;</span> + standarlizeName(bookNm)</span><br><span class="line"></span><br><span class="line"><span class="comment">//章节数</span></span><br><span class="line">chaps := <span class="built_in">len</span>(contentNode)</span><br><span class="line">fmt.Printf(<span class="string">&quot;\nTotal: %d Chapters \n&quot;</span>, chaps)</span><br><span class="line"></span><br><span class="line"><span class="comment">//章节base1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= chaps; i++ &#123;</span><br><span class="line">chapNm := <span class="string">&quot;&quot;</span></span><br><span class="line">chromedp.Run(ctx, chromedp.TextContent(contentNode[chaps-i].PartialXPath(), &amp;chapNm))</span><br><span class="line">chapNm = standarlizeName(chapNm)</span><br><span class="line">fmt.Printf(<span class="string">&quot;[%d] %s \n&quot;</span>, i, chapNm)</span><br><span class="line">NmList[index][i] = NmList[index][<span class="number">0</span>] + <span class="string">&quot;/[&quot;</span> + fmt.Sprintf(<span class="string">&quot;%02d&quot;</span>, i) + <span class="string">&quot;] &quot;</span> + chapNm <span class="comment">//章节数补全2位,加上章节名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !pathExists(NmList[index][i]) &#123; <span class="comment">//建好文件夹</span></span><br><span class="line">err = os.MkdirAll(NmList[index][i], <span class="number">0766</span>)</span><br><span class="line">Check(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">bar := progressbar.New(chaps) <span class="comment">//显示一个进度条，用来展示每本书的进度</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= chaps; i++ &#123;</span><br><span class="line">LoadChap(index, i, bar)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadChap</span><span class="params">(bookNum <span class="type">int</span>, chapNum <span class="type">int</span>, bar *progressbar.ProgressBar)</span></span> &#123;</span><br><span class="line"><span class="comment">//分为两步，下拉</span></span><br><span class="line">Load(pageUrl2 + idList[bookNum] + <span class="string">&quot;&amp;chapter=&quot;</span> + strconv.Itoa(chapNum))</span><br><span class="line">ScrollDown()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> picNodes []*cdp.Node</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Nodes(<span class="string">`//div[@class=&#x27;chapter-images wide-block pt-2 pb-2 my-bg-white&#x27;]/img`</span>, &amp;picNodes))</span><br><span class="line">Check(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// println(&quot;total Picnum = &quot;, len(picNodes))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(picNodes); i++ &#123;</span><br><span class="line">picture := &amp;pic&#123;bookNum, chapNum, i, picNodes[i].AttributeValue(<span class="string">&quot;data-src&quot;</span>)&#125;</span><br><span class="line">picChan &lt;- picture</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.Add(<span class="number">1</span>) <span class="comment">//标记这章节已经完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ScrollDown</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> prgsBar <span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; &#123;</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Evaluate(<span class="string">&quot;window.scrollBy(0,document.body.scrollHeight)&quot;</span>, <span class="literal">nil</span>),</span><br><span class="line">chromedp.Sleep(<span class="number">2</span>*time.Second),</span><br><span class="line">chromedp.TextContent(<span class="string">`.//div[@class=&quot;w-100 text-center text-black-50 my-read-tip&quot;]`</span>, &amp;prgsBar))</span><br><span class="line">Check(err)</span><br><span class="line"><span class="keyword">if</span> prgsBar == <span class="string">&quot;100 % （點擊可跳轉）&quot;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Login</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Navigate(homeUrl),</span><br><span class="line">chromedp.WaitVisible(<span class="string">&quot;#email1&quot;</span>, chromedp.ByID),</span><br><span class="line">chromedp.SendKeys(<span class="string">&quot;#email1&quot;</span>, account+kb.Tab+password, chromedp.ByID),</span><br><span class="line">chromedp.Click(<span class="string">`.//button[@type=&quot;submit&quot;]`</span>, chromedp.BySearch),</span><br><span class="line">chromedp.WaitVisible(<span class="string">`//div[@class=&#x27;appBottomMenu&#x27;]`</span>))</span><br><span class="line">Check(err)</span><br><span class="line">fmt.Println(<span class="string">&quot;login complete&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;\n...you&#x27;ve 15 second to change the picture quality...&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">100</span>)</span><br><span class="line">Load(pageUrl2 + idList[<span class="number">0</span>] + <span class="string">&quot;&amp;chapter=1&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;processing start&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathExists</span><span class="params">(path <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">_, err := os.Stat(path)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//chromedp初始化</span></span><br><span class="line">headlessFlag := chromedp.Flag(<span class="string">&quot;headless&quot;</span>, <span class="literal">false</span>) <span class="comment">//有头模式</span></span><br><span class="line">opts := <span class="built_in">append</span>(</span><br><span class="line">chromedp.DefaultExecAllocatorOptions[:],</span><br><span class="line">chromedp.NoDefaultBrowserCheck,                               <span class="comment">//不检查默认浏览器</span></span><br><span class="line">headlessFlag,                                                 <span class="comment">//无头</span></span><br><span class="line">chromedp.IgnoreCertErrors,                                    <span class="comment">//忽略错误</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;blink-settings&quot;</span>, <span class="string">&quot;imagesEnabled=false&quot;</span>),       <span class="comment">//不加载gif图像 因为有可能会卡住</span></span><br><span class="line">chromedp.DisableGPU,                                          <span class="comment">//关闭GPU渲染</span></span><br><span class="line">chromedp.NoSandbox,                                           <span class="comment">//不适用谷歌的sanbox模式运行</span></span><br><span class="line">chromedp.NoFirstRun,                                          <span class="comment">//设置网站不是首次运行</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;disable-web-security&quot;</span>, <span class="literal">true</span>),                  <span class="comment">//禁用网络安全标志</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;disable-extensions&quot;</span>, <span class="literal">true</span>),                    <span class="comment">//关闭插件支持</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;disable-default-apps&quot;</span>, <span class="literal">true</span>),                  <span class="comment">//关闭默认浏览器检查</span></span><br><span class="line">chromedp.WindowSize(<span class="number">1280</span>, <span class="number">1024</span>),                              <span class="comment">//初始大小</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;run-all-compositor-stages-before-draw&quot;</span>, <span class="literal">true</span>), <span class="comment">//在呈现所有数据之前防止创建Pdf</span></span><br><span class="line">chromedp.UserAgent(<span class="string">`Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36`</span>), <span class="comment">//设置UserAgent</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">allocCtx, _ := chromedp.NewExecAllocator(context.Background(), opts...)</span><br><span class="line">ctx, _ = chromedp.NewContext(</span><br><span class="line">allocCtx,</span><br><span class="line">chromedp.WithLogf(log.Printf),</span><br><span class="line">)</span><br><span class="line">chromedp.Run(ctx, <span class="built_in">make</span>([]chromedp.Action, <span class="number">0</span>, <span class="number">1</span>)...) <span class="comment">//打开，但是什么都不干</span></span><br><span class="line">fmt.Println(<span class="string">&quot;-- chromedp start success --&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//customsettings初始化</span></span><br><span class="line"><span class="keyword">type</span> custom <span class="keyword">struct</span> &#123;</span><br><span class="line">Account  <span class="type">string</span>   <span class="string">`json:&quot;Account&quot;`</span></span><br><span class="line">Password <span class="type">string</span>   <span class="string">`json:&quot;Password&quot;`</span></span><br><span class="line">IDList   []<span class="type">string</span> <span class="string">`json:&quot;IDList&quot;`</span> <span class="comment">//漫画列表</span></span><br><span class="line">SavePath <span class="type">string</span>   <span class="string">`json:&quot;SavePath&quot;`</span></span><br><span class="line">PROXY    <span class="type">string</span>   <span class="string">`json:&quot;PROXY&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, projectPath, _, _ := runtime.Caller(<span class="number">0</span>)</span><br><span class="line">filePath := path.Dir(projectPath) + <span class="string">&quot;/custom.json&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;fetch customInfo from&quot;</span>, filePath)</span><br><span class="line"></span><br><span class="line">jsonFile, err := os.Open(filePath)</span><br><span class="line">Check(err)</span><br><span class="line"><span class="keyword">defer</span> jsonFile.Close()</span><br><span class="line"></span><br><span class="line">jsonData, err := ioutil.ReadAll(jsonFile)</span><br><span class="line">Check(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> customInfo custom</span><br><span class="line">json.Unmarshal(jsonData, &amp;customInfo)</span><br><span class="line">account, password, idList, savePath, PROXY = customInfo.Account, customInfo.Password, customInfo.IDList, customInfo.SavePath, customInfo.PROXY</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> PROXY == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">PROXY = <span class="string">&quot;http://127.0.0.1:1080/&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;-- custom.json loadng success --&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Welcome!&quot;</span>, account)</span><br><span class="line">fmt.Println(<span class="string">&quot;your savePath:&quot;</span>, savePath)</span><br><span class="line">fmt.Println(<span class="string">&quot;your cidList:&quot;</span>, idList)</span><br><span class="line">fmt.Println(<span class="string">&quot;your proxy:&quot;</span>, idList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Check</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details><details class="tag-plugin folding" child="codeblock"><summary><span>./custom.json</span></summary><div class="body"><ul><li>放在.exe或者.go的同目录下</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;Account&quot;</span><span class="punctuation">:</span> <span class="string">&quot;账号，空置则手动填写（不着急，检定登陆成功才会开始下一步）&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;Password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;密码，空置则手动填写，建议不要空置&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;IdList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;63944d19d6ffb644413e139f漫画的cid列表，用逗号分割&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;SavePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;G:/Comic/2023.02，文件目录&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;PROXY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://127.0.0.1:1080/默认端口，空置也行&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;web-golang&quot;&gt;&lt;a href=&quot;#web-golang&quot; class=&quot;headerlink&quot; title=&quot;web #golang&quot;&gt;&lt;/a&gt;web #golang&lt;/h1&gt;&lt;p&gt;第二次的Golang代码！纪念一下~~&lt;br&gt;也是第二次的picaCom</summary>
      
    
    
    
    <category term="Codes" scheme="https://floatdesu.github.io/categories/Codes/"/>
    
    
    <category term="web" scheme="https://floatdesu.github.io/tags/web/"/>
    
    <category term="golang" scheme="https://floatdesu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Python爬取picaComic</title>
    <link href="https://floatdesu.github.io/Codes/482da7d4.html"/>
    <id>https://floatdesu.github.io/Codes/482da7d4.html</id>
    <published>2023-01-30T17:58:03.000Z</published>
    <updated>2023-01-31T09:16:48.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="net-python"><a href="#net-python" class="headerlink" title="net #python"></a>net #python</h1><p>第一次的python-selenium爬虫，动态网页确实复杂很多啊（……）<br>现在回头看觉得到处是瑕疵了hhh<br>做一个纪念吧。</p><details class="tag-plugin folding" child="codeblock"><summary><span>Source Code ( using python-selenium )</span></summary><div class="body"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os <span class="comment">#文件管理</span></span><br><span class="line"><span class="comment"># import imghdr  #图像查损</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment"># import urllib</span></span><br><span class="line"><span class="keyword">import</span> imghdr</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------爬虫初始化----------</span></span><br><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">user_agent = <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15&quot;</span></span><br><span class="line"><span class="comment"># 增加用户代理</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--user-agent=%s&#x27;</span> % user_agent)</span><br><span class="line"><span class="comment"># 忽略证书错误</span></span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--ignore-ssl-errors&#x27;</span>) </span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;--ignore-certificate-errors-spki-list&#x27;</span>)</span><br><span class="line"><span class="comment"># 忽略 Bluetooth: bluetooth_adapter_winrt.cc:1075 Getting Default Adapter failed. 错误</span></span><br><span class="line">chrome_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 忽略 DevTools listening on ws://127.0.0.1... 提示</span></span><br><span class="line">chrome_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-logging&#x27;</span>])</span><br><span class="line">chrome_options.add_argument(<span class="string">&#x27;blink-settings=imagesEnabled=false&#x27;</span>) </span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=chrome_options)  <span class="comment">#模拟器启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># opener = urllib.request.build_opener() #防反爬</span></span><br><span class="line"><span class="comment"># opener.addheaders = [(&#x27;User-Agent&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1941.0 Safari/537.36&#x27;)]</span></span><br><span class="line"><span class="comment"># urllib.request.install_opener(opener)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先加载完所有链接再下载，最稳定的版本</span></span><br><span class="line">idlist=[<span class="string">&quot;63c00254380963328e1d487c&quot;</span>]</span><br><span class="line"><span class="comment">#漫画地址list&quot;63c00254380963328e1d487c&quot;,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkFileName</span>(<span class="params">txt</span>):</span><br><span class="line">  dictionary = &#123;<span class="string">&quot; &quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;|&quot;</span>:<span class="string">&quot; &quot;</span>,<span class="string">&quot;/&quot;</span>:<span class="string">&quot; &quot;</span>,<span class="string">&quot;&lt;&quot;</span>:<span class="string">&quot;[&quot;</span>,<span class="string">&quot;&gt;&quot;</span>:<span class="string">&quot;]&quot;</span>,<span class="string">&quot;:&quot;</span>:<span class="string">&quot;_&quot;</span>,<span class="string">&quot;\&quot;&quot;</span>:<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&quot;+&quot;</span>:<span class="string">&quot;_&quot;</span>&#125;</span><br><span class="line">  transTable = txt.maketrans(dictionary)</span><br><span class="line">  txt = txt.translate(transTable)</span><br><span class="line">  <span class="keyword">return</span> txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pulldown</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Pulling Down The Page---&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>) <span class="comment">#进入一个新的网页，先稍等加载一会</span></span><br><span class="line"></span><br><span class="line">    cnt=<span class="number">0</span></span><br><span class="line">    check_height = driver.execute_script(<span class="string">&quot;return document.body.scrollHeight;&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        driver.execute_script(<span class="string">&quot;window.scrollBy(0,1200)&quot;</span>)  <span class="comment">#太快容易中断</span></span><br><span class="line">        time.sleep(<span class="number">1.2</span>)</span><br><span class="line">        check_height1 = driver.execute_script(<span class="string">&quot;return document.body.scrollHeight;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> check_height == check_height1:</span><br><span class="line">            cnt+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(cnt)</span><br><span class="line">            <span class="keyword">if</span> cnt&gt;=<span class="number">25</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;---Back To The Main---&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            check_height = check_height1</span><br><span class="line">            <span class="keyword">if</span> cnt&lt;<span class="number">20</span>:</span><br><span class="line">                cnt=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isCompleted</span>(<span class="params">img</span>): <span class="comment">#图像完整性检查（因为urlretrieve稳定性很好，所以不开也没关系</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(img):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> imghdr.what(img):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;image not completely downloaded, i\&#x27;m trying again now.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imgOutput</span>(<span class="params">imgUrl, i, savePath</span>):</span><br><span class="line">    filename=savePath+<span class="string">f&#x27;\\<span class="subst">&#123;i:<span class="number">0</span>&gt;<span class="number">4</span>&#125;</span>.jpg&#x27;</span></span><br><span class="line">    r = requests.get(imgUrl)</span><br><span class="line">    <span class="comment">##打开文件并写入</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="comment"># urllib.request.urlretrieve(url=imgUrl, filename=savePath+f&#x27;\\&#123;i:0&gt;4&#125;.jpg&#x27;)</span></span><br><span class="line">    <span class="comment"># if isCompleted(savePath+f&#x27;\\&#123;i:0&gt;4&#125;.jpg&#x27;):</span></span><br><span class="line">    <span class="comment">#     return 1 # 检查图片完整性（如果用这一段，下面改0）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getImgs</span>(<span class="params">url, savePath</span>):</span><br><span class="line"></span><br><span class="line">    driver.get(url)</span><br><span class="line">    pulldown()  <span class="comment">#下拉，刷新所有链接</span></span><br><span class="line"></span><br><span class="line">    imgs = driver.find_elements(</span><br><span class="line">        by=By.XPATH, value=<span class="string">&quot;//div[@class=&#x27;chapter-images wide-block pt-2 pb-2 my-bg-white&#x27;]/img&quot;</span>)</span><br><span class="line">    <span class="comment">#在下拉过程中，元素的src属性会刷新</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> imgs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no more pages&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(savePath):</span><br><span class="line">        os.makedirs(savePath)</span><br><span class="line"></span><br><span class="line">    jpgn = <span class="number">0</span></span><br><span class="line">    start=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> imgs:</span><br><span class="line">        <span class="comment"># if isCompleted(savePath+f&#x27;\\&#123;jpgn:0&gt;4&#125;.jpg&#x27;): #断点续传</span></span><br><span class="line">        <span class="comment">#    jpgn+=1</span></span><br><span class="line">        <span class="comment">#    print(f&quot;---&#123;jpgn&#125;.jpg has existed in *&#123;savePath[-6:]&#125;*---&quot;)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">            imgUrl = <span class="built_in">str</span>(i.get_attribute(<span class="string">&quot;src&quot;</span>))</span><br><span class="line">            <span class="keyword">if</span> imgUrl.find(<span class="string">&quot;.gif&quot;</span>) == -<span class="number">1</span>:  <span class="comment">#不下载gif</span></span><br><span class="line">                time.sleep(<span class="number">1.5</span>)</span><br><span class="line">                cnt=<span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> cnt&lt;=<span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">if</span> imgOutput(imgUrl, jpgn, savePath):</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    imgUrl = <span class="built_in">str</span>(i.get_attribute(<span class="string">&quot;src&quot;</span>))</span><br><span class="line">                    time.sleep(<span class="number">1</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Something Wrong Here. Cnt=<span class="subst">&#123;cnt&#125;</span>&quot;</span>)</span><br><span class="line">                    cnt+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (cnt&gt;<span class="number">5</span>):</span><br><span class="line">                    <span class="built_in">print</span>(imgUrl)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;Sorry, I can&#x27;t deal with this error, please check this url later&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> cnt&gt;<span class="number">0</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;Luckily, it has been successfully processed now. &quot;</span>)</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;---<span class="subst">&#123;jpgn:<span class="number">0</span>&gt;<span class="number">4</span>&#125;</span>.jpg has been downloaded in /<span class="subst">&#123;savePath[-<span class="number">6</span>:]&#125;</span>---&quot;</span>)</span><br><span class="line"></span><br><span class="line">                jpgn += <span class="number">1</span></span><br><span class="line">    end=time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;||This Chapt Consumed <span class="subst">&#123;end-start&#125;</span> seconds.||&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> jpgn == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&#x27;https://manhuabika.com/plogin/&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)  <span class="comment"># 登录</span></span><br><span class="line"></span><br><span class="line">driver.get(</span><br><span class="line">    <span class="string">&quot;https://manhuabika.com/pchapter/?cid=5fde2af559b287406e2151b8&amp;chapter=1&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">10</span>)  <span class="comment"># 修改清晰度</span></span><br><span class="line"></span><br><span class="line">bcnt=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> cid <span class="keyword">in</span> idlist:</span><br><span class="line"></span><br><span class="line">    start=time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------每本书的初始化---------</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n\n|||||||Reading Book <span class="subst">&#123;bcnt&#125;</span>||||||&quot;</span>)</span><br><span class="line">    url = <span class="string">f&quot;https://manhuabika.com/pchapter/?cid=<span class="subst">&#123;cid&#125;</span>&amp;chapter=&quot;</span></span><br><span class="line">    chapN = <span class="number">3</span> <span class="comment">#起始章</span></span><br><span class="line">    urlC = url+<span class="built_in">str</span>(chapN)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------获取书名----------</span></span><br><span class="line">    driver.get(<span class="string">f&quot;https://manhuabika.com/pcomicview/?cid=<span class="subst">&#123;cid&#125;</span>&quot;</span>) </span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    urlTitle=driver.find_element(by=By.XPATH, value=<span class="string">&quot;//div[@class=&#x27;comic-title text-start&#x27;]&quot;</span>).text</span><br><span class="line">    urlTitle=checkFileName(urlTitle)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;Loading Book <span class="subst">&#123;bcnt&#125;</span>:[<span class="subst">&#123;cid&#125;</span>] <span class="subst">&#123;urlTitle&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    savePath = <span class="string">&quot;G:\\Comic\\Spider\\&quot;</span>+urlTitle+<span class="string">&quot;\\&quot;</span> <span class="comment">#书名作为文件夹名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#---------分章节爬取图像----------</span></span><br><span class="line">    <span class="keyword">while</span> getImgs(urlC, savePath+<span class="string">f&#x27;Chap<span class="subst">&#123;chapN:<span class="number">0</span>&gt;<span class="number">2</span>&#125;</span>&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Chap<span class="subst">&#123;chapN&#125;</span> is Finished&quot;</span>)</span><br><span class="line">        chapN += <span class="number">1</span></span><br><span class="line">        urlC = url+<span class="built_in">str</span>(chapN)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#---------每本书的结尾----------</span></span><br><span class="line">    end=time.time()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;This Book Consumed <span class="subst">&#123;end-start&#125;</span> seconds.&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;||||||Book <span class="subst">&#123;bcnt&#125;</span>:[<span class="subst">&#123;cid&#125;</span>] <span class="subst">&#123;urlTitle&#125;</span> have been downloaded. ||||||&quot;</span>)</span><br><span class="line"></span><br><span class="line">    bcnt+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n\nおめでとうございます! All Books Have Been Processed Successfully.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></details>]]></content>
    
    
    <summary type="html">以前做的python爬取动态网页（漫画）的试水，新写的go程序比这个好得多得多，仅作纪念了。</summary>
    
    
    
    <category term="Codes" scheme="https://floatdesu.github.io/categories/Codes/"/>
    
    
    <category term="web" scheme="https://floatdesu.github.io/tags/web/"/>
    
    <category term="python" scheme="https://floatdesu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>互联网基础</title>
    <link href="https://floatdesu.github.io/Engineer/24012d32.html"/>
    <id>https://floatdesu.github.io/Engineer/24012d32.html</id>
    <published>2023-01-28T15:01:44.000Z</published>
    <updated>2023-02-15T15:02:56.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h1><p>课程笔记：BV1qy4y177LM</p><h1 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h1><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>包（packet）传输 &amp; 丢包<br>    queuing &amp; loss: drop packets when memory(buffer) is full</p><p>ISP(Internet Service Provider)<br>不同的接入网(access net)连入ISP，通过IXP进行信息交换</p><p>4 Sources of Packet Delay<br><img src="../../../assets/Pasted%20image%2020230125202040.png" alt=""></p><p>总延时=处理时间(很短)+排队时间+发送时间(数据量L/网速R)+传播时间(路径长D/传播时间S)</p><p>Protocols 协议：“语言”<br>    TCP<br>    IP<br>    HTTP<br>    802.11</p><p>不同的协议涉及不同的分层结构。<br>TCP/IP model</p><ul><li><p>Application 应用层 Layer 7<br>  FTP（文件传输协议） SMTP（邮件） HTTP<br>  为应用提供网络服务</p></li><li><p>Transport 传输层 Layer 4<br>  TCP UDP<br>  世界级的数据传输<br>  ==数据包Package==</p></li><li><p>Network  网络层 Layer 3<br>  IP<br>  关心数据的分发<br>  ==数据报Datagram==<br>  —路由器</p></li><li><p>Link  数据链路层 Layer 2<br>  相邻网络元素间的数据传输（Wifi,PPP, Ethernet)<br>  ==数据帧Frame==<br>  —交换机</p></li><li><p>Physical 物理层 Layer 1<br>  bits “on the file”<br>  网线设计和接口</p></li></ul><p>ISO/OSI model<br>在应用层和传输层之间增加presentation (进行数据压缩) 和 session（数据检查和修复）</p><p>Layer &amp; Header<br>    TCO/IP model中，许多层与特定的header（有时header &amp; trailer）相关<br>    用来解释数据内容、发送路径等<br>    （每向下经过一层，header都会累加）</p><p>Address<br>    appli：Application-specific address<br>        如电子邮件地址<br>    transport: Port address 端口<br>        每一个使用网卡的程序的编号，differentiate differnet processes<br>    network: Logical address (IP地址)<br>        32-bit IPV4 / 128-bit IPV6<br>    link：Physical address（mac地址）<br>        node address (defined by LAN/WAN)</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>Multiplexing/Demultipliexing<br>    Mux, Demux<br>    combine several data streams / seperate and handle</p><p>UDP (User Datagram Protocol)<br>    unreliable, unordered delivery<br>        no-frills extension of “best-effort” IP<br>    services not available:<br>        delay guarantee<br>        bandwidth guarantees<br>    无需建立连接，small header，非常快<br>    （含有校验checksum，但无法纠正错误）</p><p>UDP封装示意图<br><img src="../../../assets/Pasted%20image%2020230125210354.png" alt=""></p><p>Principles of reliable data transfer<br><img src="../../../assets/Pasted%20image%2020230125210652.png" alt=""></p><p>FSM(Finite state machine) 有限状态自动机<br>    一种非常可靠的传输机制（类似投币进闸）<br>    2.0 错误检查机制-》<br>        ACK（acknowledge）没有出现错误 &amp; NAK（Negative…）收到的数据错误<br>        收到数据正确-》通过<br>        收到数据错误-》请求再次发送-》再次检查…<br>        （如果返回的ACK/NAK出错？对数据包进行N循环编号，check和data中均包含编号，则双方可以均可以准确判断具体哪一个数据包或check信息出现问题并进行重发）<br>    -》3.0 加入计时器，建立防丢机制（一旦check信息time out，也进行重发）<br>        （但是性能很差）<br>-》通过Pipeline 可以提高利用率（一次发送多包数据，提高利用率）<br>    GBN（Go back n）：从第一个NAK/TimeOut包开始全部重发（对于N=20，如果N=2丢包，则从N=2开始再进行多包发送），<br>    SR（Selective Repeat）：对包的ACK情况进行标记，发送问题包直至收到ACK信息<br>        可能需要重新排序<br>        如果循环编号的N相对于Window太小，编号可能出现重复使用</p><p>TCP<br>    reliable, in-order deliery<br>        congestion control<br>        flow control (sender will not overwhelm receiver)<br>        connection setup （connectio-oriented <em>handshaking</em>, point-to-point)<br>        full duplex data 边发边收<br>        pipeline<br>    TCP fast retransmit:</p><pre><code>    &gt;=3 ACKs直接重发，减少等待时间</code></pre><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><blockquote><p>Socket是BSD UNIX的进程通信机制，通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。<br>Socket可以理解为TCP/IP网络的API，它定义了许多函数或例程，程序员可以用它们来开发TCP/IP网络上的应用程序。电脑上运行的应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p></blockquote><p>介于应用层和传输层之间<br>对应用层的抽象</p><ul><li>常用的Socket类型有两种：流式Socket和数据报式Socket，流式是一种面向连接的Socket，针对于面向连接的TCP服务应用，数据报式Socket是一种无连接的Socket，针对于无连接的UDP服务应用</li><li>TCP：比较靠谱，面向连接，比较慢</li><li>UDP：不是太靠谱，比较快<br>（举个例子：TCP就像货到付款的快递，送到家还必须见到你人才算一整套流程。UDP就像某快递快递柜一扔就走管你收到收不到，一般直播用UDP。）</li></ul><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><a href="https://www.topgoer.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B/TCP%E7%BC%96%E7%A8%8B.html">TCP</a></h3><p>TCP服务端程序的处理流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.监听端口</span><br><span class="line">2.接收客户端请求建立链接</span><br><span class="line">3.创建goroutine处理链接。</span><br></pre></td></tr></table></figure><p>TCP客户端进行TCP通信的流程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.建立与服务端的链接</span><br><span class="line">2.进行数据收发</span><br><span class="line">3.关闭链接</span><br></pre></td></tr></table></figure><p><em>粘包处理</em><br>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。<br>解决方法：自定义协议，如在数据包前加上数据长度开头</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a><a href="https://www.topgoer.com/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/socket%E7%BC%96%E7%A8%8B/UDP%E7%BC%96%E7%A8%8B.html">UDP</a></h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li>通常承载于TCP协议之上</li><li>Web服务器的工作原理可以简单地归纳为<ul><li>客户机通过TCP/IP协议建立到服务器的TCP连接</li><li>客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档</li><li>服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端</li><li>客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果</li></ul></li></ul><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><ul><li>WebSocket是一种在单个TCP连接上进行全双工通信的协议</li><li>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据</li><li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输</li><li>需要安装第三方包：<ul><li>cmd中：go get -u -v github.com/gorilla/websocket</li></ul></li></ul>]]></content>
    
    
    <summary type="html">很基础，随便看看</summary>
    
    
    
    <category term="Engineer" scheme="https://floatdesu.github.io/categories/Engineer/"/>
    
    
    <category term="Internet" scheme="https://floatdesu.github.io/tags/Internet/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件操作</title>
    <link href="https://floatdesu.github.io/Engineer/8a4e650f.html"/>
    <id>https://floatdesu.github.io/Engineer/8a4e650f.html</id>
    <published>2023-01-28T13:01:51.000Z</published>
    <updated>2023-03-11T19:05:54.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol><li><code>ls</code> 打印当前目录下的文件名</li><li><code>cd &#123;dir&#125;</code> 打开文件夹</li><li><code>cd ..</code> 退回上级目录</li><li><code>cd  /</code>（退回最高级目录）</li><li><code>mkdir &#123;dir&#125;</code>创建文件夹</li><li><code>rm &#123;name&#125;</code> 删除文件</li></ol><h3 id="打印文件内容"><a href="#打印文件内容" class="headerlink" title="打印文件内容"></a>打印文件内容</h3><p><code>cat &#123;name&#125;</code></p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><code>vi &#123;name&#125;</code></p><h4 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h4><ol><li><p><code>/ &#123;keyword&#125;</code>，查找</p></li><li><p>通过命令进入文本输入模式，常用的命令如下：</p></li></ol><blockquote><p>① a 在光标之后开始输入文本<br>② A 在行尾开始输入文本<br>③ i 在光标之前开始输入文本<br>④ I 在行首第一个非空白字符前输入文本<br>⑤ o 在光标所在行后插入一空行<br>⑥ O 在光标所在行前插入一空行</p></blockquote><h4 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h4><p>修改好文件后，如果在文本输入模式下，首先按“ESC” 键进入命令模式，然后输入“:”，进入末行模式，在末行模式下，可使用如下退出命令：</p><blockquote><p>① q 是直接退出；<br>② wq 保存后退出；<br>③ q! 强制退出；<br>④ wq! 强制保存退出；</p></blockquote><h3 id="复制-移动-修改文件名"><a href="#复制-移动-修改文件名" class="headerlink" title="复制/移动/修改文件名"></a>复制/移动/修改文件名</h3><p><code>cp &#123;Source&#125; &#123;Dst&#125;</code></p><p><code>mv &#123;Source&#125; &#123;Dst&#125;</code></p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>tar -xvf &#123;filename&#125;</code></p>]]></content>
    
    
    <summary type="html">linux命令行</summary>
    
    
    
    <category term="Engineer" scheme="https://floatdesu.github.io/categories/Engineer/"/>
    
    
    <category term="Centos" scheme="https://floatdesu.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>群晖docker部署Yunzai-Bot V3（原神qq机器人）</title>
    <link href="https://floatdesu.github.io/Engineer/19b0016d.html"/>
    <id>https://floatdesu.github.io/Engineer/19b0016d.html</id>
    <published>2023-01-27T18:09:00.000Z</published>
    <updated>2023-01-27T19:54:41.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker-linux"><a href="#docker-linux" class="headerlink" title="docker #linux"></a>docker #linux</h1><hr><p>大篇幅参考：</p><p><a href="https://www.bilibili.com/read/cv16393194">zh8416-Yunzai-Bot在群晖NAS中的搭建教程</a></p><p><a href="[https://github.com/Le-niao/Yunzai-Bot/issues/80](https://docs.yunzai.org/deploy/linux/Docker.html">Docker 部署</a>)</p><hr><p>本以为配置完go环境的我已经无坚不摧了，却还是（……）踩了很多坑（悲），终于搭好了，简单记录一下过程。（草，抄错链接了以为不能用，其实可能可以一键部署，我全是手动部署的，问题不大……）</p><h2 id="1-创建容器"><a href="#1-创建容器" class="headerlink" title="1. 创建容器"></a>1. 创建容器</h2><ul><li>在套件中心下载docker插件，并在注册表中查找centos双击下载，版本选择8.2.2004  <del>（好像可以选更新的，Centos8会导致接下来多一步操作，但是我是抄作业的，所以照抄了）</del></li></ul><p><del>虽然说可以创建两个容器分别是redis和yunzai而不是把两个程序都部署在centos上，但是这样后面管理插件之类的会很痛苦的，还是别这么干了，而且容器之间还得开端口通信……（头皮发麻）</del></p><ul><li>下载完成后，在映像中找到centos右键启动，勾选高权限执行容器</li></ul><p><strong>【！！重要！！】</strong><br>如果需要使用锅巴插件（可访问可视化后台管理页面），需要开启端口映射！！！创建时不开端口映射后面想加会很麻烦！！！<br>锅巴插件默认端口号（容器端口号）50831，映射界面可填写50831-50831-UDP，50831-50831-TCP，这样，把访问群晖的网址后的端口号5000改成50831即可访问锅巴后台。</p><ul><li>双击centos容器，进入终端机（命令行），开始配置环境</li></ul><h2 id="2-配置云崽本体"><a href="#2-配置云崽本体" class="headerlink" title="2. 配置云崽本体"></a>2. 配置云崽本体</h2><h3 id="1-配置Yum环境"><a href="#1-配置Yum环境" class="headerlink" title="1. 配置Yum环境"></a>1. 配置Yum环境</h3><p>版本号高于8的可以跳过这一步</p><h4 id="进入yum目录"><a href="#进入yum目录" class="headerlink" title="进入yum目录"></a>进入yum目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d/</span><br></pre></td></tr></table></figure><h4 id="更换下载源"><a href="#更换下载源" class="headerlink" title="更换下载源"></a>更换下载源</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/mirrorlist/#mirrorlist/g&#x27; /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27; /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><h4 id="更新设置（这一步要等一会）"><a href="#更新设置（这一步要等一会）" class="headerlink" title="更新设置（这一步要等一会）"></a>更新设置（这一步要等一会）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure><h4 id="回到根目录"><a href="#回到根目录" class="headerlink" title="回到根目录"></a>回到根目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /</span><br></pre></td></tr></table></figure><h3 id="2-配置云崽依赖和本体"><a href="#2-配置云崽依赖和本体" class="headerlink" title="2. 配置云崽依赖和本体"></a>2. 配置云崽依赖和本体</h3><h4 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h4><p>可以先试一下这个：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -sSL http://yunzai.org/install_v3)</span><br></pre></td></tr></table></figure></p><h4 id="手动部署"><a href="#手动部署" class="headerlink" title="手动部署"></a>手动部署</h4><p>如果能用的话以下都可以跳过，如果不能用的话就手动部署。</p><h5 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h5><p>（如果报错的话可以再输一次更新下载源的两条命令试试）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y dnf</span><br><span class="line">dnf module install nodejs:16 -y</span><br></pre></td></tr></table></figure></p><p>安装 git<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure></p><p>安装并运行 redis<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install redis &amp;&amp; redis-server --daemonize yes</span><br></pre></td></tr></table></figure></p><p>克隆项目（国内镜像链接）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 -b main https://gitee.com/Le-niao/Yunzai-Bot.git</span><br></pre></td></tr></table></figure></p><p>安装模块<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd Yunzai-Bot</span><br></pre></td></tr></table></figure></p><p>安装 pnpm<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install pnpm -g</span><br></pre></td></tr></table></figure></p><p>安装依赖<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pnpm install -P</span><br></pre></td></tr></table></figure></p><p>安装 chrome 依赖库<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install pango.x86_64 libXcomposite.x86_64 libXcursor.x86_64 libXdamage.x86_64 libXext.x86_64 libXi.x86_64 libXtst.x86_64 cups-libs.x86_64 libXScrnSaver.x86_64 libXrandr.x86_64 GConf2.x86_64 alsa-lib.x86_64 atk.x86_64 gtk3.x86_64 -y &amp;&amp; yum install libdrm libgbm libxshmfence -y &amp;&amp; yum install nss -y &amp;&amp; yum update nss -y</span><br></pre></td></tr></table></figure></p><p>安装中文字体<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum groupinstall fonts -y</span><br></pre></td></tr></table></figure></p><h2 id="3-云崽使用和插件安装"><a href="#3-云崽使用和插件安装" class="headerlink" title="3. 云崽使用和插件安装"></a>3. 云崽使用和插件安装</h2><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>前台运行指令（第一次需要登录）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node app</span><br></pre></td></tr></table></figure></p><p>后台运行/停止指令（如果在/Yunzai-Bot目录下）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm start</span><br><span class="line">npm stop</span><br></pre></td></tr></table></figure></p><p>重启服务器/docker/容器时，（容器在根目录），后台运行指令：<br>（重启时需要重新打开redis服务）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server --save 900 1 --save 300 10 --daemonize yes</span><br><span class="line">npm -prefix=/Yunzai-Bot start</span><br></pre></td></tr></table></figure></p><p>以上指令可匹配开机计划任务自定义脚本：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep 300;sudo docker exec [container id] redis-server --save 900 1 --save 300 10 --daemonize yes;sudo docker exec [container id] npm -prefix=/Yunzai-Bot start</span><br></pre></td></tr></table></figure></p><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><p><a href="https://gitee.com/yhArcadia/Yunzai-Bot-plugins-index">https://gitee.com/yhArcadia/Yunzai-Bot-plugins-index</a></p><h4 id="喵喵插件"><a href="#喵喵插件" class="headerlink" title="喵喵插件"></a><a href="https://gitee.com/yoimiya-kokomi/miao-plugin">喵喵插件</a></h4><p>重要，涉及很多好用的附加功能，建议安装</p><ul><li><p>喵喵插件安装命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 -b master https://gitee.com/yoimiya-kokomi/miao-plugin.git ./plugins/miao-plugin/</span><br></pre></td></tr></table></figure></li><li><p>喵喵依赖安装命令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pnpm add image-size -w</span><br></pre></td></tr></table></figure></li><li><p>帮助菜单命令： <code>#喵喵菜单</code></p></li><li><p>插件设置命令： <code>#喵喵设置</code></p></li><li><p>推荐执行： <code>#喵喵更新图像</code> 以及 <code>#喵喵设置帮助 开启</code></p></li></ul><h4 id="锅巴插件"><a href="#锅巴插件" class="headerlink" title="锅巴插件"></a><a href="https://gitee.com/guoba-yunzai/guoba-plugin">锅巴插件</a></h4><p>很重要！涉及可视化的后台管理界面，强烈建议安装</p><ul><li><p>锅巴插件安装命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://gitee.com/guoba-yunzai/guoba-plugin.git ./plugins/Guoba-Plugin/</span><br></pre></td></tr></table></figure></li><li><p>锅巴依赖安装命令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pnpm install --no-lockfile --filter=guoba-plugin -w</span><br></pre></td></tr></table></figure></li><li><p>外网登录的话需要在服务器后台放行端口，具体看 <code>#锅巴帮助</code></p></li><li><p>帮助菜单命令： <code>#锅巴帮助</code></p></li></ul><h4 id="逍遥插件-图鉴插件"><a href="#逍遥插件-图鉴插件" class="headerlink" title="逍遥插件(图鉴插件)"></a><a href="https://gitee.com/Ctrlcvs/xiaoyao-cvs-plugin">逍遥插件(图鉴插件)</a></h4><p>涉及图鉴，选装</p><ul><li><p>逍遥插件安装命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://gitee.com/Ctrlcvs/xiaoyao-cvs-plugin.git ./plugins/xiaoyao-cvs-plugin/</span><br></pre></td></tr></table></figure></li><li><p>逍遥依赖安装命令： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pnpm add promise-retry -w</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pnpm add superagent -w</span><br></pre></td></tr></table></figure><ul><li><p>安装完需要先 <code>#图鉴更新</code> 一次</p></li><li><p>帮助菜单命令： <code>#图鉴菜单</code></p></li><li><p>插件设置命令： <code>#图鉴设置</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;docker-linux&quot;&gt;&lt;a href=&quot;#docker-linux&quot; class=&quot;headerlink&quot; title=&quot;docker #linux&quot;&gt;&lt;/a&gt;docker #linux&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;大篇幅参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Engineer" scheme="https://floatdesu.github.io/categories/Engineer/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang爬取qq空间说说</title>
    <link href="https://floatdesu.github.io/Codes/b854aa89.html"/>
    <id>https://floatdesu.github.io/Codes/b854aa89.html</id>
    <published>2023-01-27T09:45:50.000Z</published>
    <updated>2023-02-14T04:17:49.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web-golang"><a href="#web-golang" class="headerlink" title="web #golang"></a>web #golang</h1><p>第一次的Golang代码！纪念一下~~（chromedp就这么冷门吗资料都好难找…这波是被迫99%原创了（？</p><p>主要内容是：</p><ol><li><p>载入网页，等待用户登录，检测到登录后开始爬取</p></li><li><p>进入说说页面先检查总页数，跳转到用户需求的起始页，开始爬取</p></li><li><p>根据我的观察（？），qq空间网页结构如下：</p></li></ol><blockquote><ol><li>li[@class=’feed’] 存储了每一个说说/转发单元</li><li>（feed的下一层）/div[@class=’box bgr3’]<br> i. /div[@class=’bd’]存储了说说本体/转发内容<pre><code>     /pre[@class=&#39;content&#39; and @style=&#39;display:inline&#39;]存储了文字信息</code></pre> ii. /div[@class=’md rt_content’]存储了转发信息（如果名字为’md’，就是原创内容）<pre><code>     /div[@class=&#39;quote bor2&#39;]         /div[@class=&#39;bd&#39;] 文字信息             /a content是转发者信息，profileuin是转发者的QQ号             /pre[@style=&#39;display:inline&#39;] 存储文字信息         /div[@class=&#39;md&#39;] 图片信息             /a href中是转发图片的直链</code></pre> iii. /div[@class=’ft’]<pre><code>     /span[@class=&#39;c_tx3&#39;]         /a title是时间码（形如：2023年1月3日 19:45）</code></pre> iv. /div[@class=’box_extra bor3’]//此处先不做了好麻烦（）<pre><code>     /div[@class=&#39;feed_like&#39;]         /a 可能有多个，是列举的点赞者和人数（形如：292人）     /div[@class=&#39;mod_comment&#39;]         /div[@class=&#39;mod_comments&#39;]             /ul （以下每一组评论是一个Bor）                 //a[@class=&quot;nickname&quot;] content是昵称，href包含qq号信息                 //span[@style=&quot;]</code></pre></li></ol></blockquote><ol><li><p>根据这个结构，先找到每个说说节点，即Xpath为<code>.//div[@class=&#39;box bgr3&#39;]</code>，然后在其子结点中分别提取说说内容、时间码即可形成简单的日志。想要过滤转发的说说，故对div[2]以class属性为md和md rt_content进行区分即可。</p></li><li><p>希望体验一下Go语言知名的Goroutine并发，故把数据的处理、处理的数据生成日志两个步骤分配给独立线程。由于qzone本身需要ck登录才能使用，所以多线爬取也会被快速关黑屋（访问人数过多），这里就没有尝试代理池x<br>具体的内容就是read线程用来连续从网页爬取数据，把数据塞进textChannel，output线程时刻监听textChannel的动向、每收集50条说说（如果读取到结束信号，则不满50条说说也操作）就启动一个go线程（toFile）生成一个文件。</p></li><li><p>就效果来说感觉相当满意了！大约120页左右还是被关了小黑屋就是了（小声）可能多sleep会更安全吧~不过120页我觉得是个能接受的程度了~速度的话也比Python-Selenium快很多！<br>不足的话就是没有做超时刷新，一旦卡住就会出问题（不过chromedp稳定性还是挺不错的），等有空了就加上x</p></li><li><p>总体的体验就是：这库是真难用啊啊啊！不过写这个还是很有趣~明后天就来做漫画爬取的golang版本~动态网页还是爬取上比较麻烦呢（叹气）<br>细说这个难用，啊啊啊啊啊啊啊啊，啊啊啊啊啊（无意义的悲鸣），你这怎么把函数放在参数表里运行当常态，痛苦<br>比如说webEngine创建好了以后，python-Selenium可以直接webEngine.get(url)，就是get()是引擎类的类函数，但是这里所有相关engine的操作都是要“嵌套”的，这里要用chromedp.run(webEngine, xxxxxxx,xxxxxxx)（xxxx就是所有要运行的函数）。这样看还好，但是导致一个问题，这些函数的返回值都是函数参数，比如我查找一个元素它就不能直接把这个元素返回到左值，而是要先定义一个元素变量把地址传给找元素的函数……带来很多没必要的麻烦（我并不能体会到这种写法的好处……还是更喜欢把这种常用的、有返回值、和类紧密相关的函数写成类函数）<br>不过最后还是写完了！很开心！总之就是非常开心！&gt;w&lt;</p></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/chromedp/cdproto/cdp&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/chromedp/chromedp&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/chromedp/chromedp/kb&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">qqID     <span class="type">string</span> = <span class="string">&quot;2498742177&quot;</span></span><br><span class="line">savePath <span class="type">string</span> = <span class="string">&quot;F:/Temp&quot;</span></span><br><span class="line">docRange <span class="type">int</span>    = <span class="number">50</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ctx context.Context</span><br><span class="line">wg  sync.WaitGroup</span><br><span class="line">) <span class="comment">//每篇容量为50条说说,如果完成则不满50条说说也输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">url := <span class="string">&quot;https://user.qzone.qq.com/&quot;</span> + qqID + <span class="string">&quot;/311&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;please log in&quot;</span>) <span class="comment">//正在加载页面</span></span><br><span class="line">visit(url)                   <span class="comment">//初次加载</span></span><br><span class="line">deal(<span class="number">254</span>, <span class="number">999</span>)               <span class="comment">//需要加载的范围(第二个值如果过大，会自动修正为最后一页)</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deal</span><span class="params">(start <span class="type">int</span>, end <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">pageNum := ini_load()</span><br><span class="line"></span><br><span class="line"><span class="comment">//规范化输入</span></span><br><span class="line"><span class="keyword">if</span> start &lt; <span class="number">1</span> &#123;</span><br><span class="line">start = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> end &gt; pageNum || end &lt; start &#123;</span><br><span class="line">end = pageNum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">100000</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> output(textChan) <span class="comment">//创建一个进程，用来处理输出的文本</span></span><br><span class="line"></span><br><span class="line">turnToPage(start)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">load()</span><br><span class="line">read(textChan)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">nextPage()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i == end &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;all pages have been read. &quot;</span>)</span><br><span class="line">textChan &lt;- <span class="string">&quot;end&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Navigate(url),</span><br><span class="line">chromedp.WaitVisible(<span class="string">`#app_canvas_frame`</span>, chromedp.ByID))</span><br><span class="line">check(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ini_load</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Evaluate(<span class="string">&quot;window.scrollBy(0,1000)&quot;</span>, <span class="literal">nil</span>),</span><br><span class="line">chromedp.Sleep(time.Second),</span><br><span class="line">chromedp.TextContent(<span class="string">`.//a[@title=&quot;末页&quot;]`</span>, &amp;str)) <span class="comment">//找到最大页数</span></span><br><span class="line">check(err)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;total page: &quot;</span> + str)</span><br><span class="line">fmt.Println(<span class="string">&quot;initializing completed&quot;</span>)</span><br><span class="line">pageNum, _ := strconv.Atoi(str)</span><br><span class="line"><span class="keyword">return</span> pageNum</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">&quot;scroll error: can&#x27;t find pageEnd&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">load</span><span class="params">()</span></span> &#123;</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line"><span class="keyword">var</span> str <span class="type">string</span></span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Evaluate(<span class="string">&quot;window.scrollBy(0,1000)&quot;</span>, <span class="literal">nil</span>),</span><br><span class="line">chromedp.Sleep(time.Second),</span><br><span class="line">chromedp.TextContent(<span class="string">`.//p[@class=&quot;mod_pagenav_main&quot;]/span[@class=&quot;current&quot;]/span`</span>, &amp;str))</span><br><span class="line">check(err)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(str) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;* current page: &quot;</span> + str)</span><br><span class="line">fmt.Println(<span class="string">&quot;loading completed&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">&quot;scroll error: can&#x27;t find pageEnd&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(textChan <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;reading...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nodes []*cdp.Node</span><br><span class="line"></span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line"><span class="comment">// chromedp.Evaluate(`document.getElementsByClassName(&#x27;app_canvas_frame&#x27;)[0].contentWindow.document.body.outerHTML;`, nil),</span></span><br><span class="line">chromedp.Sleep(time.Second),</span><br><span class="line">chromedp.Nodes(<span class="string">`.//div[@class=&#x27;box bgr3&#x27;]`</span>, &amp;nodes),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;total: &quot;</span>, <span class="built_in">len</span>(nodes))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123; <span class="comment">//对于每个找到的说说节点</span></span><br><span class="line"></span><br><span class="line">path := node.FullXPath()</span><br><span class="line">path = path[strings.Index(path, <span class="string">&quot;//&quot;</span>)+<span class="number">2</span>:] <span class="comment">//去除iframe前面的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> share <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> date <span class="type">string</span></span><br><span class="line"></span><br><span class="line">textPath := path + <span class="string">&quot;/div[2]/pre&quot;</span>        <span class="comment">//子节点地址2：text</span></span><br><span class="line">sharePath := path + <span class="string">&quot;/div[3]&quot;</span>           <span class="comment">//子节点地址3：share(转发则该元素class为md rt_content)</span></span><br><span class="line">datePath := path + <span class="string">&quot;/div[4]/div/span/a&quot;</span> <span class="comment">//子节点地址4：date</span></span><br><span class="line"></span><br><span class="line">err = chromedp.Run(ctx,</span><br><span class="line">chromedp.TextContent(textPath, &amp;text),</span><br><span class="line">chromedp.AttributeValue(sharePath, <span class="string">&quot;class&quot;</span>, &amp;share, <span class="literal">nil</span>),</span><br><span class="line">chromedp.AttributeValue(datePath, <span class="string">&quot;title&quot;</span>, &amp;date, <span class="literal">nil</span>),</span><br><span class="line">)</span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">//启动进程进行登记</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()                  <span class="comment">//进程结束进行登记</span></span><br><span class="line"><span class="keyword">if</span> text != <span class="string">&quot;&quot;</span> &amp;&amp; share == <span class="string">&quot;md&quot;</span> &#123; <span class="comment">//如果文本为空或来源于转发，则跳过以下步骤</span></span><br><span class="line">textChan &lt;- <span class="string">&quot;&lt;!-- node &quot;</span> + date + <span class="string">&quot;--&gt;\n\n&quot;</span> + text + <span class="string">&quot;\n\n&quot;</span> <span class="comment">//开一个进程进行输出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">turnToPage</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.SendKeys(<span class="string">`.//span[@class=&quot;mod_pagenav_turn&quot;]/input`</span>, strconv.Itoa(i)+kb.Enter),</span><br><span class="line"><span class="comment">// chromedp.Click(`//a[@title=&#x27;下一页&#x27;]`),</span></span><br><span class="line">)</span><br><span class="line">check(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPage</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := chromedp.Run(ctx,</span><br><span class="line">chromedp.Click(<span class="string">`//a[@title=&#x27;下一页&#x27;]`</span>),</span><br><span class="line">)</span><br><span class="line">check(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">output</span><span class="params">(textChan <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//该进程唯一（保证顺序）</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">doc := <span class="string">&quot;&quot;</span></span><br><span class="line">k := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; &#123;</span><br><span class="line">item, _ := &lt;-textChan <span class="comment">//等待从通道中获取值</span></span><br><span class="line"><span class="keyword">if</span> item == <span class="string">&quot;end&quot;</span> &#123;</span><br><span class="line">k++</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> toFile(doc, &amp;k)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">49</span> &#123;</span><br><span class="line">i++</span><br><span class="line">doc = doc + item</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k++</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> toFile(doc, &amp;k)</span><br><span class="line">doc = <span class="string">&quot;&quot;</span></span><br><span class="line">i = <span class="number">0</span> <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toFile</span><span class="params">(doc <span class="type">string</span>, k *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//该进程可多发</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileSavePath <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fileSavePath = savePath + <span class="string">&quot;/qzone(&quot;</span> + strconv.Itoa(*k) + <span class="string">&quot;).md&quot;</span></span><br><span class="line">_, err := os.Stat(fileSavePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*k++</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//如果文件重名，则一直尝试到不重名</span></span><br><span class="line"></span><br><span class="line">doc = <span class="string">&quot;---\ntitle: qzone(&quot;</span> + strconv.Itoa(*k) + <span class="string">&quot;)\nlayout: wiki\nwiki: dynamic\ntype: dynamic\norder:\n---\n&quot;</span> + <span class="string">&quot;&#123;% timeline %&#125;\n\n&quot;</span> + doc + <span class="string">&quot;&#123;% endtimeline %&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">file, err := os.OpenFile(fileSavePath, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>) <span class="comment">// 以写|创建的方式打开目标文件</span></span><br><span class="line">check(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">file.WriteString(doc)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;- file &quot;</span> + strconv.Itoa(*k) + <span class="string">&quot; has been written. &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">//初始化chromedp</span></span><br><span class="line">headlessFlag := chromedp.Flag(<span class="string">&quot;headless&quot;</span>, <span class="literal">false</span>) <span class="comment">//有头模式</span></span><br><span class="line">opts := <span class="built_in">append</span>(</span><br><span class="line">chromedp.DefaultExecAllocatorOptions[:],</span><br><span class="line">chromedp.NoDefaultBrowserCheck,                               <span class="comment">//不检查默认浏览器</span></span><br><span class="line">headlessFlag,                                                 <span class="comment">//无头</span></span><br><span class="line">chromedp.IgnoreCertErrors,                                    <span class="comment">//忽略错误</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;blink-settings&quot;</span>, <span class="string">&quot;imagesEnabled=false&quot;</span>),       <span class="comment">//不加载gif图像 因为有可能会卡住</span></span><br><span class="line">chromedp.DisableGPU,                                          <span class="comment">//关闭GPU渲染</span></span><br><span class="line">chromedp.NoSandbox,                                           <span class="comment">//不适用谷歌的sanbox模式运行</span></span><br><span class="line">chromedp.NoFirstRun,                                          <span class="comment">//设置网站不是首次运行</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;disable-web-security&quot;</span>, <span class="literal">true</span>),                  <span class="comment">//禁用网络安全标志</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;disable-extensions&quot;</span>, <span class="literal">true</span>),                    <span class="comment">//关闭插件支持</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;disable-default-apps&quot;</span>, <span class="literal">true</span>),                  <span class="comment">//关闭默认浏览器检查</span></span><br><span class="line">chromedp.WindowSize(<span class="number">1280</span>, <span class="number">1024</span>),                              <span class="comment">//初始大小</span></span><br><span class="line">chromedp.Flag(<span class="string">&quot;run-all-compositor-stages-before-draw&quot;</span>, <span class="literal">true</span>), <span class="comment">//在呈现所有数据之前防止创建Pdf</span></span><br><span class="line">chromedp.UserAgent(<span class="string">`Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36`</span>), <span class="comment">//设置UserAgent</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">allocCtx, _ := chromedp.NewExecAllocator(context.Background(), opts...)</span><br><span class="line">ctx, _ = chromedp.NewContext(</span><br><span class="line">allocCtx,</span><br><span class="line">chromedp.WithLogf(log.Printf),</span><br><span class="line">)</span><br><span class="line">chromedp.Run(ctx, <span class="built_in">make</span>([]chromedp.Action, <span class="number">0</span>, <span class="number">1</span>)...) <span class="comment">//打开，但是什么都不干</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;web-golang&quot;&gt;&lt;a href=&quot;#web-golang&quot; class=&quot;headerlink&quot; title=&quot;web #golang&quot;&gt;&lt;/a&gt;web #golang&lt;/h1&gt;&lt;p&gt;第一次的Golang代码！纪念一下~~（chromedp就这么冷门吗资料</summary>
      
    
    
    
    <category term="Codes" scheme="https://floatdesu.github.io/categories/Codes/"/>
    
    
    <category term="web" scheme="https://floatdesu.github.io/tags/web/"/>
    
    <category term="golang" scheme="https://floatdesu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>回来的女儿</title>
    <link href="https://floatdesu.github.io/Drama-TVdrama/901aa4a4.html"/>
    <id>https://floatdesu.github.io/Drama-TVdrama/901aa4a4.html</id>
    <published>2023-01-16T17:25:36.000Z</published>
    <updated>2023-01-21T18:53:25.399Z</updated>
    
    <content type="html"><![CDATA[<p>推荐：4/5<br>标签：家庭/悬疑<br>简介：讲述了20世纪90年代的潭岭小镇，失踪与伤害案件频发。为找寻失踪好友小秀，孤女陈佑希逃离孤儿院，却阴差阳错成为李家失踪多年的女儿，意外撞见这个家不可说的秘密的故事。</p><p>简评：缺一不可的一个又一个大小事件促成必然的结果（悲）</p><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><ul><li><p>我趣，演员各个演技爆表了！张子枫这个发型感觉蠢蠢的哈哈哈哈（x）但是演得好棒！</p></li><li><p>剧情的复杂程度和长度相当匹配，不会感觉特别拖节奏，情节发展上也是有意外有合理。当我看到女主被关进去精神病院的时候，我真的觉得不知所措了（）</p></li><li><p>关于老李<br>  前半程其实一直觉得很心疼老父亲，有点希望小秀的事情真的是傻哥哥酿成的悲伤的意外，希望如实地呈现给警方，或者女主就在这个家里生活下去……后来大跌眼镜。（博主看男人的眼光还是一如既往的差.jpg）……啊啊啊啊把我的感动还给我……</p><p>  就是<br>  我觉得教自行车啊。买蛋糕啊。送孩子上学啊。什么的。这都很能共鸣啊。感觉我爸也差不多是这样吧。怎么说呢，那种明明经济并不富裕但是为了孩子愿意付出很多的我总是莫名其妙地心里一缩（当然啦，很多的爱有时候也会带来对子女的更多的期待、、期望、、甚至会成为枷锁……那就是另一个话题），啊啊啊啊啊……QAQ，我感觉我爸就是那种在这个情境下会给我蛋糕all in的类型</p><p>  怎么说呢，我觉得有些对子女的爱啊。还真的是。像是不需要理由的存在。有时候也会有点迷茫，血缘在亲情里的具体意义。如果不是认为有血缘，女主也不能被这样对待吧，可是如果认为没有血缘也愿意待在一起的话，那这种感情该怎么说明……如果李文文回来的话，看到女主又会怎么想……之类的（？）<br>  这对我不是很新鲜的想法就是了（）我有时候也会想着，啊啊我真是不肖女啊，如果我爸的女儿是别人来做的话很可能比我做的更好吧……我爸是很爱我对我期待也很高的类型，他自己很努力也觉得我应该要很努力，但是我是个咸鱼性格（悲）……</p><p>  噢，不过我很快就没有余地想这些乱七八糟的东西了，因为老父亲和我想象的也完全不一样……&amp;<br>  所以发现这个父亲这么吓人的时候我真的！啊啊啊啊啊（啸叫）</p><p>  好像也合理，被欺负久了的老实人，自卑的种子在心里深植，这一点甚至可以说是第一集就讲清楚了，老父亲别扭地问妻子是不是她在后悔没有选择王重江……</p><p>  怎么说，我还是受不了，。而且我看了这么多年悬疑小故事，我真的觉得杀人这种事情一旦开始，人就会异化的，就像一旦开始抄作业就会觉得“啊原来还可以这样解决问题！”然后每次看到作业都想抄（尽量浅淡的说法呢……），，唉<br>  而且<br>  对小孩子下手也太过分了，这样欺骗亲近的人也太恐怖了……会觉得背后好冷的程度……<br>  还真是他妻子说的那样呢<br>  看起来深爱着谁，其实最爱的是他自己……什么的</p><p>  就是 这推车业务也太不熟练了吧？而且推的时候到底咋想的，是不是早就想到会被发现想推给程威啊……救命……可是如果他真的没想过帮小孩子担责任，他完全可以不要推这个车，这样自己根本就不沾这件事情……或者只是想法在犹豫之间改变了吧。我不是很明白。</p></li><li><p>关于廖<br>  基本上就是刻画了一个为了傻儿子不顾一切的母亲<br>  剧情进入后半开始激情降智，难绷……就解释成因为儿子过于激动无法思考吧（唉<br>  其实前半我一直在想怎么能这样啊，一边一边的对两边都好过分啊，。。我妈好像就比我能理解一点，但我完全不行，我就是觉得她要不就放弃一边……（强加一点我的伦理观？）可是真的很痛苦啊<br>  在两个床之间辗转不好吧。可是看样子好像和老李也是分床睡。<br>  我搞不懂啊。<br>  如果是我……我的想法就是，优柔寡断就会什么都得不到的。唉。<br>  所以王重江怎么干嘛抛弃她又找回她啊？？</p><p>  还有那个，把一个好好的小姑娘关进精神病院真的好恐怖，她明明说什么都不愿意自己的儿子去精神病院，可是对女主……啊啊啊啊啊啊啊（悲）</p></li><li><p>王重江<br>  搞保健品的……（后仰）但是对廖女士是恋爱脑<br>  这两个人其实行为逻辑都还蛮简单的。。。</p></li><li><p>女主&amp;程威<br>  呃，我就是说你们不要指望两个普通的小孩能做到什么特了不起的事情，真的就是普通的青少年而已……不是名侦探之类的存在……冲动也有的，鲁莽也有的，对法律不知界限也是有的……</p><p>  不过从我的个人好恶来看，不是很能接受拿枪弄棒的脾气（退）我属于是在家教环境下极其排斥肢体冲突的类型呢……<br>  弹幕里怎么刷讨厌女主，把一切都怪在女主回家身上我也是不太理解的……事情本来就是那么些个事情，女主也没有伤害谁的恶意，她开始只是想知道真相，后来是想守护也守护过她的程威罢了……</p><p>  要说迷惑的话，可能在知道推车真相以后她立刻回去找廖女士讨论，说很恨老李让我觉得有一点没反应过来，说实话妹妹你们在抛下老王的时候本来不就是一副杀了人也没办法的态度了吗（就算真的觉得还能活你们会报警吗），……，反正我觉得一下子变得那么生气是我有点没想到的。至少还得等老李的残忍的一面更明显一些？然后寻找证据的方式也属于让我大开眼界……<br>  （不过我也就是纸上谈兵罢了x</p></li><li><p>一些没想明白的东西</p><ul><li>关于DNA证明<br>  虽然我不是很确认啊。就是说这个东西是小程去偷换了搞出来亲子鉴定的结果，然后先是廖女士看到了，廖女士很明确地知道女主绝对不是她女儿（洗衣机），所以直到精神病院那里才拿出来用，那时候老李也看到了（？？？），可是不久前老李才看到女主脸上假的痣<br>  我有点懵，有点好奇老李怎么看待这个报告（因为理论上不能造假呀），不过从态度来讲，看到痣以后老李完全就是一副反正你也不是我亲女儿的样子……</li><li>关于帮忙保管鱼饵的店的老板<br>  那哥们好像被打晕了，他后面没事吗（我本来以为要血案+1的……害怕极了）</li><li>所以王重江和小秀到底是怎么回事啊（大雾）还有那片子后面为什么是廖女士独白啊，是王重江有意的吗（？）</li><li>好像还有，但是我忘了，想起来再说吧…</li><li>啊啊啊啊啊啊啊洗衣机我趣，真的好恐怖……让我想起来看的一个什么和洗衣机有关的人格分裂的故事&amp;好像以前在萌芽也看过一个和洗衣机有关的，反正都好吓人。呜呜……</li></ul></li><li><p>总的来说<br>  不能说对我是没什么触动的。唉。<br>  家庭这个tag打在悬疑前面完全没问题（悲）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;推荐：4/5&lt;br&gt;标签：家庭/悬疑&lt;br&gt;简介：讲述了20世纪90年代的潭岭小镇，失踪与伤害案件频发。为找寻失踪好友小秀，孤女陈佑希逃离孤儿院，却阴差阳错成为李家失踪多年的女儿，意外撞见这个家不可说的秘密的故事。&lt;/p&gt;
&lt;p&gt;简评：缺一不可的一个又一个大小事件促成必然的</summary>
      
    
    
    
    <category term="Drama/TVdrama" scheme="https://floatdesu.github.io/categories/Drama-TVdrama/"/>
    
    
  </entry>
  
  <entry>
    <title>关于皮套&amp;直播的一些</title>
    <link href="https://floatdesu.github.io/Daily/d0ed31bf.html"/>
    <id>https://floatdesu.github.io/Daily/d0ed31bf.html</id>
    <published>2023-01-12T17:25:36.000Z</published>
    <updated>2023-01-23T19:25:36.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0"><a href="#0" class="headerlink" title="0"></a>0</h3><p>开始觉得有点无聊和烦躁了，故.,.（大量删减的聊天记录在2#）有亲友陪着我真的太好了！</p><p>不能说是完全没有套皮出道试试的想法吧，但是发现毫无心理准备的我对于这种事情来说还是<strong>太脆弱了</strong>（）</p><p>就结论而言，（尤其寒假之后）直播的时间会大幅减少……（不如说我以后预期是只偶尔做每周1-2次的<strong>歌回</strong>，其他内容纯看心情）寒假的话，由于最近心情的原因可能也会取消歌回（约22.00）以外的内容。基本确保能每天直播的时间大约到两位三次元不认识的舰长过期为止~</p><p>原因的话…</p><p>差不多两个原因五五开？……</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>一方面是<strong>内容上的固执</strong>。</p><p>就是，我不知道到底播什么了。（）</p><p>也想试试玩别的游戏，想试试以“面对着他人”的姿态玩游戏去直播，但是发现自己其实做不到。喜欢的就是喜欢，没那么喜欢的就是没那么喜欢，……</p><p>我确实是文字游戏博主哦。也想试着玩玩别的游戏的，但是就是觉得没有文字游戏好玩呀。就算我玩游戏对每个游戏有这样那样的看法，当别人问我推荐“神作”的时候犹豫很久很久，但是我还是喜欢这件事情呀，我喜欢故事远远胜过玩法……纯粹玩法的游戏，我也不是不能感觉到好玩，可是故事要吸引我得多，复杂的玩法会让我因为看不到故事而焦躁……</p><p>就算文字游戏是一个可能快要死掉的形式也很喜欢。我喜欢文字游戏特有的叙事方式，喜欢声优们的精彩演出，喜欢画师赋予角色们的鲜活容貌。习惯于这个恰到好处的幻想空间并对此感到舒适。</p><p>而比起一边与他人讨论一边看故事，我更愿意自己一个人自闭地看……一方面，我的阅读习惯比较排他，我偏好速读、遇重点回读，但是对别人未必如此，可能只能看到我不断地切过句子；另一方面，就是单纯地没有那么喜欢说话（）所以直播我玩文字游戏的过程对于观众来说是非常无趣的。而从我的角度而言，我也更希望观众自己去玩这个游戏而不是看我玩。</p><p>并且，很多文字游戏其实是不太方便直播的。对文字游戏来说，故事就是绝大多数了，不像是玩法取向的游戏、看了玩法会觉得想要自己去玩，有的片段看了确实影响体验的……而且有一些非官方翻译等等都是不允许公开流出的，我对那些为爱发电的汉化组非常感谢和佩服，不想违背他们的意愿。</p><p>唱歌什么的倒也是可以的啦，但是我会的曲子没有那么多也唱不了很久，一直播的话就会很多重复……（另外我觉得我的麦也不是很好x）</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>另一方面是<strong>我这个人的固执</strong>（）。</p><p>这个就在下面的聊天记录里说得很明白了……说到想做直播的初衷，也只不过薅叔叔的百来块钱羊毛罢啦。所以几乎是无准备无了解地进入了这个领域（……）</p><p>现在渐渐意识到：</p><blockquote><p>:想着 什么不认识的人也会喜欢 这种做法就感觉很不舒服<br>:没有做教程的时候想 什么不认识的人可能也会有帮助 那么纯粹</p></blockquote><p>至少我觉得我不能做得到，或者说我本来在三次元中都不算个什么讨人喜欢的人……</p><p>可以说社恐的很大一部分成因就是过强的自我意识，正因如此，即使在二次元我也不能做到开着直播和关了直播一个样地摸鱼（）</p><blockquote><p>友:\=\=推得咋样了（）<br>:没怎么管（x<br>:放养中<br>友:笑死<br>友:三天打鱼两天晒网捏（）<br>:是这样的（<br>:比如我现在就不想播了<br>:我已经开始觉得很无聊了（<br>友:xs<br>友:但是 感觉 现在有这个群<br>友:是不是就会<br>:影响我<br>友:有点上班似的压力<br>:对<br>:呜呜 我还是不该建这个的<br>友:不过他们话这么多（）<br>:应该我不播了就少了吧（<br>友:难说<br>友:可能直接把主包踢了自立门户（）<br>友:已经是成熟的水友了 涩图吊图技术一样不落<br>:确实……主包常年状况外<br>:我觉得我还是喜欢自闭地一个人打点没人玩的单机游戏<br>:而且我也不是很喜欢一边打游戏一边说话<br>友:害<br>:所以我也没什么可播的其实<br>友:感觉尝试这种东西<br>友:还是要留点退路（）<br>:是这样的（<br>:反正等两个陌生水友的舰长到期了我就自由了<br>:大爷，，那无所谓的<br>友:笑死<br>友:老头地位（）<br>:是这样的<br>:然后我想我确实对奇怪的人容忍度极低<br>:=。=<br>:属于看了就糟心的那种<br>:不如自闭<br>友:确实<br>:而且一些群友一副自来熟的样子<br>:呃<br>友:确实<br>:我有点难绷<br>:可能V圈是这样吧<br>友:有点太社牛了<br>:但是对我 不熟就是不熟啊。。<br>:在我这就是感觉。。啊啊啊<br>友:确实有点（？）<br>友:怎么说呢<br>友:戏子的感觉吧<br>友:就是要去取悦他人<br>:感觉还是不一样的<br>:开直播打游戏和自己自闭打游戏<br>友:尤其是有利益关系之后<br>:是这样的<br>:而且肯定主要还是白嫖的啊<br>:我今天看了几个V的那种切片<br>:就是 主播你能不能只露出眼睛然后点头（<br>:草<br>友:确实<br>友:那个<br>:我现在真觉得V圈是…<br>:我也很难理解有些妹子在皮套后面说这种话之类的是怎么想的<br>友:V圈搞软色情不是一天两天了（）<br>:玩弄阿宅的心情很有趣是吧（主要还是有利吧<br>友:也不一定吧<br>友:生活所迫可能就麻木了<br>:我不理解（大声<br>:不过说实话<br>:光好看皮套就能千粉<br>:V圈基数是在这<br>友:确实<br>:我已经不知道我想搞什么了<br>:其实这个粉丝基数可能是可以做一点好玩的试试的<br>:但是一想到是取悦的性质我就觉得挺恶心的（<br>友:怎么说呢<br>友:不开心就别做<br>:确实是<br>友:只能说钱不好挣a<br>:确实~<br>:还是好好写代码<br>友:好好学习好好搞钱<br>友:好好搞男人（）<br><strong>:想着 什么不认识的人也会喜欢 这种做法就感觉很不舒服<br>:没有做教程的时候想 什么不认识的人可能也会有帮助 那么纯粹</strong><br>友:确实<br>:可能普通人就是这样吧x<br>友:目的变了就很不一样了<br>:呜呜<br>友:希望别人喜欢。。。这种感觉真的很卑微<br>:是的是的<br>:希望别人有帮助的话 可以说是平等甚至有点上位的<br>友:确实<br>:还是自己开心最重要<br>友:感觉实在不行得玉玉跑路（）<br>:笑死，太懂了<br>友:我有点理解了<br>:但是我真觉得我要是每天需要考虑播什么<br>:我真的会玉玉的<br>友:为啥这么喜欢玉玉这个说法<br>:因为我本来就不是很擅长和别人相处的类型<br>友:确实<br>:今天我在群里脾气都有点控制不住了<br>友:花心思讨好别人真的很累啊<br>:但我这脾气注定没办法和很多人都好好相处吧（<br>:也就亲友们能忍忍我了233<br>友:感觉主包是一个很奇怪的地位<br>友:看起来是在上位<br>友:但又是观众的服务者<br>:其实是在下位<br>友:就很<br>:主包一旦说错话都是要被吊起来的<br>友:哎<br>友:确实<br>:比如说什么Vtb不就是…什么的<br>:我敢往b站上发明天估计就被冲烂<br>友:确实<br>:我不知道别的套皮人套皮播的时候是不是觉得这个事情很开心呢<br>友:“享受了流量的红利就要接受流量的反噬”<br>:反正对我来说就是…，渐渐意识到是在干嘛以后就只会觉得压力很大了<br>:…普通人还是别轻易尝试了（<br>:而且很难说做到心态上完全不在意别人感受的直播<br>:就是只要有这个行为了就会产生表演意识<br>:害害 已经搞不懂啦<br>友:害<br>友:以前觉得当V恰恰米挺容易的<br>:感觉以前（几周？）的想法有点理想化<br>:我也是这么想<br>:可能就是声音好听然后卖卖萌<br>:<strong>但是我现在觉得卖卖萌这种事本来就不是普通人自然而然地能做到的</strong><br>友:哎<br>友:感觉真的挺折磨的<br>:我现在速润<br>友:确实<br>:幸好投入还没有很多<br>:还是做我的冷冷清清的自闭文字游戏博主<br>友:虽然感觉现在已经挺难收场的了<br>友:但是已经是最好的结果了<br>:还好，要是一周一回唱个歌我还是能接受的（<br>:至少唱歌的时候不用考虑说什么话<br>:毕竟我还有个皮套，不用总感觉亏了（草<br>友:笑死<br>:我的兴趣都没支撑到我皮套做完<br>:草死了<br>友:沉没成本这就来咯（）<br>:沉没成本这就来咯（）<br>友:害 憋想了<br>:嗯嗯嗯<br>友:摆一天是一天<br>:你陪我理一下思路感觉想清楚很多了<br>友:摆到日子就差不多了<br>:本来觉得挺烦的<br>友:嘿嘿<br>:嘿嘿</p></blockquote><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>其实心情有点类似和我爸说要退出致远荣誉计划（类似重点班）的感觉</p><p>就是，我能预期到我爸一定会说好，会支持我的决定，可是我也知道他到底怎么想</p><p>我觉得我现在如果说啊啊不干了（可能是）喜欢我的大家的想法……（说是大家其实也没几个人啦）支持肯定是支持，除了我自己没人能强制我继续做这件事情的</p><p>群我也不知道该怎么处理好，就先这样吧……</p><p>让大家陪伴我任性一场，非常不好意思哦。（）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0&quot;&gt;&lt;a href=&quot;#0&quot; class=&quot;headerlink&quot; title=&quot;0&quot;&gt;&lt;/a&gt;0&lt;/h3&gt;&lt;p&gt;开始觉得有点无聊和烦躁了，故.,.（大量删减的聊天记录在2#）有亲友陪着我真的太好了！&lt;/p&gt;
&lt;p&gt;不能说是完全没有套皮出道试试的想法吧，但是发现</summary>
      
    
    
    
    <category term="Daily" scheme="https://floatdesu.github.io/categories/Daily/"/>
    
    
  </entry>
  
  <entry>
    <title>咎狗之血</title>
    <link href="https://floatdesu.github.io/Tavg/RoseR/ff3273f7.html"/>
    <id>https://floatdesu.github.io/Tavg/RoseR/ff3273f7.html</id>
    <published>2023-01-12T14:50:02.000Z</published>
    <updated>2023-01-21T19:35:12.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><ul><li>简评：带点灰暗的血腥气的幻想故事</li><li>推荐：4/5</li><li>标签：战争/暴力</li><li><p>Infomation: <a href="https://zh.moegirl.org.cn/%E5%92%8E%E7%8B%97%E4%B9%8B%E8%A1%80">MoeLink</a></p></li><li><p>CV List：</p></li></ul><div class="table-container"><table><thead><tr><th>姓名</th><th>声优</th><th>角川译名</th><th>身高</th><th>年龄</th></tr></thead><tbody><tr><td>Akira</td><td>先割れスプーン(鸟海浩辅)</td><td>明</td><td>172cm</td><td>18~19岁</td></tr><tr><td>Shiki</td><td>绿川光</td><td>式</td><td>188cm</td><td>21~24岁</td></tr><tr><td>Keisuke</td><td>何武者(杉田智和)</td><td>启介</td><td>178cm</td><td>18~19岁</td></tr><tr><td>Rin</td><td>鬼龙院隼人(福山润)</td><td>凛</td><td>154cm</td><td>-</td></tr><tr><td>源泉</td><td>一条和矢</td><td></td><td>183cm</td><td>40岁+</td></tr><tr><td>NANO</td><td>Prof.紫龙神谷浩史(山崎巧)</td><td></td><td>182cm</td><td>-</td></tr><tr><td>Yukihito</td><td>神谷浩史</td><td></td><td>178cm</td><td>21~24岁</td></tr></tbody></table></div><ul><li><p>一些：<br>  如果说甜池围绕着异形和宗教、探讨人的爱与非人的爱，那么这部就是围绕着战争和暴力，探讨罪与罚（？）……<br>  甜池给读者的感受像输液管里的药液一点一点流进血脉里，有细微且微妙的凉意，而咎狗是更加直接的，直接哐哐哐几拳砸向读者的脑袋……是的，血腥和暴力是几乎无法排解的主调。</p><p>  在体验过这一部作品之后，感觉对这位剧本娘的作品有了更多的认识。她的世界都是那么特别，弥漫着微妙的氛围感——她太懂得怎么去制造一个这样的世界了~&gt;w&lt;=</p></li></ul><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="关于角色们"><a href="#关于角色们" class="headerlink" title="关于角色们"></a>关于角色们</h3><p>战争背景下的大家都好麻木好冷漠好血腥好暴力——啊啊啊——你们怎么几乎都不做润滑（怒）小明好可怜</p><p>中间最柔软最细腻的一个大概是启介，结果启介也是一把螺丝起子直接捅穿天际，我趣，真的痛啊。。。。啊啊啊啊啊啊。。。。</p><h4 id="小明"><a href="#小明" class="headerlink" title="小明"></a>小明</h4><blockquote><p>陷入永远的，沉眠。这就是所谓的………「死亡」吗?<br>只是这样吗？也许，就只是这样而已。<br>并没想过要死。<br>但，对生存也不抱有特别的感慨。哪怕某天早上，突然就死去，那样也无所谓。<br>『不想死』，若如此强烈地期望的话一—那么，又要为了什么而活着?<br>除了身体的机能停止以外，「生」与「死」之间，又有什么差别?<br>再多的考虑也没有结果。</p></blockquote><p>明公主（双手合十）~</p><p>哎其实我刚开始也搞不明白大家为什么管他叫明公主哎，比起来说我觉得甜池的蓉感觉公主多了，毕竟蓉纤细敏感又疏离，明看上去不太一样……要命，我一旦想要分析，我觉得二者又有很多相似的地方。他们都是那种仿佛漂浮在世间一样的人，……蓉司更明显地处在迷茫中，因为他既无法融入人类社会的正常交往又不愿意服从那些东西的支配，小明则大多数线里完全没进过这个状态（）</p><p>简单来说，小明和蓉司都能“感觉”到许多东西，蓉司困在琐碎的思绪中无法迈向他人，那些琐碎的思绪形成了他与外界的隔音墙，而小明是完全不去“感受”、“思考”这些东西，和感性的柔软的东西好像有一层可悲的厚障壁……挚友的生命也只是让他稍稍多理解了一点挚友在于不在的差别、人类生与死的差别。大概是这种东西，造就了他们相似又不同的隔阂感吧。</p><p><del>我觉得这种0好带劲啊！呜呜呜呜呜，虽然我也很喜欢看上去软乎乎的小0，但是看上去好冷漠的不爱想的声音也1里1气的小0也好可爱啊！</del>（？在这理发店）</p><h4 id="启介"><a href="#启介" class="headerlink" title="启介"></a>启介</h4><p>我草起子哥你不要过来啊（害怕）</p><p>哎，怎么说呢，我好像能理解两方的心情。不过我还是觉得启介不应该去那个地方的，真的不适合他……小明一开始的生气我非常非常理解，我都自身难保了还要带一朵脆弱的娇花，娇花的正义让我甚至都不好意思动手（转头）</p><p>至于故事染了血以后，唉……</p><p>…………启介你要好好赎罪啊。……</p><h4 id="式"><a href="#式" class="headerlink" title="式"></a>式</h4><p>故事到这里一下子字母了起来！男人，你怎么能直面如此强大的我，真是太有趣了，看我不把你腿打断了</p><p>感觉是一个超级加强版总裁戏（？）</p><p>大火炖肉很猛，很有这个作品一贯的风格……但是说实在的几个结局我都不太喜欢，啊啊啊啊啊啊，我完全代入普通人视角，式哥直接军国统治我觉得好害怕……</p><p>以及那个感觉可能有点OOC的诱0结局，剧本娘好会写啊，瑟飞了啊啊啊啊啊（啸叫）</p><h4 id="凛"><a href="#凛" class="headerlink" title="凛"></a>凛</h4><p>他追他逃他插翅难逃（什么）</p><p>我愿称小明为一种天使，他在努力地弥合小凛支离破碎的心。不过，就算是因为和前男友长得像，小凛对小明真的很好，在这个黑暗的地方帮了他很多的忙、保护了小明，同时也保护了小明的善良，说不感动也是假的。</p><p>说来也是缘分吗，对式的执念支撑着凛，对Nano的执念支撑着式，还真是兄弟俩啊。然而，式仿佛从一开始就是强大而不在意手段的存在了，而凛是从天真一点一点走向绝望，……（或许式也有被磨练的契机吗……）</p><p>结局很理想，但是很甜。我就是喜欢和平社会嘛qwq</p><h4 id="源泉"><a href="#源泉" class="headerlink" title="源泉"></a>源泉</h4><p>全游戏对男主最好的一位了，几乎没怎么折磨过男主，至少身体上……</p><p>精神上就另说了，源泉一直被对儿子的死亡、对自己所参与的实验的真相的悲哀、后悔和恨意所囚禁着，所以在别的结局也是，只要知道了男主的真实身份就会想要除掉了事（啊啊啊说到底军方是怎么放心男主这种重要的实验资料跑到外面去的呀，一不小心就BE了）</p><p>不过在这个结局里，男主强调了他和Nano在实验中同样的被害者的身份、强调了他们的情感，软化了源泉的态度。唉，其实源泉本来也不是那么偏执的人，明明也很重感情。</p><p>（明明是个有儿子的异性恋，哼哼哼qwq）</p><p>没忍住私藏几段摘录。大叔真的很懂小明。不过小明确实是这个性格……他可能确实是这么想的，但是有些东西他不会或者不能进行什么有形的思考，喜欢而无法知晓、难以诉说，痛苦而无法自察、难以纾解……</p><blockquote><p>源泉悠然地笑着、大口地吞云吐雾。<br>源泉<br>    每次来到教堂、我都会觉得比起神来、人类更厉害。怎么说呢、人类比较有潜力<br>明<br>    潜力?<br>源泉<br>    啊啊。从远古开始人类就信奉着神明、也因为那强烈的信念、而完成了这样的建筑。你可以确认神的存在吗?<br>明<br>    ……不能<br>源泉<br>    对吧？不能确定也无法判断。<br>    明知如此、还是不停地为了祂去建造会面的场所、即是教堂」<br>源泉将香烟夹在指缝中、用手指轻敲着椅子。<br>少许的烟灰掉了下来、当然、他对此毫不在意。<br>源泉<br>    所谓的执念、在某种程度上是很恐怖的<br>    人的意念可以超越时间、唤起很多人的共鸣、现在也一样。经常可以听人说、虽然并不相信、但是很喜欢<br>确实、虽然今天是明第一次来教堂、而且还是这么破败的地方、却觉得很放松。</p><p>源泉<br>    我可不是要你向神明祈祷。<br>    倾诉是人最简单的本能、却异常地重要。<br>    所谓语言的东西、虽然肉眼看不见、但却是有着真实的形态。既可以积在胸口、也可以积在肚子里、然后变成凶器。<br>明<br>    凶器？<br>源泉<br>    嗯。<br>语言通过声音传达、并非肉眼可见。怎会变成凶器呢。<br>源泉<br>    话要是留在肚子里、就可能变为凶器。若积在胸中、那又是另一个问题了<br>明<br>    肚子？<br>源泉<br>    肚子<br>就是这里、源泉用下巴指了指明的腹部。不知是不是错觉、胃部感到一阵奇妙的异样。<br>源泉<br>    因为语言是有生命的。要是堆在那里就会不断地腐烂。腐烂的东西不能被身体消化、只会使你的身体变得急躁<br>    身体的急躁又会带来心理的焦躁不安。所谓言之于身、气之于心嘛。这些都是环环相扣、息息相关的。……对吧、明<br>源泉的眼神依然很沉稳。<br>源泉<br>    所谓说话、就是不需要考虑说什么、或是希望对方听到什么。只要将大脑里的东西原原本本地搬到外面来、自然便成了语言<br>    如果一直不说、便会越来越沉重。<br>    因为这是人类的本能。</p></blockquote><h4 id="Nano"><a href="#Nano" class="headerlink" title="Nano"></a>Nano</h4><p>神明一般的男人（感叹）我不是很理解就是了</p><p>对男主的态度让我无端想起了O社Paradigm Paradox的大boss，一样的那种“我与你是相似的存在”的独一无二的共鸣感，正因如此我会很重视你的话语……呜呜，在这一点上两部作品的表现都挺不错的！</p><h3 id="别的"><a href="#别的" class="headerlink" title="别的"></a>别的</h3><p>过得有点久了写得好粗糙，寒假看的故事太多了，有点怠惰于写repo，拖着拖着果然还是慢慢在忘掉啊……不想拖到年后啊！啊啊啊啊啊</p><p>这个故事并不太复杂，小明重复多次发现真相的过程比较枯燥，去掉这些的话剩下的东西也就比较少了，所以想要说很多也不知道从哪说起，感觉更多的是大家靠剧本娘一些很有深意的文字继续往下挖掘的东西。……相比来说，甜池就是几乎单线走到底，不会有这个问题。</p><p>嗯，总之，给我的感觉没有甜池那么深刻也是确实的事情啦。也可能，是不是某种意义上，战争下人们的异化比起异化的人对我来说更遥远呢？（沉思）</p>]]></content>
    
    
    <summary type="html">4/5 带点灰暗的血腥气的幻想故事</summary>
    
    
    
    <category term="Tavg" scheme="https://floatdesu.github.io/categories/Tavg/"/>
    
    <category term="RoseR" scheme="https://floatdesu.github.io/categories/Tavg/RoseR/"/>
    
    
    <category term="N+C" scheme="https://floatdesu.github.io/tags/N-C/"/>
    
  </entry>
  
  <entry>
    <title>无法打开的黑与金之匙</title>
    <link href="https://floatdesu.github.io/Tavg/SakuraR/e8c6562f.html"/>
    <id>https://floatdesu.github.io/Tavg/SakuraR/e8c6562f.html</id>
    <published>2022-12-31T07:26:03.000Z</published>
    <updated>2023-02-15T08:43:24.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><ul><li>简评：一部非常细腻的校园恋爱剧</li><li>推荐：4-/5</li><li><p>标签：校园/R</p></li><li><p>简介：自闭家里蹲少女某日因梦中的契机走出了家门，剪掉长长的刘海开始了普通的校园生活~</p></li></ul><p>（*女主有配音w）</p><ul><li>总评：<br>  取材其实比较古早（x）但是很细腻、完成度也很高，一些小甜品一直被人写来写去就是因为真的好萌（嘿嘿）另外，虽然古早但是画风非常非常好看！！<br>  结局很多，每个线有GoldEnd GoodEnd BadEnd BlackEnd，小火炖肉也很香很自然、没有为写而写的感觉，黑化结局也是真敢写……<br>  完成GE之后才会解锁Gold和Black，这时需要从头来一遍，可以看到很多和男主们内心戏有关的新剧情~<br>  *个人非常非常萌弟弟线（放心不是亲弟弟嘿嘿），喜欢弟弟系的可以冲冲看呀！（x）</li></ul><hr><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><p>期末考期间开始打和打完的，就没写repo，放假了又猛玩新的，完全忘了这个事情了。总之就是很香，不过也特别到我觉得不玩就缺少什么（没有什么特别的格局？就是校园恋爱剧罢了x）</p><h3 id="关于角色"><a href="#关于角色" class="headerlink" title="关于角色"></a>关于角色</h3><p>（按翼梦攻略中的顺序）</p><h4 id="园村郁人"><a href="#园村郁人" class="headerlink" title="园村郁人"></a>园村郁人</h4><p>啊啊啊啊好萌好萌好萌好萌哇！！（打滚）第一条就打了，差不多这个游戏的真相也全解开了？（关于打开少女心扉的哥哥什么的x）至于黑钥匙金钥匙什么的，呃，就当是个数值条就好了~</p><p>弟弟真的一直都很照顾女主呢，给她做好吃的（kksk）让她走出自闭的小房间还想要帮姐姐找到爱情。私心里觉得是担心自己对女主的亲情变质所以快点把姐姐嫁出去好让自己定死在弟弟役上（悲）……新增的剧情里也可以看到弟弟是在自己的线里和女主多接触了才产生恋爱的火花的呢~！所以还是不会让我太心疼弟弟会不会在别的角色的线里喜欢我（）</p><p>想要弟弟不要崩坏掉还是要给弟弟足够的安全感吧。调戏弟弟但是又不喜欢弟弟，或者喜欢弟弟又不愿意接受，这种事情都是不被允许的噢！虽然半夜来说悄悄话有点那个，但是作为R18游戏的话好像也不算很离谱……（啊这种事也就郁人做起来比较自然吧！如果是因为亲情所以担心，然后来说悄悄话的角色变成父母之类的好像就毫无萌感了，呜呜）</p><p>最喜欢的也就弟弟线啦~后面都没有给我这么大的触动qwq反而我倒是一直在别人线里看着可爱的弟弟~~嘿嘿！会打开门把我从莲井小黑屋里救出来的弟弟，会因为须藤打了我然后超级生气帮我去找场子的弟弟，会帮我试探欺负我心情的绀野的弟弟~~什么别的角色！根本不喜欢！只不过是让我更加喜欢弟弟的铺垫罢了！弟弟~弟弟~！弟弟~~！！！！！！</p><h4 id="莲井智臣"><a href="#莲井智臣" class="headerlink" title="莲井智臣"></a>莲井智臣</h4><p>我趣！你PUA我！（。）大概是不太喜欢的类型所以萌不起来吧……</p><p>有个特别相近的角色，倒是，灰姑娘玻璃鞋的纶灯，把女主角当作美丽的玻璃标本一样处理（）美丽的少女作为一种美丽的物品……多少有点……恐怖……（。）</p><p>只为你一人而开的理发店。房间里无数的与你长得一模一样的模型。……女主角闯进去的时候的感受，恐怕和玻璃鞋的女主角推开门看到全都变成玻璃的人类的感受差不多吧。甚至不需要对你隐瞒，你知道也无所谓，因为你是我的东西（。）或者说其实希望你知道，因为这才是真实的我——心里多少有那么一点孤独寂寞渴望被看到被理解的心情吧。</p><p>但是我是真接受不了啊（……）</p><p>就算是Good和Gold也无法绕开的，让男主渐渐意识到女主爱着这样的他无论如何也不会离开他的痛苦的过程。好可怕啊……</p><h4 id="须藤透央"><a href="#须藤透央" class="headerlink" title="须藤透央"></a>须藤透央</h4><p>恐怕是一种泰迪转世（。）同样的深深的自卑敏感寂寞，但是表现和上面那位完全不同。上面那位从控制中获取安全感，这位则是从……，不过这都是占有的形式也没错啦。</p><p>还有一个区别，就是上面那位是已经有很高的专业水平、算得上功成名就而隐退中的艺术家，这个还只是个孩子，甚至正在因为家里的经济问题而面临不得不和小女朋友分离、回老家上学。他说，上学什么的都无所谓了，你也不要在意那些了，只要和我在一起就好了。</p><p>两位恋爱的样子完全就是一种激进的年轻情侣，整天黏黏糊糊耽误学业，如果女主说不想耽误学业那就会影响感情……啊啊，好可怕……你还是让我读完书吧……虽然乙女游戏里可能是有完美的爱吧，但是放现实里这位根本是在逼迫女主放弃人生所有的可能性选择与他的恋情啊，这是我无论如何也无法接受的（我是无法对谁产生绝对的安全感的类型……）而且还没法沟通，甚至使用暴力……</p><p>对女主那边，为了透央，自说自话地去当陪酒女，我感觉很麻，也不想评价。……反正我要是透央我肯定气坏了，就算是普通的学生情侣对这种事也……透央正处于家庭危机，一想到自己逊到要女朋友去做这种事肯定爆炸（虽然我觉得你不应该对着女朋友爆炸，应该好好反省自己），女主没考虑到这个问题让我也觉得有点无奈。</p><p>要我说还是先好好读书吧（。）而且！回个老家分离一段时间就那么恐怖吗！！！！你们不是可以发短信的吗，啊啊啊啊啊这世界上甚至有网恋的啊！要是再忍个几年社交网络都发明出来了！……</p><h4 id="绀野千纮"><a href="#绀野千纮" class="headerlink" title="绀野千纮"></a>绀野千纮</h4><p>看上去很温柔。为了满足恋人不顾一切。但是这种不顾一切是恐怖的，因为他仿佛把自己定位成为了满足对方需求的存在一般……即使他并不愿意去理解对方真正的需求。</p><p>我很难理解这种不需要不愿意去理解对方的爱。……他感受不到对方的困扰和痛苦吗？</p><p>Black更是离谱（。）</p><p>怎么说呢，我觉得师生恋被忌惮完全是有道理的，因为通常来说师生之间存在着一些年龄地位学识之类的东西的差距，这些差距很容易让青春期的下位者感觉到模糊的憧憬、甚至喜欢的感情，这种感情有多稳固多容易褪色先不说（要说青春期的很多感情不都也是风一吹就会散掉的东西吗，即使曾经有过热烈的时间），……上位者想要利用这种东西太过于容易了……虽然状况不太一样，但是会让我想起来房思琪的初恋乐园。</p><p>更何况绀野本来就是被前女友已经认证过的地雷男（……）</p><h4 id="女主角"><a href="#女主角" class="headerlink" title="女主角"></a>女主角</h4><p>其实刚开始的时候我感觉到了高度的共鸣，作者应该是真有过类似的自闭阶段吧。我还挺相信文字的。……就是那种，不想见到任何人，不想和任何人交谈，对任何的人际交往感觉到沉重和困扰，有高度的自我意识和某种程度上的自卑、对他人的目光感觉到敏感和恐惧，之类的感觉……啊啊啊，完全能共情到，那一刻我就想，啊这游戏我开对了，期末考试周就该玩这个！（？）</p><p>呃，但是后面就没这么共情了，因为她也走出去得太快了吧（）……我趣，你是怎么能做到一星期就变成正常人，太离谱了……甚至，不擅长不喜欢人际交往的你还能举起手主动要求要参与一个跨校大活动的组织，救命啊，我单是想想都觉得毛骨悚然啊……</p><p>可能女主在自闭前和我就不是一类人吧，所以恢复得也不太一样……我现在还在半社恐阶段呢，在奶茶店做不到和柜员点单只愿意看微信的那种类型……啊啊啊……而且女主她是真好看啊！稍微打理一下走到街上就会被搭讪的类型，我就真的非常普通啦（悲）</p><p>说多了x</p><p>后面进个人线以后的女主我都比较无感，比较典型的日系乙女游戏女主角的类型了，有点软弱但是爱得很坚定，蛮普通的（。）有些男主的所作所为匹配上女主的爱，时常让我觉得：你喜欢他哪啊！！！</p><p>把女主角写的没特色也有这个问题，容易让我同时对男主也产生困惑：除了她好看，你还喜欢她哪啊！！！</p><p>不要都用なんとなく糊弄啊！</p><p>要说是弟弟役还能解释，男主们中的很多和女主认识得不久、甚至连交集都没多少呢。</p><p>……还有女主之前到底经历了什么啊能不能解释一下呀……别的完成度都很高，我觉得这个理应说一说的……</p><h4 id="别的"><a href="#别的" class="headerlink" title="别的"></a>别的</h4><p>也就这些吧（）现在想来也是比较普通的一个游戏，只能说是在剧情范围内做到了很流畅很细腻很完善啦，毕竟这么普通的背景真的相当考研作者的编排和描写，不然会让人觉得很无聊。有一些游戏会依靠复杂繁琐的元素和设定制造剧情矛盾，让故事发展能够被比较轻松地掌握，而这样的游戏就只能纯靠作者对人心的精妙把握。（鼓掌！）足以看出剧本的功力相当到位&gt;w&lt;</p>]]></content>
    
    
    <summary type="html">4-/5 一部非常细腻的校园恋爱剧</summary>
    
    
    
    <category term="Tavg" scheme="https://floatdesu.github.io/categories/Tavg/"/>
    
    <category term="SakuraR" scheme="https://floatdesu.github.io/categories/Tavg/SakuraR/"/>
    
    
  </entry>
  
  <entry>
    <title>沧海天记</title>
    <link href="https://floatdesu.github.io/Tavg/Flos/dafa11a.html"/>
    <id>https://floatdesu.github.io/Tavg/Flos/dafa11a.html</id>
    <published>2022-12-26T14:50:02.000Z</published>
    <updated>2023-01-02T14:01:45.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="assets/2022122622435400.jpg" alt=""></p><h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><p>推荐：3/5<br>简评：少年的羁绊与神明的羁绊<br>篇幅：不会继续玩了。两条线约12h</p><p>Caution：</p><ul><li>描写男性之间的友谊和羁绊的意思就是真的是友谊和羁绊，不是指女性向分类下属的蔷薇向（。）一点擦边都没有的那种（啊啊啊啊我没法理解一个没有恋爱线的游戏有好感度机制！！）</li><li>决战描写非常的有很多乙女向文字游戏的风格，特点就是非常的回合制，非常的二，非常多的谜之静止帧</li><li>单一主线，根据好感度不同会进入和不同伙伴共同战斗的分支结局，总体上差别不大。不过这条主线写得非常有趣，让玩家甚至无法猜测到下一步会发生什么。</li></ul><p>打完感觉人已经没有感觉了，这到底是怎么回事呢，原来有人打之前根本就没有注意什么叫做真正的女性向——原来就是真正的一点恋爱都没有的意思啊！博主打着打着都要掉小珍珠了……</p><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><p>我真的是忍不了！拜托！你那决战写的是什么东西！？如果有人倒下了，邪神就在旁边看着所谓正派几个人磨磨唧唧一会然后几个人若无其事地继续回合制……邪神完全不够邪好吧，直接挨个击破不行吗，几个小孩就在你的家里乱窜你怎么可能不知道……</p><p>还有你那几个情感丰富的神，太好了，除了邪神，太阳神一家三口我是几乎一点神性都感受不到，这波，这波是人类直接被太阳神一家三口的优柔寡断拖死了……傻白甜月读和他的傻白甜哥哥天照，被邪神忽悠的一愣一愣的就好像没有大脑，哦对你们神是不是确实没有大脑，不好意思啊。</p><p>考虑到神话背景，就不吐槽把神的力量远远写在凡人之上了。主要是这就会有一个问题，我一直很在意这种问题，尤其在花女王里面特别生气地写过，你这样战斗平衡很容易就做得稀巴烂，因为强度完全就是剧本娘一支笔……为了让几个十几岁的凡人小孩能够参与神明的战斗，特意给他们每个人分配了一个没有脸的神作为庇护，……事实上也确实是做得稀巴烂就是了。</p><p>还有让人火大的ナギサ，摘了尸鬼耳朵做实验。不行真的会有点恶心到我，我当时对着尸鬼割自己耳朵的战斗画面咳咳咳狂吐，……ナギサ看起来蛮正常的一个小孩，怎么玩这么大……</p><p>以及茶褐色外套的哥们的谜之立场。救命，你怎么能做得到一会儿好人一会儿又能超狠心做坏人，刚刚还是要干死主角的样子，一会儿又觉得可以可以大家一起去干掉邪神吧。我能理解剧本娘的意思是间谍哥顾及到家族的安危，可是这写的变化也太过于莫名其妙，让我感觉这哥们完全没有自己的决心，……说起来，哥们你和小鬼还不是一代人呢，我看小鬼们就是看弟弟的感觉，可这哥们年纪比我还大啊（x），感觉完全就是捉摸不定又不太懂事的状态……</p><p>不过嘉隆老师是真的顶。（双手合十）愿主能够原谅你们的罪孽。</p>]]></content>
    
    
    <summary type="html">tbc</summary>
    
    
    
    <category term="Tavg" scheme="https://floatdesu.github.io/categories/Tavg/"/>
    
    <category term="Flos" scheme="https://floatdesu.github.io/categories/Tavg/Flos/"/>
    
    
  </entry>
  
  <entry>
    <title>逢魔が刻 ～かくりよの縁～</title>
    <link href="https://floatdesu.github.io/Tavg/Sakura/2655f8cd.html"/>
    <id>https://floatdesu.github.io/Tavg/Sakura/2655f8cd.html</id>
    <published>2022-12-20T14:38:12.000Z</published>
    <updated>2023-01-02T14:01:45.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><ul><li>简评：[误]入幽世的少女冒险记</li><li>标签：和风奇幻</li><li>推荐：3-/5</li><li><p>篇幅：中篇（25h）</p></li><li><p>Points</p><ul><li>5*个人线（真相线为==常磐线==，但不锁线）</li><li>攻略难度低，可以调整数值跳转</li><li>糖分不是很高，有部分场景戳到的话会觉得很甜（我就有好几个&gt;w&lt;），但是总体上感情发展方面的描写只能说是一般（其实我觉得明明可以写得很好！！很生气，好牌乱打）</li><li>关于日系神话的设定引入比较多，这些相关的文本也比较难…（但是我都嘎嘎跳，甚至连游戏内词典都没翻x（它怎么不能一键调用啊？）好像也没影响整体理解）</li><li>真相不是很复杂，故事也简单，如果按おすすめ顺序玩下来会觉得信息量比较低</li><li>所以总的来说就是不是很甜，故事能圆上但是不算很刺激，也没什么激动人心的波折，但是要说很不好的地方也说不出来，就是普普通通吧</li><li>画的真的是好看啊！！！！！！！！</li></ul></li><li><p>（如果你不在意剧透一些可能小雷的地方，可以去看一看剧透篇的1，剧透程度大概截止到按顺序攻略的一半位置（虽然是这么说，不过前一半根本就没有什么主线信息量就是了2333）</p></li></ul><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="1-说在前面的一些（关于女主的一些）"><a href="#1-说在前面的一些（关于女主的一些）" class="headerlink" title="1. 说在前面的一些（关于女主的一些）"></a>1. 说在前面的一些（关于女主的一些）</h3><p>（无关）玩了二十个小时我都还不知道水绪怎么念（）我还是喜欢男主喊喊名字的qwq，不过声优们在不读名字的地方很多也做了小发挥，喜欢（现在知道了，念ミオ，音同澪，好好听啊~）</p><p>女主是神籬（ヒモロギ），查了一下百度感觉不是游戏里的意思，根据游戏里的意思，是类似神明的供品一样的存在。神籬被设定拥有与一切有灵之物有很高的亲和力，容易被万物所爱；生来的意义就是为了“神のものになる”，字面意义上的：成为神的所有物，能够非常非常大的程度上提升神明的力量。所有的意思呢是指：要么是被神明连灵魂都吃掉，要么是永远寸步不离地陪伴在神明的身边，……即使是不用痛苦地死掉，这个陪伴也没有那么轻松，是需要一个仪式的，如果神明不够强大的话神籬就会失去一切感知、失去“自我”。</p><p>女主掉进幽世然后被狐神培养的过程，就是不断作为神籬觉醒的过程，在觉醒之后她的气息会完全被神们知道（和风神话设定下有非常多的神），按游戏里的说法，会被当做肉一样去争抢，女主的意识根本不重要……（。）</p><p>怎么说，不是说这个背景不行，但是这种设定好人神供奉一样的背景然后玩家站在一个被供奉的贡物的视角就很不爽，你这也不是个抖M游戏（参见怀有特殊的血液的小仓唯in大菠萝），就是个平凡的少女童话啊，……女主怎么跟“牺牲玉帛,弗敢加也”里的牺牲（。）在神眼里是一个待遇啊！！</p><p>而且，虽然奥，作为供品的女主不是什么力量都没有，说了有亲和力，然后也会有一些预知力，她的祈祷也会有愿力，（其实我觉得贡物有特殊力量的设定就有点怪怪的2333），但是这些都不是能打的力量而已，而且也不受控，基本看剧本娘心情出现，整篇游戏的立场就是被保护被保护被保护……与此同时，水绪是经典的温柔善良又有责任感类型的日乙女主，不免有些时候就看起来有点来火了……&amp;……是不是圣母我不好说吧，总之没有体现出不圣母的地方……</p><h3 id="2-各角色线路吐槽"><a href="#2-各角色线路吐槽" class="headerlink" title="2. 各角色线路吐槽"></a>2. 各角色线路吐槽</h3><p>a. 奏太</p><p>怎么说呢，阳光开朗积极向上超受欢迎的二次元美少年虽然不算我xp但是也是可以的！但是写得……啊啊啊啊有点绷不住</p><p>最早打得一条线了现在有点模糊，记得最清楚的就是女主和奏太第二次遇到死魔事件，也就是大静谧（博主你什么取名方法），然后两个人一路逃到[病葉床]（玩完了我都不知道这个词是什么意思2333）的一个阴暗的摆了一张沙发的灰扑扑房间开始对线。奏太挺人类的挺正常的，他的能力能救女主本来就挺了不起了，能保护好女主就很值得开心了，女主“不行，我们得出去救大家”大概就是这种很无聊的对话进行了非常久……</p><p>考虑到女主和奏太是镇守学舍的学生，打比方的话可以说是现世的警校生之类的存在，对他人有保护的责任之类的想法的产生也没什么值得质疑的，但是，也不是说女主很圣母或者是我的话我就不劝他救人，怎么说呢……我觉得很无谋啊……而且，女主她也不能打架啊！！！虽然反复强调女主是有“能力”的，但是基本上也就是什么“看穿弱点”啊“祈祷”啊之类的辅助能力，在这节点他们已经直面过死魔了，女主对自己的战斗力应该完全有数……</p><p>所以女主干的事情其实是：啊？你害怕死掉？你觉得做不到？そんなじゃだめよ…为了保护大家！頑張らなきゃ！！！……对于我的核心雷点是，女主她自己打不了，奏太不是很想打，但是女主正在几乎是逼迫地希望奏太去打一场赢的概率几乎为0的仗……</p><p>总之这段超级长，打得我直接下头了，之后半个月都没碰游戏机……SOS</p><p>b. 宵宫<br>呜呜、せんせい我的せんせい——刀的名字是五月雨也好好听呀！！同样是不太戳我xp的优雅成男，快速掠过（？）这里我也简略吧。剧情矛盾也很简单，都在皓身上，皓是女主的愿望所形成的神在月白线里月白的调侃里提到一句以外再也没有照应过2333，女主作为召唤师存在的可能性也完全是看剧本娘的心情嘛（）（皓这么强哎。女主多来几次可以组一个军队吧……（？））</p><p>比较难受的是月白拜托女主回现世神社的剧情，确实那里并不安全，女主犹豫是合理的，可是宵宫去了就会死掉的设定也是真的、是宵宫自己也知道的，女主说个两句宵宫就很主动地说要去要去就很奇怪，你要是真的喜欢她应该是想长久地守护她而不是瞒着她保护她一次、然后让她的余生一直背负着负罪感，而且能去的也不是非宵宫不可，想不到让五月雨去也总有别的办法啊……宵宫这么想为了女主自我牺牲是我想不明白的……还是说就是为了多凑一个分支结局啊……</p><p>c. 颯</p><p>在这个游戏我的初恋啊！！！女主逢魔之刻跑进幽世的时候，刚刚摆脱危机来到平静的地方，看到的就是颯在无人的花海里安静地坐着。颯多好看啊，不只是立绘里，剧本娘也不止一次的描写这个木魂、地主神的美丽的外貌了嘿嘿x</p><p>而且是细谷！！！众所周知（也没有）我的命中注定的老公我早已遇见，就是终远的顶流烫男人西恩·布洛菲瓦兹=w=就是细谷桑配的~啊，但是这也导致了一个问题，我对细谷的声音的印象直接定格了，就是那种，嗯嗯，总是觉得这个声音对应的就是那种学识渊博的、成熟稳重还有点屑的成男……同样的问题也影响到我玩黑蝶的体验了（）但是黑蝶还好，至少对方也是个看起来成熟靠谱的少年。可是，ハヤテ给人的感觉就完全不一样……不一样的地方正是我超中意他的地方qwq</p><p>这次是一个一直以来对于幽世颇有“漂浮感”的天生神明~只有花花草草大自然能够听见他的声音，他和幽世的妖魔鬼怪神明没法交流，也没有很强的共情，对镇守学舍的工作没有什么激情也没有什么归属感（不如说他为什么会去那里这点就很奇怪……）但是水绪给了他传达声音的机会，让他对镇守学舍的大家、尤其水绪产生了羁绊和情感……还挺美好的呀，哈哈哈（）</p><p>颯是个很天然的带着孩子气的神，对女主有非常天然的保护欲占有欲，非常可爱（）开头我就被他在女主宿舍门口等女主一起去上学结果发现女主已经去了然后在那里沮丧萌到了&gt;w&lt;一起编花环也很温柔很美好，和花说话也超级喜欢。</p><p>有七个章节不只是因为涉及主线多，还有因为颯自损修为（？）劈了自己本源的大树把女主送回现实然后两个人互相痛苦思念数日女主又自己跑回来，颯惊讶但是又不是很生气因为他发现没有水绪的自己真的太痛苦了，两个人贴贴了一阵就开始准备仪式，中间写了一大堆伙伴们帮忙准备东西的剧情（）。好吧，我是真的觉得女主这一个来回有点莫名其妙的，试错成本也太高了吧，……完全是没有必要的事情……而且颯也完全不跟女主商量就做决定，嗨呀）……</p><p>对了下雨那段！我超级喜欢啊啊啊啊 TvT 有种孩子长大了的欣慰感（）</p><p>（而且，暗示了半天，柏木前辈到底和颯是什么联系啊2333 写明白一点嘛）</p><p>d. 月白</p><p>太好了我觉得这条线写的烂爆了！（侧目）不如说我真的很讨厌这个人设出现在攻略对象里！女主完全一副被强者设计和引诱的样子啊……（声优的语气也屑得很贴脸很符合角色2333）</p><p>(1) 关于喜欢</p><blockquote><p>女主：（我好像喜欢月白桑呢，明明并不是很了解，喜欢的是什么呢）<br>女主：（是的，作为神的他也好，作为“月白”的他也好，我喜欢他的全部）<br>月白：你喜欢我啊。我也喜欢你哦。（不过是作为神籬的那种啦，你能成为我的东西吗）</p></blockquote><p>所以月白在不是神的时候是什么样子啊？连一段插叙都吝啬吗（）剧情里根本没法认识到月白不像个神的样子啊……</p><p>(2) 关于开心</p><blockquote><p>女主：和月白待在一起很开心！（因为喜欢月白桑所以只要看见就会觉得开心）<br>月白：和水绪待在一起很开心！（看神籬少女为了她的单纯到愚蠢的愿望努力、难过，觉得非常有趣）</p></blockquote><p>(3) 关于愿望</p><blockquote><p>女主：我希望大家能一起平安幸福地生活下去，希望你解决幽世的困境<br>月白：好啊，那么我们就干脆斩草除根，把可能变坏的存在都清剿干净吧<br>月白：你看啊，他们都是因为你的愿望死掉的哦，我做得是不是很棒？<br>女主：……<br>月白：你哭什么呀，为什么不会觉得开心呢？（一边欣赏女主的悲伤的表情觉得有趣）<br>月白：与其放置他们不管，不如完全从根源上杜绝他们犯罪的可能性嘛？</p></blockquote><p>可恶，我一点都不觉得这种屑很戳我，我觉得……恶心。神啊，那可是你的子民啊。。。你觉得那里治安差有人嗑药会出坏人，那你自己不管怎么也不让镇守学舍管呢……</p><p>多说一句，我觉得你们幽世还是应该要有幽世法的，你们的神实在太乱来了……而且说着想要稳定的幽世所以建立了镇守学舍管理，可是管理到什么程度也不设定，全看学生和老师的良心……这怎么运行得下去啊（）</p><p>(4) 关于喜欢_2</p><blockquote><p>女主：我喜欢你，即使成为你的神籬也心甘情愿那种<br>月白：（掏出一个不能说谎的幻境，让幻境里每一个女主熟悉的人都出来动摇一下女主的喜欢的想法，用以考验女主）</p></blockquote><p>这里是我最无语的地方，也是BE分叉。如果女主但凡有一点动摇，或者之前好感没刷好，就会被月白直接在仪式里送走，变成没有自我意识的神籬……如果女主一路坚定地重复爱语，月白就会在让她成为有自我意识的神籬然后娶她。……好吧，反正都是变成你的东西啦。可恶，我下意识地很讨厌一些“无法退路的情境”。</p><p>总的来说，就是这个人神恋真的写的很不舒服，男主一直是以神看供品的视角玩弄女主的心情并为此感到快乐，嘴上说着喜欢到底是什么样的喜欢，总之我觉得是无法和女主的情感同等比较的喜欢，就算他的BestEnd是全游戏唯一一个上车的也一样，我只能共情到女主的恼怒和无力，并没有ドキドキ。剧本娘的狐神很有神的对于人的疏离感、上位感，唯独缺乏恋爱感。</p><p>e. 常盤</p><p>剧本娘你要不要看看自己在男女主终于能互诉衷肠之前都写的是啥？？？啊？？？有些片段你写的是ok，但是基本的に完全是莫名其妙……</p><p>一见钟情我完全可以接受，好吧，男主不是很爱说话天天对她摆脸色说重话女主每次都“なんとなく”地过去没话找话，也行吧，忍忍，毕竟明里暗里还是说男主挺关心女主的，和神無一起买衣服走失被男主捡回来挨训那次男主误会女主不高兴了拼命解释也挺可爱的，milkHall的甜点和戏份超甜我也喜欢（虽然我真的能感觉到女主在每次对话里的尴尬的感觉……），但是但是，啊啊啊啊我最不能忍的是，那个重要的告白写的是啥啊？？？</p><blockquote><p>女主：*表白<em><br>男主：你是不是误会了什么，我不喜欢你。<br>女主：就算这样我也喜欢你，想要帮助你实现目的。<br>男主：\</em>强吻<em>（我草，甚至是深吻，女主都傻了）<br>女主：？？？どうして<br>男主：你想要的就是这种东西对吧！反正我不喜欢你。速速滚吧！<br>女主：？？？\</em>泪如雨下*<br>（女主走了以后）<br>男主：我怎么能这样呢！</p></blockquote><p>我理解剧本娘觉得男主冲动又傲娇的样子有萌点，但是这个冲突是否有点过于强行了……我好无语，我真的好无语，为什么把男主写的像个冲动傻逼，啊？？？我觉得剧本娘的意思是，常盘一直喜欢水绪一直为她默默地付出没想过要被喜欢，也不希望她的恋心影响到自己保护她的大业，所以惊讶不相信觉得是误会、所以拒绝；发现女主真的喜欢他，又非常感动，因为自己其实非常喜欢现在的她，所以激动地强吻（？）；吻完发现自己打乱了自己的规划，对自己做的事情也非常惊慌失措，所以也惊慌失措地说出伤人的话来赶走女主。</p><p>草，我简直就是剧本娘的知心妹妹，把它解释通了，可是你看这个剧情从玩家和女主视角来看是个啥啊！！是个啥啊！！！？？？而且最重要的是，男主一直以来不都是在坚持着他保护女主这件事情作为他生存的意义吗，更何况他对现在的女主也是隐约存在恋心的呀，怎么能做得到这么伤害女主的事情，拜托这不是不懂女孩子的问题，是他吗根本就没有照顾女主心情的主观想法……别的剧情有的时候男主确实说话难听不爱想，可是他关心的意思都完全传达给女主了呀，那这里传达了的是什么啊？？？常盘，被剧本娘绑架了你就眨眨眼（）</p><p>好啦，跳过这一段我还是非常喜欢常盘的，谁会讨厌喜欢甜食、说到甜食会kirakira的容易脸红的纯情少年啊~虽然冲动傲娇说话难听不爱想，但是其实有非常温柔的心啊~（麻烦给我来一份常盘Special~~）</p><p>以及，怎么说呢，我觉得常盘的想法很真实，比如说：既然花了半个魂魄才保护了你，也想一直保护下去；既然至今为止的人生都在保护你，那么我也不会后悔，不会否定我的努力；之前这份感情说不上是喜欢，（或者说只是一种执念，）但是现在的我真的很喜欢现在的你，看到你现在好好的我好开心。</p><p>确实，我想了一下我如果第一次做了这个选择，可能也会后面一直这么做（特别喜欢的对象的话），如果后悔了就什么都没有了，有种像玩游戏一直氪金氪了很多后来弃坑也不愿意卖掉，因为一旦卖掉好像那些充进去的钱、看起来“亏损”的钱就变成实际的东西了……（好像也不是很恰当2333）玩游戏氪金也不会说后悔氪金，不管怎么样都会哄自己说：因为喜欢才氪的，因为开心，不会后悔的。</p><p>但是这样的感情……也太沉重了吧。即使水绪喜欢上了常盘，水绪的喜欢也无法回应这份感情，就算水绪不提，她心里也一定抱有很重的亏欠的感觉，这样的恋情……嗯……或者说，这种事情只要是知道了，总会抱有亏欠和罪恶的感觉，无论对方怎么想的都会觉得很难受吧……</p><p>（Soma配得也太好了，啊啊啊啊啊啊啊啊啊啊啊）（虽然一开始觉得他配脸这么成熟的角色有点怪，但是啊啊啊啊啊啊啊啊啊啊太会配了）</p><h3 id="3-总评"><a href="#3-总评" class="headerlink" title="3. 总评"></a>3. 总评</h3><p>发现我个人线写的全是槽点（草），但是其实玩的过程也没有那么生气，只是说它让我生气的地方让我印象很深刻……而且也有很多甜的地方）（x）但是也不够突出，不是那种再过好几个月我都能记得好多的故事和人设。……</p><p>不过画的是真的好好看啊……！！！！</p><p>嗯……情绪发泄完了居然有5k字了，我好累啊……就写到这里吧……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无剧透篇&quot;&gt;&lt;a href=&quot;#无剧透篇&quot; class=&quot;headerlink&quot; title=&quot;无剧透篇&quot;&gt;&lt;/a&gt;无剧透篇&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简评：[误]入幽世的少女冒险记&lt;/li&gt;
&lt;li&gt;标签：和风奇幻&lt;/li&gt;
&lt;li&gt;推荐：3-/5&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="Tavg" scheme="https://floatdesu.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://floatdesu.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
  <entry>
    <title>汇编语言 速效救心丸</title>
    <link href="https://floatdesu.github.io/Coding/74e40bab.html"/>
    <id>https://floatdesu.github.io/Coding/74e40bab.html</id>
    <published>2022-12-07T07:03:08.000Z</published>
    <updated>2023-01-02T14:07:00.666Z</updated>
    
    <content type="html"><![CDATA[<p>帮助快速上手汇编语言编程，虽然只限于编程<br>配套Bilibili视频：<a href="https://www.bilibili.com/video/BV1BM411B7ZB/">上篇</a>；<a href="https://www.bilibili.com/video/BV1BM411B7ZB/">下篇</a></p><h1 id="VScode配置调试环境"><a href="#VScode配置调试环境" class="headerlink" title="VScode配置调试环境"></a>VScode配置调试环境</h1><ol><li>安装插件TASM/MASM</li><li>右键扩展设置，选择Assembler：MASM</li><li>右键调试即可开始调试了！</li></ol><h1 id="Debug-exe"><a href="#Debug-exe" class="headerlink" title="Debug.exe"></a>Debug.exe</h1><blockquote><p>R命令：查看、改变CPU寄存器的内容<br>D命令：查看内存中的内容<br>T命令：执行一条机器指令<br>G命令：从停顿的地方运行到底</p></blockquote><h1 id="第一段代码：Hello-World"><a href="#第一段代码：Hello-World" class="headerlink" title="第一段代码：Hello World"></a>第一段代码：Hello World</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DSEG SEGMENT</span><br><span class="line">        MESS DB &#x27;Hello, World!&#x27;,0DH,0AH,24H</span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">SSEG SEGMENT PARA STACK</span><br><span class="line">             DW 256 DUP(?)</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">              ASSUME CS:CSEG, DS:DSEG</span><br><span class="line">        BEGIN:MOV    AX,DSEG</span><br><span class="line">              MOV    DS,AX</span><br><span class="line">              MOV    DX,OFFSET MESS</span><br><span class="line">              </span><br><span class="line">              MOV    AH,9</span><br><span class="line">              INT    21H</span><br><span class="line">              </span><br><span class="line">              MOV    AH,4CH</span><br><span class="line">              INT    21H</span><br><span class="line">CSEG ENDS</span><br><span class="line">END BEGIN</span><br></pre></td></tr></table></figure><h1 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h1><p>用以下指令可以写一个基础的程序：</p><ol><li>段定义+Assume</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XXX SEGMENT(XXX:DATA/STACK/CODE)</span><br><span class="line">XXX ENDS</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CSEG, DS:DSEG, SS:SSEG</span><br><span class="line">MOV AX,DSEG</span><br><span class="line">MOV DS,AX</span><br><span class="line">MOV AX,SSEG</span><br><span class="line">MOV SS,AX</span><br></pre></td></tr></table></figure><ol><li>数据定义</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(ORG 1000)</span><br><span class="line">(NAME) DB ?/...</span><br><span class="line">(NAME) DB N DUP(?/...)</span><br><span class="line">db:12H/dw:1234H</span><br></pre></td></tr></table></figure><ol><li>MOV</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,Y</span><br><span class="line">MOV Y,AX</span><br><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure><ol><li>+-</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD AX,X;AX+=X</span><br><span class="line">SUB AX,X;</span><br><span class="line">INC AX;AX++</span><br><span class="line">DEC AX;AX--</span><br><span class="line"></span><br><span class="line">NEG AX ;取负</span><br></pre></td></tr></table></figure><ol><li>程序的终止</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>稍后会讲的进阶指令：</p><ol><li>Label和JUMP：跳转</li><li>分支和循环</li><li>堆栈的使用</li><li>&lt;函数&gt;：PROC和MACRO</li><li>INT 21H指令：输入/输出</li></ol><h1 id="寄存器的使用"><a href="#寄存器的使用" class="headerlink" title="寄存器的使用"></a>寄存器的使用</h1><p>在汇编语言中，我们不能对内存中的数据进行直接操作，如果要操作，需要把数据先<code>MOV</code>到寄存器中再进行处理。<br>为了写代码的过程更顺滑，最好先简单了解一下这些寄存器的使用，当然，你也可以只了解通用寄存器的使用，别的等用到了再去查询。<br>我会尽可能简单地表述。</p><p>8086 CPU 中有14个16位寄存器 。16位的存储可以用16进制表示，BeLike：<code>123AH</code>（H表示16进制)在查看内存情况的时候，由于数据从高位到低位存储，BeLike：<code>3A 12</code></p><p><img src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="">  </p><h3 id="通用寄存器：AX，BX，CX，DX"><a href="#通用寄存器：AX，BX，CX，DX" class="headerlink" title="通用寄存器：AX，BX，CX，DX"></a>通用寄存器：AX，BX，CX，DX</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DSEG ...</span><br><span class="line">X DB 12H</span><br><span class="line">Y DB ?</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">CSEG...</span><br><span class="line">...</span><br><span class="line">MOV AH,X</span><br><span class="line">MOV Y,AH ;Y--12H</span><br></pre></td></tr></table></figure><p>可以拆分为两个寄存器使用（AH和AL），不过各自有各自的独特作用，用到再提，这和它们的名字是关联的</p><p>说到底为什么&lt;通用&gt;寄存器会有&lt;独特的作用&gt;？<br>这是因为==一些内置的指令依靠<strong>固定</strong>的寄存器传递参数==，所以这些寄存器也有了独特的作用</p><p>一般来说随便用就可以，反正里面的东西不久存，只是用来做==中转==</p><h5 id="AX：Accumlator-累加器"><a href="#AX：Accumlator-累加器" class="headerlink" title="AX：Accumlator 累加器"></a>AX：Accumlator 累加器</h5><p>特殊功能和MUL/DIV有关，后面再说</p><h5 id="BX：Base-基地址寄存器"><a href="#BX：Base-基地址寄存器" class="headerlink" title="BX：Base 基地址寄存器"></a>BX：Base 基地址寄存器</h5><p>可以存储地址并访问<br>说到地址，就得提一下汇编语言里地址的表示方法<br>在汇编语言里，内存中的地址BeLike：<code>204B:1001</code> （以16进制表示）<br><code>204B</code>是<strong>段地址</strong>，<code>1001</code>是<strong>偏移地址</strong>，各需要一个Word进行存储<br>有两个指令对应的获取内存单元的这两种地址<br>    <code>SEG</code>可以获取<strong>段地址</strong>（这个段就是指我们程序对应的段Segment），<code>OFFSET</code>可以获取<strong>偏移地址</strong><br>    使用这两个词只需要在MOV时加在变量前即可，比如<code>MOV BX offset X</code><br>在“通过地址找内容”这件事方面，一般用BX存储偏移地址<br>比如：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X DW 1234H</span><br><span class="line">Y DW ?</span><br><span class="line">...</span><br><span class="line">MOV BX, OFFSET X;BX中存储了X的偏移地址</span><br><span class="line">MOV Y, [BX];BX存储的偏移地址对应的内容被存放到y</span><br></pre></td></tr></table></figure></p><p>一般来说，<code>[BX]</code>就是指 <code>DS:[BX]</code>，默认段地址为数据段，当然你也可以指定为CS和SS</p><h5 id="CX：Count-计数器"><a href="#CX：Count-计数器" class="headerlink" title="CX：Count 计数器"></a>CX：Count 计数器</h5><p>和循环指令<code>LOOP</code>有关</p><p>LOOP指令类似于C语言中的For循环，<code>loop NAME</code>近似于<code>for(cx;;cx--)</code><br>关于LOOP的用法，具体到程序结构再说好了~。</p><h5 id="DX：Data-数据寄存器"><a href="#DX：Data-数据寄存器" class="headerlink" title="DX：Data 数据寄存器"></a>DX：Data 数据寄存器</h5><p>特殊功能和MUL/DIV有关，后面再说<br>也有与输入输出的暂存有关的功能（9.10号指令）</p><h3 id="指针变址寄存器：SP，BP，SI，DI"><a href="#指针变址寄存器：SP，BP，SI，DI" class="headerlink" title="指针变址寄存器：SP，BP，SI，DI"></a>指针变址寄存器：SP，BP，SI，DI</h3><p>都倾向于用来存地址</p><h5 id="SP：Stack-Pointer"><a href="#SP：Stack-Pointer" class="headerlink" title="SP：Stack Pointer"></a>SP：Stack Pointer</h5><p>和堆栈段的使用有关，定义堆栈段要记得手动把SP放在栈顶</p><h5 id="BP：Base-Pointer"><a href="#BP：Base-Pointer" class="headerlink" title="BP：Base Pointer"></a>BP：Base Pointer</h5><p>和BX有类似的用法，只是一般更倾向于用在堆栈的数据里，<code>[BP]</code>默认为<code>SS:[BP]</code></p><h5 id="SI：Source-Index"><a href="#SI：Source-Index" class="headerlink" title="SI：Source Index"></a>SI：Source Index</h5><h5 id="DI：Destination-Index"><a href="#DI：Destination-Index" class="headerlink" title="DI：Destination Index"></a>DI：Destination Index</h5><p>和BX有类似的用法，<code>[SI]</code>默认为<code>DS:[SI]</code><br>如果要转移数据，倾向于用SI存原地址，DI存新地址</p><h3 id="段寄存器：CS，DS，SS，ES，IP"><a href="#段寄存器：CS，DS，SS，ES，IP" class="headerlink" title="段寄存器：CS，DS，SS，ES，IP"></a>段寄存器：CS，DS，SS，ES，IP</h3><p>段的存在方便我们以==段地址+偏移地址==的方式定位内存单元<br>刚刚在例子中看到，一般的程序我们定义三个段，Data、Stack和Code，它们的作用和名字是一致的</p><p>这些寄存器都和程序段还有程序的运行有关。<br>在程序启动的时候，操作系统会把IP（Instruction Pointer）指向程序的第一句开始运行，之后IP会一直指向每次要运行的下一条指令（显然我们可以用IP玩一些花活，但是对于简单的程序，我们没有必要操作IP）</p><p>在代码段的开始，我们就用Assume语句声明CS、DS、SS的地址<br>和CS不同，DS和SS寄存器的值需要我们手动指定，而与SS寄存器绑定的SP指针也需要我们手动设置（SS:SP指向的就是栈顶元素）</p><p>ES是Extra Segment，程序有附加段落的时候才用，用法和DS SS差不多</p><h3 id="标志寄存器-FLAG"><a href="#标志寄存器-FLAG" class="headerlink" title="标志寄存器 FLAG"></a>标志寄存器 FLAG</h3><p>只是写代码的话不用管它<br>16位分开使用，有各自不同的意思，结果会以下面的形式呈现在-R中</p><p><img src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt=""></p><h1 id="阶段练习"><a href="#阶段练习" class="headerlink" title="阶段练习"></a>阶段练习</h1><p>有以上的知识已经能写很多代码。</p><h4 id="练习a-x-y"><a href="#练习a-x-y" class="headerlink" title="练习a: x+y"></a>练习a: x+y</h4><blockquote><ol><li>在数据段（data segment）中定义3个word，其中x=1234H，y=2345H, z=?</li><li>将x+y的结果保存在z中</li></ol></blockquote><h1 id="进阶指令"><a href="#进阶指令" class="headerlink" title="进阶指令"></a>进阶指令</h1><p>这里开始会有一点复杂，建议一边写一边看</p><h3 id="1-Label和Jump：跳转"><a href="#1-Label和Jump：跳转" class="headerlink" title="1. Label和Jump：跳转"></a>1. Label和Jump：跳转</h3><p>一段代码可以拥有label，Jump NAME 即可跳转至label位置<br>比如<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN：MOV X,AX</span><br><span class="line">JUMP DONE</span><br><span class="line">MOV AX,Y</span><br><span class="line">...</span><br><span class="line">DONE:</span><br><span class="line">MOV AH, 4CH</span><br><span class="line">INT 21</span><br></pre></td></tr></table></figure><br>在这段程序中，<code>MOV AX,Y</code>就会直接被跳过</p><h3 id="2-分支和循环"><a href="#2-分支和循环" class="headerlink" title="2. 分支和循环"></a>2. 分支和循环</h3><h4 id="分支-CMP-JGE-…"><a href="#分支-CMP-JGE-…" class="headerlink" title="分支 CMP-JGE/…"></a>分支 CMP-JGE/…</h4><p><img src="../../../assets/Pasted%20image%2020221206112205.png" alt=""></p><p>BeLike:(求abs(AX)保存在AX中)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">...</span><br><span class="line">CMP AX,0</span><br><span class="line">JGE DONE; Jump if Greater or Equal</span><br><span class="line">NEG AX</span><br><span class="line">DONE:</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h5 id="练习b-求最大值"><a href="#练习b-求最大值" class="headerlink" title="练习b: 求最大值"></a>练习b: 求最大值</h5><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="循环-LOOP"><a href="#循环-LOOP" class="headerlink" title="循环  LOOP"></a>循环  LOOP</h4><p>一种简单的循环，类似于<code>for(cx;;cx--)</code>。（事实上，你可以用JUMP和分支结构来实现循环）</p><p>LOOP NM过程中：</p><pre><code>0. CMP CX,01. 如果CX&gt;0，继续执行以下语句，否则跳出2. DEC CX(CX&gt;0)3. JUMP NM</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV CX,6</span><br><span class="line">NM: ...</span><br><span class="line">LOOP NM;这样写一共执行CX次（声明NM时执行1次，LOOP中执行CX-1次）</span><br></pre></td></tr></table></figure><h5 id="练习c-数组初始化"><a href="#练习c-数组初始化" class="headerlink" title="练习c: 数组初始化"></a>练习c: 数组初始化</h5><blockquote><p>在数据段（data segment）中分配100字节，并为每个字节依次赋值0-99。</p></blockquote><h3 id="3-堆栈的使用"><a href="#3-堆栈的使用" class="headerlink" title="3. 堆栈的使用"></a>3. 堆栈的使用</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>两个好用的方法</p><h5 id="比较直观的（堆栈段中做定义）"><a href="#比较直观的（堆栈段中做定义）" class="headerlink" title="比较直观的（堆栈段中做定义）"></a>比较直观的（堆栈段中做定义）</h5><ol><li>在堆栈段划分位置，保存栈顶位置</li><li>在程序段开始的时候把堆栈段的位置告诉堆栈寄存器SS，把栈顶的位置告诉指针寄存器SP</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">      STACK DW  128 dup(?)</span><br><span class="line">      TOP   DW LENGTH STACK ;划定范围</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG SEGMENT</span><br><span class="line">           ASSUME CS:CSEG,DS:DSEG,SS:SSEG</span><br><span class="line">      MAIN:</span><br><span class="line">           MOV    AX,DSEG</span><br><span class="line">           MOV    DS,AX</span><br><span class="line">           MOV    AX,SSEG</span><br><span class="line">           MOV    SS,AX</span><br><span class="line">           MOV    AX,TOP</span><br><span class="line">           MOV    SP,AX                        ;栈顶地址载入</span><br></pre></td></tr></table></figure><h5 id="稍微没那么直观的（程序段中划空间）"><a href="#稍微没那么直观的（程序段中划空间）" class="headerlink" title="稍微没那么直观的（程序段中划空间）"></a>稍微没那么直观的（程序段中划空间）</h5><p>直接给SP赋值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSEG SEGMENT</span><br><span class="line">SSEG ENDS</span><br><span class="line">;ss:0000-ss:1000</span><br><span class="line">CSEG SEGMENT</span><br><span class="line">            ASSUME CS:CSEG, DS:DSEG,SS:SSEG</span><br><span class="line">      BEGIN:MOV    AX,DSEG</span><br><span class="line">            MOV    DS,AX</span><br><span class="line">            MOV    AX,SSEG</span><br><span class="line">            MOV    SS,AX</span><br><span class="line">            MOV    SP,1000H                      ;手动规定了1000H的空置空间(OFFSET 0H-1000H)</span><br></pre></td></tr></table></figure><h4 id="PUSH和POP"><a href="#PUSH和POP" class="headerlink" title="PUSH和POP"></a>PUSH和POP</h4><p>注意：==只能操作寄存器==，不能直接操作内存单元<br><code>PUSH AX</code>：将AX的值入栈（如果AX两个字节，就会入栈两个字节，SP也相应-2）<br><code>POP AX</code>：出栈，内容保存在AX（如果AX两个字节，就会入栈两个字节，SP也相应+2）</p><h4 id="用SP和BP操作堆栈"><a href="#用SP和BP操作堆栈" class="headerlink" title="用SP和BP操作堆栈"></a>用SP和BP操作堆栈</h4><p>在主程序只是暂存数据用的话，一般==不用==操作指针<br>但是，由于PROC需要使用到堆栈段，所以这是操作指针就是必要的，接下来在PROC中解释</p><h3 id="4-lt-函数-gt-：PROC和MACRO"><a href="#4-lt-函数-gt-：PROC和MACRO" class="headerlink" title="4. &lt;函数&gt;：PROC和MACRO"></a>4. &lt;函数&gt;：PROC和MACRO</h3><h4 id="PROC-amp-CALL（子程序结构）"><a href="#PROC-amp-CALL（子程序结构）" class="headerlink" title="PROC&amp;CALL（子程序结构）"></a>PROC&amp;CALL（子程序结构）</h4><h5 id="定义-PROC-RET-ENDP"><a href="#定义-PROC-RET-ENDP" class="headerlink" title="定义 PROC-RET-ENDP"></a>定义 PROC-RET-ENDP</h5><p>(Near 属性是默认值)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIN:</span><br><span class="line">CALL NM</span><br><span class="line"></span><br><span class="line">NM PROC</span><br><span class="line">...</span><br><span class="line">RET</span><br><span class="line">NM ENDP</span><br><span class="line">...</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>完整的表达式：<br>调用：<code>CALL FAR/NEAR PTR NM</code><br>定义：<code>NM PROC FAR/NEAR</code></p><h5 id="子程序属性和调用"><a href="#子程序属性和调用" class="headerlink" title="子程序属性和调用"></a>子程序属性和调用</h5><h6 id="段内调用"><a href="#段内调用" class="headerlink" title="段内调用"></a>段内调用</h6><p>只需要Main（主Label调用）的话空置即可（默认Near）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A:...</span><br><span class="line">CALL B;调用B</span><br><span class="line"></span><br><span class="line">PROC B:...;默认为near属性子程序</span><br><span class="line">RET</span><br><span class="line">B ENDP</span><br><span class="line">...</span><br><span class="line">END A</span><br></pre></td></tr></table></figure><h6 id="段间调用"><a href="#段间调用" class="headerlink" title="段间调用"></a>段间调用</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROC A:CALL FAR PTR B</span><br><span class="line">RET</span><br><span class="line">ENDP</span><br><span class="line"></span><br><span class="line">PROC B FAR:...;写明属性</span><br><span class="line">RET ENDP</span><br></pre></td></tr></table></figure><h5 id="小心堆栈！"><a href="#小心堆栈！" class="headerlink" title="小心堆栈！"></a>小心堆栈！</h5><p>PROC的本质是：入栈程序出口指针，RET时从回到出口指针的位置<br>所以：</p><ol><li>第一个出栈元素会是一个偏移地址</li><li>如果最后SP的指针位置不对，就无法正确RET</li></ol><p>简单的方法：==用寄存器BP保护SP==，使用BP进行数据的读取</p><h6 id="例子a-1-x-y子程序化"><a href="#例子a-1-x-y子程序化" class="headerlink" title="例子a(1): x+y子程序化"></a>例子a(1): x+y子程序化</h6><blockquote><p>…</p><ol><li>在堆栈段push任意两个长度为1word的数据</li><li>使用子程序，将这两个数据的和存储于AX<br>…</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUM PROC ;取两个栈顶元素求和储存到AX中</span><br><span class="line">         MOV    BP,SP</span><br><span class="line">         MOV    AX,[BP+2]</span><br><span class="line">         ADD    AX,[BP+4]</span><br><span class="line">         RET</span><br><span class="line">SUM ENDP</span><br></pre></td></tr></table></figure><h6 id="练习b-1-求最大值-子程序化"><a href="#练习b-1-求最大值-子程序化" class="headerlink" title="练习b(1) 求最大值 子程序化"></a>练习b(1) 求最大值 子程序化</h6><blockquote><ol><li>在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?</li><li>在堆栈段push x,y,z</li><li>求max(x,y,z)储存于w</li></ol></blockquote><h4 id="Macro（宏定义）"><a href="#Macro（宏定义）" class="headerlink" title="*Macro（宏定义）"></a>*Macro（宏定义）</h4><p>PROC的使用有调用开销（程序的中断 跳转 继续），而MACRO没有<br>MACRO相当于写代码的人把重复写代码的过程交给了汇编器，相比子程序来说，是通过多占程序的内存来提高运行速度（对机器来说，每调用一次Macro，就是把这段指令重复了一次）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NM MACRO R1,R2...(参数)</span><br><span class="line">...</span><br><span class="line">END M</span><br><span class="line"></span><br><span class="line">NM MACRO AX,BX...(寄存器取值)</span><br></pre></td></tr></table></figure><h3 id="5-INT-21H指令：输入-输出"><a href="#5-INT-21H指令：输入-输出" class="headerlink" title="5. INT 21H指令：输入/输出"></a>5. INT 21H指令：输入/输出</h3><p>其实查书就可以了</p><p>到这里汇编语言编程的&lt;大局&gt;已经描述完全</p><p>关于一些语句的细节可以通过搜索引擎和汇编相关的任何书籍进行确认~</p><h4 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h4><h5 id="1号指令：单个字符输入"><a href="#1号指令：单个字符输入" class="headerlink" title="1号指令：单个字符输入"></a>1号指令：单个字符输入</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AH,1</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>(内容会保存在AL)</p><h5 id="10号指令：从键盘输入字符串"><a href="#10号指令：从键盘输入字符串" class="headerlink" title="10号指令：从键盘输入字符串"></a>10号指令：从键盘输入字符串</h5><p>内存里需要划分三个部分：<br>    1.一个字节存放最大长度（你写，溢出会被裁掉）<br>    2.一个字节存放实际长度（指令运行完CPU会写）<br>    3.一些字节用来存字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA SEGMENT</span><br><span class="line">    MAXLENGTH    DB 100           ;一个字节，用它存最大的长度</span><br><span class="line">    ACTUALLENGTH DB ?             ;一个字节，用它存实际的长度，在指令执行后会被填写</span><br><span class="line">    STRING       DB 100 DUP(?)    ;用来存字符串</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">         ASSUME DS:DATA,SS:STACK,CS:CODE</span><br><span class="line">    MAIN:</span><br><span class="line">         MOV    AX,DATA</span><br><span class="line">         MOV    DS,AX</span><br><span class="line">         MOV    DX,OFFSET MAXLENGTH         ;把需要用到的内存块（三个部分）的地址存入DX</span><br><span class="line"></span><br><span class="line">         MOV    AH,10</span><br><span class="line">         INT    21H</span><br><span class="line"></span><br><span class="line">         MOV    AH,4CH</span><br><span class="line">         INT    21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><h4 id="显示器输出"><a href="#显示器输出" class="headerlink" title="显示器输出"></a>显示器输出</h4><h5 id="2号调用：单个字符输出"><a href="#2号调用：单个字符输出" class="headerlink" title="2号调用：单个字符输出"></a>2号调用：单个字符输出</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DL,&#x27;A&#x27;</span><br><span class="line">MOV AH,2</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h5 id="9号调用：字符串输出"><a href="#9号调用：字符串输出" class="headerlink" title="9号调用：字符串输出"></a>9号调用：字符串输出</h5><p>你的字符串必须要以’$‘结尾！不然输出不会结束！（类似于’\0’，’$‘是一种字符串的终止符）<br>程序会将DS:DX地址开始输出字符到’$‘结尾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,OFFSET STRING</span><br><span class="line">MOV AH,9</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h3 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h3><h4 id="练习d-大小写转换-输入输出"><a href="#练习d-大小写转换-输入输出" class="headerlink" title="练习d. 大小写转换+输入输出"></a>练习d. 大小写转换+输入输出</h4><blockquote><p>（分支/循环/子程序+输入输出）<br>用户输入一个单词，程序将所有大写转换为小写并输出到显示器<br>(注：’a’=’A’+20H)</p></blockquote>]]></content>
    
    
    <summary type="html">帮助快速上手汇编语言编程的小教程</summary>
    
    
    
    <category term="Coding" scheme="https://floatdesu.github.io/categories/Coding/"/>
    
    
    <category term="ASM" scheme="https://floatdesu.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言 全家桶</title>
    <link href="https://floatdesu.github.io/Coding/5b511fc.html"/>
    <id>https://floatdesu.github.io/Coding/5b511fc.html</id>
    <published>2022-12-06T06:40:15.000Z</published>
    <updated>2023-01-02T14:07:00.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VScode配置调试环境"><a href="#VScode配置调试环境" class="headerlink" title="VScode配置调试环境"></a>VScode配置调试环境</h1><ol><li>安装插件TASM/MASM</li><li>右键扩展设置</li><li>右键调试即可开始调试了！</li></ol><h1 id="debug-exe使用"><a href="#debug-exe使用" class="headerlink" title="debug.exe使用"></a>debug.exe使用</h1><p><a href="https://blog.csdn.net/weixin_38633659/article/details/125166093">https://blog.csdn.net/weixin_38633659/article/details/125166093</a></p><p>Debug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。  </p><h2 id="1-Debug的常用功能"><a href="#1-Debug的常用功能" class="headerlink" title="1. Debug的常用功能"></a>1. Debug的常用功能</h2><blockquote><p>==R命令：查看、改变CPU寄存器的内容；  ==<br>==D命令：查看内存中的内容；  ==<br>E命令：改写内存中的内容：<br>U命令：将内存中的机器指令翻译成汇编指令：<br>==T命令：执行一条机器指令；  ==<br>A命令：以汇编指令的格式在内存中写入一条机器指令。<br>Q命令：退出debug<br>P命令：类似于step over（“t”命令类似于step into），可用于跳过loop循环<br>==G命令：跳过前面的代码，运行到指定的代码位置==</p></blockquote><h2 id="2-R命令"><a href="#2-R命令" class="headerlink" title="2. -R命令"></a>2. -R命令</h2><p>输入<code>r</code>：查看所有寄存器的值<br>输入<code>r 寄存器名称</code>：修改寄存器的值<br>输入<code>r ax</code>：将ax寄存器的值改为0100H<br><img src="https://img-blog.csdnimg.cn/766f633834b54ba9b27566c5b45d0287.png" alt="在这里插入图片描述"></p><h2 id="3-D命令"><a href="#3-D命令" class="headerlink" title="3. -D命令"></a>3. -D命令</h2><p>输入<code>d</code>：可以查看内存中的内容<br>输入<code>d 段地址:偏移地址</code>：查看特定位置的内存数据<br>输入<code>d 段地址:起始偏移地址 结尾偏移地址</code>：查看特定位置和特定范围的内存数据<br>输入<code>d 偏移地址</code>、 <code>d 起始偏移地址 结尾偏移地址</code>：会将DS的内容作为段地址  </p><p><img src="https://img-blog.csdnimg.cn/787cf3e1950f46f5b19fea11d0f62843.png" alt="在这里插入图片描述"></p><p>右边是每个内存单元中的数据对应的可显示的ASCII码字符，如果没有对应的ASCII字符，就显示“.”。</p><h2 id="4-E命令"><a href="#4-E命令" class="headerlink" title="4. -E命令"></a>4. -E命令</h2><p>1、输入<code>e 段地址:偏移地址 数据串</code>修改特定位置的内存数据：<br><img src="https://img-blog.csdnimg.cn/429434b7cb61433fa575ee970a227fff.png" alt="在这里插入图片描述"><br>2、输入<code>e 段地址:偏移地址</code>后按Enter也可以修改特定位置的内存数据，数据之间用空格隔开：<br><img src="https://img-blog.csdnimg.cn/361619e10b5645b8b89c055ae127ceaa.png" alt="在这里插入图片描述"></p><h2 id="5-U命令"><a href="#5-U命令" class="headerlink" title="5. -U命令"></a>5. -U命令</h2><p>输入<code>u</code>、<code>u 段地址:偏移地址</code>可以将内存中的内容翻译为对应的汇编指令：<br><img src="https://img-blog.csdnimg.cn/7e5c84f72e60412c9c4955302fcee21a.png" alt="在这里插入图片描述">由3部分组成</p><blockquote><p>1、最左边一列：是指令的地址<code>段地址:偏移地址</code><br>2、中间那一列：是指令对应的机器指令<br>3、最右边一列：是汇编指令</p></blockquote><h2 id="6-A命令"><a href="#6-A命令" class="headerlink" title="6. -A命令"></a>6. -A命令</h2><p>输入<code>a</code>、a 段地址:偏移地址<code>在这里插入代码片</code>可以从某位置开始写入汇编指令：<br><img src="https://img-blog.csdnimg.cn/0848a6e92a9b4af09de93e2d80f3fa2d.png" alt="在这里插入图片描述"></p><h2 id="7-T-执行机器指令"><a href="#7-T-执行机器指令" class="headerlink" title="7. -T 执行机器指令"></a>7. -T 执行机器指令</h2><p><img src="../../../assets/Pasted%20image%2020221201161730.png" alt=""></p><h2 id="8-G-从指定地址开始直到断点或正常结束"><a href="#8-G-从指定地址开始直到断点或正常结束" class="headerlink" title="8. -G 从指定地址开始直到断点或正常结束"></a>8. -G 从指定地址开始直到断点或正常结束</h2><p><img src="../../../assets/Pasted%20image%2020221201161736.png" alt=""></p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>本篇文章转载自 <a href="https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html">https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html</a><br>结合文章做了一些小修改，使文章更完整。</p><h2 id="1-总线"><a href="#1-总线" class="headerlink" title="1 总线"></a>1 总线</h2><p>只是想了解寄存器知识的话，只要看这一段就好：CPU与内存之间的通信采用总线的方式，其中总线又分为三种：<strong>数据总线</strong>（用来传输数据）、<strong>地址总线</strong>（确定将数据传输到什么地方）、<strong>控制总线</strong>（确定哪个设备需要传输数据）</p><p>计算机五大组成部分是：<strong>控制器、运算器、存储器、输入设备和输出设备</strong>。CPU所代表的控制器和运算器需要和存储器（主内存），以及输入设备和输出设备进行通信。通信采用的方式就是总线。</p><p>总线，其实就是一条线路。CPU、内存、以及输入和输出设备，都是通过这组线路进行相互间通信的。总线的英文叫做Bus，就是一辆公交车。这个名字很好地描述了总线的含义。我们的公交车的各个站点，就是各个接入设备（键盘、鼠标、显示器、硬盘、乃至通过USB接口连接的外部设备）。想要向一个设备传输数据，我们只要把数据放在公交车，在对应的车站将数据放下就好。</p><p>现代 Intel CPU 的体系结构里面，通常有好几条总线。</p><p>首先，<strong>CPU 和内存</strong>以及 <strong>CPU 和高速缓存</strong>之间采用不同的总线进行通信。这种方式，我们称之为双独立总线（Dual Independent Bus,DIB)。CPU 内部，有一个快速的<strong>本地总线</strong>（Local Bus)，也称之为后端总线（Back-side Bus),是 CPU 用来 和 CPU 内部的高速缓存之间进行通信，另一个速度较慢的<strong>前端总线</strong>（Front-side Bus)，也称之为处理器总线（Processor Bus)或内存总线（Memory Bus), 是 CPU 用来和主内存以及输入输出设备进行通信。  </p><p>从 CPU 硬件架构图可以看出，CPU 里面的<strong>北桥芯片</strong>，把之前说的前端总线，一分为二，变成了三个总线。前端总线其实就是系统总线。CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器（I/O Bridge)。这个 I/O 桥接器，一边接入了我们的内存总线，使得我们的 CPU 和内存通信； 另一边又接入了一个 I/O 总线，用来连接 I/O 设备。</p><p>事实上，真实的计算机里，前端总线层面拆分得更细，根据不同的设备，还会分成独立的 PCI 总线、ISA 总线等等。<br><img src="https://img-blog.csdnimg.cn/20200512104137989.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在物理层面，其实完全可以把总线看作一组”电线“。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p><ol><li><strong>数据线（Data Bus）</strong>，用来传输实际的数据,也就是公交车上实际坐的”人“。</li><li><strong>地址线（Address Bus)</strong>,用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个 I/O 设备。也即”人“要下车的站点。</li><li><strong>控制线（Control Bus)</strong>,用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这就是我们的控制信号。</li></ol><h2 id="2-CPU-发展史"><a href="#2-CPU-发展史" class="headerlink" title="2 CPU 发展史"></a>2 CPU 发展史</h2><p>Intel CPU 系列，最初是 4 位微处理器 4004，然后到到 8 位微处理器的 8008 ，再到 8 位微处理器 8080,以及稍后的 16 位微处理器 8086，由 8086 开始，Intel 进入现在所谓的 <strong>x86</strong> 时代 。Intel 8086 为 16 位 CPU ，而因为在 8086 之前的 CPU 都是 8 位 CPU，这样也就造成了很多的外设也只支持 8 位，因此 Intel 紧接着就退出了 8 位的 8088 CPU，因此 Intel 8088 也就可以看做是 8086 的 8 位版本；如果是但从汇编语言的角度上来说，8086 和 8088 是没有区别的，即 8086 上跑的程序可以不加修改的移植到 8088 ，8088 上跑的程序也可以不加修改的移植到 8086 上，当然，还是有些特殊的地方是不同的，而这些基本上在这里可以忽略掉，</p><p>在 8088 CPU 之后，Intel 又推出了 80186 ，80286 ，这两款 CPU 均是 16 位 CPU ，而对于 80186 来说，其与 8086 的区别可以简单的看做是 80186 多了几条指令而已，而 80286 则不同，80286 的地址总线数目有了变化，在 8086 , 8088 , 80186 上，CPU 的地址总线都是 20 根，即可最大寻址 2^20 即达到 1MB 的寻址能力，而对于 80286 CPU 来说，其地址总线数目达到了 24 根，从而最大寻址能力为 2^24 即 16MB，由于支持更多的物理内存寻址，因此 80286 便开始成为了多任务，多用户系统的核心。</p><p>而后来，Intel 又推出了 80386 ，80386 为 32 位微处理器，Intel 80x86 家族的 32 位微处理器始于 80386；同时 80386 也完全兼容先前的 8086/8088，80186，80286，并且 80386 全面支持 32 位数据类型和 32 位操作，并且 80386 的数据总线根数和地址总线根数均达到了 32 根，从而可以最大物理寻址为 2^32 即 4GB 。</p><p>而之后的 80486 也是 32 位微处理器，而后又出来了 Pentium 和 Pentium Pro 等等第五代微处理器，这些处理器虽然也是 32 位微处理器，但是他们的数据总线和地址总线都有所扩展，比如 Pentium 的数据总线达到 64 位，而 Pentium Pro 的地址总线位数达到了 36 位 。</p><h2 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3 寄存器"></a>3 寄存器</h2><p>寄存器是什么呢？其实很简单，寄存器就是个存储信息的单元或者说是器件又或者说是容器而已，<br>就比如内存也是一个存储介质或者说是存储单元而已，其实寄存器从理解上来说和内存差不多，</p><p>只不过寄存器（这里讨论的寄存器都是 CPU 中的寄存器，不包括外设上的寄存器）位于 CPU 内部，而内存位于 CPU 外部，</p><p>而且，寄存器比内存可是珍贵得多啊，就拿内存和硬盘来比，肯定是内存在使用上珍贵得多，是 PC 中的稀有资源，而寄存器是 CPU 中的稀有资源，内存和寄存器相比就像硬盘和内存相比一样。而对于一个汇编程序员来说，CPU 中主要可以使用的也就是寄存器而已，汇编程序员可以使用指令来读写 CPU 中的寄存器，</p><p>从而可以实现对于 CPU 的控制，当然，不同的 CPU ，寄存器的个数和结构都是不一样的，</p><p>8086 CPU 中寄存器总共为 14 个，且均为 16 位 。即 <strong>AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES</strong> 共 14 个。</p><p>而这==14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。==<br><img src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>1 通用寄存器</strong></p><p>AX，BX，CX，DX 称作为数据寄存器</p><p>AX (Accumulator)：累加寄存器，也称之为累加器；</p><p>BX (Base)：基地址寄存器；</p><p>CX (Count)：计数器寄存器；</p><p>DX (Data)：数据寄存器；</p><p>SP 和 BP 又称作为指针寄存器</p><p>SP (Stack Pointer)：堆栈指针寄存器；</p><p>BP (Base Pointer)：基指针寄存器；</p><p>SI 和 DI 又称作为变址寄存器</p><p>SI (Source Index)：源变址寄存器；</p><p>DI (Destination Index)：目的变址寄存器；</p><p><strong>2 控制寄存器</strong></p><p>IP (Instruction Pointer)：指令指针寄存器；</p><p>FLAG：标志寄存器；</p><p><strong>3 段寄存器</strong></p><p>CS (Code Segment)：代码段寄存器；</p><p>DS (Data Segment)：数据段寄存器；</p><p>SS (Stack Segment)：堆栈段寄存器；</p><p>ES (Extra Segment)：附加段寄存器；</p><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>从上面可以知道，在 8086 CPU 中，通用寄存器有 8 个，分别是 AX，BX，CX，DX，SP，BP，SI，DI ，</p><p>至于为什么给它们取名做通用寄存器，那是因为，这些个寄存器多种用途，</p><p>比如 CX 作为计数寄存器，则是在使用 LOOP 指令循环时用来指定循环次数的寄存器，</p><p>如果它们每一个都只有一个专用的作用，那就它们只能称之为专用寄存器了，</p><p>正是因为这些个寄存器还可以用来传送数据和暂存数据，所以才称它们为通用寄存器 。</p><p>下面就按顺序来一一介绍这几个通用寄存器了：</p><p><strong>数据寄存器（AX，BX，CX，DX）：</strong></p><p>数据寄存器有 AX，BX，CX，DX 四个组成，</p><p>由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，</p><p>在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，</p><p>由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了 。</p><p>AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；</p><p>BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；</p><p>CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；</p><p>DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；</p><p>除了上面 4 个数据寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 ；</p><p>注意在上面标志中的“独立”二字，这两个字表明 AH 和 AL 作为 8 位寄存器使用时，</p><p>可以看做它们是互不相关的，也就是看做两个完全没有联系的寄存器 X 和 Y 即可，</p><p>比如指令 MOV AH , 12H ，CPU 在执行时根本就不会知道 AL 中是什么鬼东西，因为它只认识 AH 。</p><p>下面给出一幅 16 位数据寄存器的结构图：</p><p>表示 16 位 寄存器 AX 可以表示成两个 8 位寄存器，</p><p>其中 AH 表示高位的 8 位寄存器，AL 表示低位的 8 位寄存器 。<br><img src="https://img-blog.csdnimg.cn/20200512111614952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><h4 id="AX-寄存器"><a href="#AX-寄存器" class="headerlink" title="AX 寄存器"></a>AX 寄存器</h4><p>如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL</p><p>AX 寄存器具有的特殊用途是在使用 DIV 和 MUL 指令时使用，</p><h5 id="DIV"><a href="#DIV" class="headerlink" title="DIV"></a>DIV</h5><p>DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的，而且除数可以存放在寄存器中或者是内存单元中，而至于被除数的话，自然，应该由 AX 来代替了，当除数是 8 位时，被除数一定会是 16 位的，并且默认是放在 AX 寄存器中，<br>而当除数是 16 位时，被除数一定是 32 位的，因为 AX 是 16 位寄存器，自然，放不下 32 位的被除数，<br>所以，在这里还需要使用另一个 16 位寄存器 DX ，其中 DX 存放 32 位的被除数的高 16 位，而 AX 则存放 32 位的被除数的低 16 位，</p><p>同时，AX 的作用还不仅仅是用来保存被除数的，当除法指令执行完成以后，如果除数是 8 位的，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数，当然，如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。</p><h5 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h5><p>当使用 MUL 做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位，如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中，</p><p>而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个 16 位的则是位于 16 的寄存器中或者是某个内存字单元中。</p><p>同时，当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中，而如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，</p><p>其中，高位默认保存在 DX 中，而低位则默认保存在 AX 中。</p><p>AX 寄存器在 DIV 指令中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,0H;设置 32 位被除数的高 16 位为 0H</span><br><span class="line">MOV AX,8H;设置 32 位被除数的低 16 位为 8H</span><br><span class="line">MOV BX,2H;设置 16 位除数为 2H</span><br><span class="line">DIV BX       ;执行计算</span><br></pre></td></tr></table></figure><p>4 条语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512112128858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>AX 寄存器在 MUL 指令中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,800H;设置 16 位乘数为 800H</span><br><span class="line">MOV BX,100H;设置 16 位乘数为 100H</span><br><span class="line">MOV DX,0H;清空用来保存乘法结果的高 16 位    </span><br><span class="line">MUL BX       ;执行计算</span><br></pre></td></tr></table></figure><p>4 条语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512112236713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><h4 id="BX-寄存器"><a href="#BX-寄存器" class="headerlink" title="BX 寄存器"></a>BX 寄存器</h4><p>首先可以明确的是，BX 作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和 AX 可以暂存一般性数据的功能是一样的，其同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即有 BH 和 BL，除了暂存一般性数据的功能外，BX 作为通用寄存器的一种，BX 主要还是用于其专属功能 – 寻址（寻址物理内存地址）上，</p><p>BX 寄存器中存放的数据一般是用来作为<strong>偏移地址</strong>使用的，何为偏移地址呢？既然是偏移地址的话，当然得有一个基地址了，而这个基地址其实就是<strong>段地址</strong>，这里就涉及到了段寄存器，当然，在介绍 BX 寄存器的时候，我不会去介绍段寄存器，上面提到 BX 的主要功能是用在寻址上，那么，其是如何寻址的呢？</p><p>而这里，我只点一下，在 8086 CPU 中，CPU 是根据 &lt;段地址：偏移地址&gt; 来进行寻址操作的，而 BX 中存放的数据表示的是偏移地址的话，自然，便可以通过 &lt;段地址：[BX]&gt; 的方式来完成寻址操作了。</p><p>为了介绍 BX 在寻址当中的作用，下面我给出一副示意图：<br><img src="https://img-blog.csdnimg.cn/20200512112423760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p><p>上面的示意图表示：可以令 BX = 2，然后通过 DS : [BX] 来访问到内存中段地址为 DS，且偏移量为 2 的内存单元了。上面介绍的这种寻址方式是 BX 在寻址中最最简单的应用了，而对于稍微复杂的寻址方式，还可以依赖于 SI，DI，BP 等寄存器来一起完成。</p><p>BX 寄存器在寻址中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV BX,5H</span><br><span class="line">MOV AH,11H</span><br><span class="line">MOV AH,[BX];设置 AX 的值为偏移地址为 BX 中的值时所代表的内存单元</span><br></pre></td></tr></table></figure><p>3 条语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512112718487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上图可以看出，在偏移地址为 5 时的内存单元中的数据位 BBH，<br><img src="https://img-blog.csdnimg.cn/20200512112848384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而从这幅图上面就可以看出，确实通过 [BX] 找到了偏移地址为 5 处的内存单元，并且将内存单元移入了 AH 中。</p><h4 id="CX-寄存器"><a href="#CX-寄存器" class="headerlink" title="CX 寄存器"></a>CX 寄存器</h4><p>CX 寄存器作为数据寄存器的一种呢，其同样具有和 AX，BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，即有 CH 和 CL 两个 8 位寄存器，</p><p>当然，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能，</p><p>当在汇编指令中使用<strong>循环 LOOP</strong> 指令时，可以通过 CX 来指定需要循环的次数，</p><p>而 CPU 在每一次执行 LOOP 指令的时候，都会做两件事：</p><p>一件就是令 CX = CX – 1，即令 CX 计数器自动减去 1；还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，</p><p>当然如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。</p><p>CX 寄存器在循环中的使用（输出 5 个白底蓝字的 A）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,0B800H</span><br><span class="line">MOV DS,AX;使用 80x25 彩色字符模式，内存地址 0xB8000 - 0xBFFFFF</span><br><span class="line">MOV BX,0;从 0xB8000 开始</span><br><span class="line">MOV CX,5H;循环 5 次</span><br><span class="line">MOV DX,41H;A 的16 进制为 41H</span><br><span class="line">MOV AX,01110001B;显示白底蓝字</span><br><span class="line">s:  MOV [BX],DX;显示 ASCII 字符</span><br><span class="line">    ADD BX,1</span><br><span class="line">    MOV [BX],AX;设置字符显示属性</span><br><span class="line">    ADD BX,1</span><br><span class="line">LOOP s</span><br></pre></td></tr></table></figure><p>语句的执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200512113302361.png" alt="在这里插入图片描述">  </p><h4 id="DX-寄存器"><a href="#DX-寄存器" class="headerlink" title="DX 寄存器"></a>DX 寄存器</h4><p>DX 寄存器作为数据寄存器的一种，同样具有和 AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，极有 DH 和 DL，同时，DX 作为一个通用寄存器的话，自然其还有其他的用途，而关于 DX 在其他方面的用途，</p><p>其实在前面介绍 AX 寄存器时便已经有所介绍了，即当在使用 DIV 指令进行除法运算时，如果除数为 16 位时，被除数将会是 32 位，而被除数的高 16 位就是存放在 DX 中，而且执行完 DIV 指令后，本次除法运算所产生的余数将会保存在 DX 中，同时，在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，那么相乘后产生的结果显然需要 32 位来保存，而这 32 位的结果的高 16 位就是存放在 DX 寄存器中。</p><p>DX 寄存器在 DIV 指令中的使用（即 2293812 / 256 = 8960 余数为 52）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,0023H;32 位被除数的高 16 位</span><br><span class="line">MOV AX,0034H;32 位被除数的低 16 位</span><br><span class="line">MOV BX,100H;16 的除数</span><br><span class="line">DIV BX  </span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/20200512113509221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><p>可以看到在语句结束以后，AX = 2300H 即十进制的 8960，而 DX = 34H即十进制的 52 和我们的结果是一致的。DX 寄存器在 MUL 指令中的使用则各位可以参考在 AX 中 MUL 运算的使用，这里就不贴出来了。</p><h4 id="指针寄存器（BP-SP）"><a href="#指针寄存器（BP-SP）" class="headerlink" title="指针寄存器（BP, SP）"></a>指针寄存器（BP, SP）</h4><p>8086 CPU 中的指针寄存器包括两个，即 SP 和 BP ，在这里呢，我先只对 BP 寄存器做介绍，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，我将会把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。</p><p>BP (Base Pointer)也就是==基指针寄存器==，它和其他的几个用来进行寻址操作所使用的寄存器（还有 BX，SI，DI）没有太大的区别。</p><p>首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用，</p><p>而后当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，那么如果在指令中没有明确或者说是显示的给出段地址时，段地址则使用默认的 SS 寄存器中的值（BX，SI，DI 会默认使用 DS 段寄存器），</p><p>比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，</p><p>所以，这里代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元，而如果单单是使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。</p><p>并且 <strong>BP 寄存器主要适用于给出堆栈中数据区的偏移，从而可以方便的实现直接存取堆栈中的数据</strong></p><p>在 8086 CPU 中，只有 4 个寄存器可以以 […] 的方式使用，这四个寄存器分别是 BX，SI，DI，BP。</p><p>下面的 Demo 是 BP 寄存器在寻址中的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV BP,0</span><br><span class="line">MOV AX,[BP]         ;将 SS:[BP] 代表的内存单元移入 AX 中</span><br><span class="line">MOV AX,CS:[BP]      ;将 CS:[BP] 代表的内存单元移入 AX 中</span><br></pre></td></tr></table></figure><p>语句的执行过程如下：<br><img src="https://img-blog.csdnimg.cn/2020051211463534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><h4 id="变址寄存器（SI，DI）"><a href="#变址寄存器（SI，DI）" class="headerlink" title="变址寄存器（SI，DI）"></a>变址寄存器（SI，DI）</h4><p>首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。</p><p>SI (Source Index) 是源变址寄存器，DI (Destination Index) 即是目的变址寄存器，</p><p>8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器，而这也就是 SI 寄存器和 DI 寄存器与BX 寄存器所不同的地方，既然，SI，DI 两个寄存器的功能和 BX 差不多，自然，SI 和 DI 中也是可以暂存一般性数据的，同时，通过使用 SI 和 DI 寄存器也是可以用来完成寻址操作的。<br>比如下面的代码就是可行的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV SI,0;初始化偏移地址为 0</span><br><span class="line">MOV AX,[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[SI];将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DI,0    ;初始化偏移地址为 0</span><br><span class="line">MOV AX,[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[DI];将段地址为 SS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure><h3 id="CS-IP-SS-SP-DS-ES-寄存器"><a href="#CS-IP-SS-SP-DS-ES-寄存器" class="headerlink" title="CS, IP, SS, SP, DS, ES 寄存器"></a>CS, IP, SS, SP, DS, ES 寄存器</h3><p>由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，我并不会单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍 。由于下面的介绍中会涉及到很多关于段和栈的概念，而段和栈的介绍又都必须关系到物理内存，所以在介绍段寄存器以及其他一些呈协作关系的寄存器之前，还是先来介绍一下这几个基本的概念比较好。</p><p><strong>8086 CPU 访问内存（物理地址）：</strong></p><p>当 CPU 需要访问一个内存单元时，需要给出内存单元的地址，而每一个内存单元在物理内存空间中都有一个唯一的地址，即可以通过这个地址定位到内存单元，而这个地址即为物理地址。CPU 通过地址总线将一个内存单元的物理地址送入存储器，而后 CPU 便可以通过这个物理地址来访问这个物理地址所指向的内存单元了。那么这个物理地址在 CPU 中是如何形成的呢？</p><p>首先，我们知道 8086 CPU 的地址总线是 20 根，即每次都可以传输 20 位的地址，从而寻址能力有 2^20 也就是 1MB 的大小，但是 8086 CPU 的寄存器只有 16 位，也就是在 8086 CPU 的内部，一次性处理，传输，暂存的地址都只能是 16 位，即 8086 CPU 不能完整的保存下一个物理地址（物理地址为 20 位），</p><p>如果单单以最简单的方式（即直接用 16 位寄存器来保存物理地址）的话，那么，寻址能力只有 2^16 ，也就是 64KB，如果真以如此简单的方式的话，那么地址总线还需要 20 根干嘛呢？而且，难不成我们以后的内存就是 64KB 了吗？</p><p>当然不是的，8086 CPU 在这里采取了一定的措施从而使其寻址能力达到 1MB 。8086 CPU 在内部通过<strong>两个 16 位的地址进行合成从而形成一个 20 位的物理地址</strong>，由此，8086 CPU 的寻址能力便可以达到 1MB 。</p><p>那么 8086 CPU 又是如何将两个 16 位的地址合成为一个20 位的物理地址的呢？当 CPU 在访问内存时，其会使用一个 <strong>16 位的基地址</strong>，然后再使用一个<strong>16 位的偏移地址</strong></p><p>通过将基地址和偏移地址传入 8086 CPU 的地址加法器中进行合成即可以构造出 20 位的物理地址。至于合成的方式如下：</p><p>基地址其实是通过一个 16 位的段地址来形成的，将一个段地址左移 4 位即形成了基地址，而至于偏移地址的话，自然不必多说，为 16 位，通过将基地址和偏移地址相加便形成了 20 位的物理地址 。</p><p>下面给出一幅示意图来表示物理地址的合成：<br><img src="https://img-blog.csdnimg.cn/20200512115455811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><h5 id="段"><a href="#段" class="headerlink" title="段"></a>段</h5><p>至于段的话，其实在物理内存中是没有段这一概念的，事实上，段的概念来自于 CPU ，因为 CPU 拥有段寄存器，既然在 CPU 中拥有了段寄存器，自然，在 CPU 中就肯定有段的概念了，其实段也就是在编程时，我们将若干个地址连续的内存单元看做是一个段，然后通过将一个段地址左移 4 位形成基地址，再通过这个基地址来定位这个段的起始地址，然后，再通过偏移地址便可以精确定位到段中的内存单元了，由于段的起始地址是一个段地址左移 4 位，</p><p>所以很明显，段的起始地址肯定是 16 的倍数，而且由于一个段内部，只能通过偏移地址来定位，而偏移地址为 16 位，所以一个段的长度也就是 2^16 也就是 64KB 的大小。</p><p>在编程时，可以讲一段内存定义成为一个段，而这里，我们又可以引出数据段，代码段，栈段这三种类型的段。何为数据段呢？其实就是我们自个儿定义一段内存（当然段起始地址肯定是 16 的倍数，并且段长度 &lt;= 64KB），</p><p>然后我们在这个段里头存放我们所需要使用的数据，这就是数据段；何为代码段呢？其实也很简单，也是我们自己在编程的时候定义一段内存，然后这段内存用来存放我们的代码（也就是指令），既然是存放的代码，自然就称之为代码段；</p><p>何为栈段呢？至于栈段的话，有接触过数据结构的朋友应该是很清楚栈的，而这里我们也就是在内存中分配出一个段，然后将这个段当做栈来使用。</p><p>首先，对于任何一个段来说，均有段地址，而这些段地址是存放在段寄存器中（段寄存器的作用也在于此），但是对于不同的段，它们默认的段地址存放在不同的段寄存器中，像数据段来说，它的段地址存放在 DS （Data Segment）寄存器中，代码段的段地址存放在 CS （Code Segment）寄存器中，栈段的段地址存放在 SS （Stack Segment）寄存器中 。</p><p>下面给出一幅在段中寻址的示意图：<br><img src="https://img-blog.csdnimg.cn/20200512115812990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的示意图中，通过将段地址左移四位，然后与偏移地址相加便可以得到 20 位的物理地址了 。</p><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>8086 CPU 中提供了对栈的支持，并且其还提供了相应的指令来以栈的方式访问内存空间 。</p><p>什么是栈？通过上面在段中的介绍，栈其实就是一个段，再说白一点，也就是一块内存，当然，这块内存是一块连续的内存 。</p><p>既然栈是一个段的话，那么当然就可以以使用段的方式来使用栈，当然，除了像段一样的使用栈以外，栈还提供了其特殊的访问方式。</p><p>众所周知，栈是先进后出类型的数据结构，在 8086 CPU 中也是如此，可以通过==PUSH==指令将数据压入栈中，然后再通过==POP==指令将栈顶的元素取出来 。</p><p>下面给出一幅示意图来描述栈：<br><img src="https://img-blog.csdnimg.cn/20200512115902282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p><p>即通过 PUSH 10 来将元素 10 放入栈中，因为，先前栈中没有任何数据，所以，10 就会作为栈顶元素存在，然后再在栈中压入元素 20 ，此时，栈顶中的元素就是 20 了，然后再使用 POP 指令将栈顶元素取出，此时取出的栈顶元素是 20 ，取出 20 后，栈中便只剩下 10 了，自然 10 就成为了栈顶，最后再通过 POP 指令将栈顶 10 取出，此时，栈便变成了空栈了 。</p><p>好了，在介绍段寄存器之前的基础知识介绍就到这里了，下面开始正式介绍段寄存器以及与它们协作使用的寄存器。</p><h5 id="CS-寄存器-和-IP-寄存器"><a href="#CS-寄存器-和-IP-寄存器" class="headerlink" title="CS 寄存器 和 IP 寄存器"></a>CS 寄存器 和 IP 寄存器</h5><p>经过前面对段的介绍，相信各位朋友对段寄存器应该也有一定的了解了，下面将要介绍的是一组非常非常重要的寄存器，即 CS:IP 。CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而 IP 为指令指针寄存器 。</p><p>什么叫做指示了 CPU 当前将要读取的指令呢？在 8086 CPU 中，为什么 CPU 会自动的执行指令呢？这些指令肯定是存放在内存中的，但是 CPU 怎么知道这些指令存放在内存的那个位置呢？</p><p>比如，我有下面的两条指令要执行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,1234H</span><br><span class="line">MOV BX,AX</span><br></pre></td></tr></table></figure></p><p>而假设这两条指令在内存中存放为：<br><img src="https://img-blog.csdnimg.cn/20200512120040942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很显然， 1000H:0000H 指向的是 MOV AX，1234H 的首地址，如果 CPU 要读取到我的指令的话，很显然，必须要知道地址 1000H:0000H ，然后 CPU 就可以根据这个首地址，将汇编指令 MOV AX，1234H 所对应的机器码读入到 CPU 的指令寄存器中，最后便可以在 CPU 中进行处理了。</p><p>但关键是 CPU 如何知道我的 1000H:0000H 这个首地址？其实这就需要使用到 CS:IP 这个寄存器组了 。</p><p>当我们运行一个可执行文件时，很明显，我们需要另外一个程序来将这个可执行文件加载到内存当中，关于这个加载可执行文件的程序，我们在这里不管他，点一下即可，一般是通过操作系统的外壳程序（也就是传说中的 Shell 程序），Shell 将可执行文件加载到内存中以后，就会设置 CPU 中的两个寄存器，即设置 CS:IP 两个寄存器指向可执行文件的起始地址，此后 CPU 便从这个起始地址开始读取内存中的指令，并且执行，</p><p>比如我们在写汇编程序时，通常会使用 START 标记，其实这个标记就是用来标记起始地址的，当将一个汇编程序编译，连接成可执行文件以后，再通过操作系统的 Shell 程序将可执行文件加载到内存中以后，这个 START 所标记处的地址就是整个可执行文件的起始地址了 。</p><p>也就是说，当一个可执行文件加载到内存中以后，CS:IP 两个寄存器便指向了这个可执行文件的起始地址，然后 CPU 就可以从这个起始地址开始往下读取指令，<strong>当读取完指令后，CS:IP 将会自动的改变，基本上是改变 IP ，从而指向下一条要读取的指令</strong>，这样就可以执行这个可执行文件了 。</p><p>最后再对 CS:IP 总结一下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.你想让  CPU  执行哪行指令，你就让  CS:IP  指向保存有指令的那块内存即可。</span><br><span class="line">2.任何时候，CS:IP  指向的地址中的内容都是  CPU  当前执行的指令。</span><br></pre></td></tr></table></figure><p>下面我们来看一个 Demo，并详细观察其执行的过程：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,1234H</span><br><span class="line">    MOV BX,AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200512120435345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面的截图中可以看出，当我使用 Shell （在 DOS 下也就是 Command 命令解释器）将可执行文件加载进内存后，可以看到，整个程序的起始地址为 0C54H : 0000 H ，并且，可以看到 CS 的地址为 0C54H ，IP 的地址为 0000H，这正好吻合我们上面对 CS:IP 的分析，很明显，CPU 将会读取 <code>MOV AX ，1234H</code> 到 CPU 中并且执行 ，</p><p>然后我们继续向下看：<br><img src="https://img-blog.csdnimg.cn/20200512120624853.png" alt="在这里插入图片描述"><br>可以看到，我们单步执行后，AX 中的值编成了 1234H ，而 IP 寄存器中的值变成了 0003H，对于 AX 中的值的改变，我们是能够理解的，但是 IP 中的值为什么会从 0000H 变到 0003H 呢？</p><p>从最上面的一幅关于指令在内存中的存放可以看出 <code>MOV AX ，1234H</code> 在内存中需要 3 个内存单元存放，也就是 CPU 为了执行 <code>MOV AX ，1234H</code> 这条指令，已经将内存中相对应的 3 个内存单元读入内存中了，执行完这条指令后，自然，CPU 就要将偏移地址向下移动 3 个单元，从而使得 CS:IP 指向下一条需要执行的指令了 ，</p><p>为了更深刻的理解，我们再来继续看执行过程，<br><img src="https://img-blog.csdnimg.cn/20200512121004851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从最上面的一幅关于指令在内存中的存放可以看出 <code>MOV BX ，AX</code> 在内存中只占 2 个内存单元，</p><p>这也就是为什么 IP 这一次只向下移动了 2 个单元的缘故 。</p><p>关于 CS: IP 的遐想：</p><p>从上面关于 CS:IP 的介绍中，我们可以大胆的猜想，我们<strong>只需要通过手动的改变 CS:IP 所指向的内存地址，让 CS:IP 指向我们另外的代码，那么我们就可以让 CPU 执行我们自己指定的代码了</strong>。即可以通过修改 CS:IP 来达到我们想要让 CPU 干什么它就干什么的目的 。</p><p>上面的虽然是遐想，但是大家要相信，我们写的是汇编，不是 JAVA 也不是 NET ，所以我们还真的可以达到上面的目的，也就是说我们的遐想其实是可以实现的，当然这还是有一定的限制的 ，</p><h5 id="SS-寄存器和-SP-寄存器"><a href="#SS-寄存器和-SP-寄存器" class="headerlink" title="SS 寄存器和 SP 寄存器"></a>SS 寄存器和 SP 寄存器</h5><p>在底层涉及的是栈在内存中的具体实现 。</p><p>不知道，大伙有没有注意笔者在本篇博文的上面介绍关于栈的知识时，我并没有提到如何找到这个栈，我只提到了一个栈就是先进后出操作，同时可以使用 ”PUSH“ 和 ”POP“ 指令，然后就是稍微带了一下 SS 这个寄存器的介绍，</p><p>我们虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给 CPU 使用的，既然 CPU 要使用的话，自然，CPU 又必须根据一定的方式找到这个栈，而这就需要使用 SS 和 SP 寄存器了 。</p><p>同时，一个栈也就是一块内存区域，通过上面的介绍，我们也知道了如果要在一块内存中精确地定位到内存单元的话（寻址），我们必须要有<strong>基地址（也就是段地址左移 4 位）和偏移地址</strong>，自然，要在一个栈中寻址的话，也需要段地址和偏移地址，</p><p>而对于一个栈来说，我们使用的最多的是什么呢？</p><p>当然是==栈顶==了，因为只有栈顶可以用来存取数据，所以对于一个栈来说，我们只需要有栈顶的段地址和偏移地址即可，而对于栈顶的段地址，其是存放在段寄存器 SS 中的，而对于栈顶的偏移地址，其则是存放在 SP 寄存器中的 。</p><p>==在任何时刻，SS:SP 都是指向栈顶元素==。</p><p>其实关于栈的使用还是比较简单的，但是要注意的是 8086 CPU 并不会保证我们对栈的操作会不会越界 。所以我们在使用栈的时候需要特别注意栈的越界问题 。</p><p>当使用 <code>PUSH</code> 指令向栈中压入 1 个字节单元时，SP = SP - 1；即栈顶元素会发生变化；</p><p>而当使用 <code>PUSH</code> 指令向栈中压入 2 个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；</p><p>当使用 <code>POP</code> 指令从栈中弹出 1 个字节单元时， SP = SP + 1；即栈顶元素会发生变化；</p><p>当使用 <code>POP</code> 指令从栈中弹出 2 个字节单元的字单元时， SP = SP + 2 ；即栈顶元素会发生变化；</p><p>下面通过一个 Demo 来介绍栈的使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,1000H;首先是定义好栈的段地址</span><br><span class="line">    MOV SS,AX    </span><br><span class="line">    MOV AX,10H;再定义好栈的长度（初始时刻的栈顶偏移地址即栈的长度）</span><br><span class="line">    MOV SP,AX</span><br><span class="line">    </span><br><span class="line">    MOV AX,0001H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0002H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0003H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0004H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0005H</span><br><span class="line">    PUSH AX</span><br><span class="line">    </span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>然后我们来看栈在内存中的结构图：<br><img src="https://img-blog.csdnimg.cn/202005121216254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>语句的执行过程如下：<br>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="https://img-blog.csdnimg.cn/20200512121658415.png" alt="在这里插入图片描述"><br>然后我们再来依次执行上述指令：<br><img src="https://img-blog.csdnimg.cn/20200512121714142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上副截图中可以看出已经设置好了 SS:SP ，也就是栈已经设置 OK 了，</p><p>下面开始往栈中压入数据了，<br><img src="https://img-blog.csdnimg.cn/2020051212201138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于我们压入栈中的数据为字数据，即占 2 个内存单元，所以，每次 SP = SP – 2 ；</p><p>将 5 个字型数据压入栈中后，我们可以来查看栈中的数据了，<br><img src="https://img-blog.csdnimg.cn/20200512122055548.png" alt="在这里插入图片描述"><br>因此，在内存中的一个好看点的结构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200512122124897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面开始进行出栈操作了<br><img src="https://img-blog.csdnimg.cn/2020051212215010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于我们弹出栈时的数据为字数据，即占 2 个内存单元，所以，每次 SP = SP + 2 ；</p><p>将 5 个字型数据全部弹出栈中后，我们可以来查看栈中的数据了，<br><img src="https://img-blog.csdnimg.cn/20200512122206915.png" alt="在这里插入图片描述"><br>可以看到 SP 变成了初始状态了，也就是说栈中所有的数据已经全部弹出了，虽然我们查看内存时看到的不是 0 ，</p><p>但是我们看到的这些数据都是无效的，我们这里不理会 。</p><h5 id="DS-寄存器和-ES-寄存器"><a href="#DS-寄存器和-ES-寄存器" class="headerlink" title="DS 寄存器和 ES 寄存器"></a>DS 寄存器和 ES 寄存器</h5><p>DS 寄存器和 ES 寄存器都属于段寄存器，其实它们和 CS 寄存器以及 SS 寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了 。</p><p>通过上面对基础知识的介绍呢，我们已经知道，如果 CPU 要访问一个内存单元时，我们必须要提供一个指向这个内存单元的物理地址给 CPU，而我们也知道在 8086 CPU 中，物理地址是由段地址左移 4 位，然后加上偏移地址形成的，所以，我们也就只需要提供段地址和偏移地址即 OK 。8086 CPU 呢，提供了一个 DS 寄存器，并且通常都是通过这个 DS 段寄存器来存放要访问的数据的段地址 。</p><p>DS（Data Segment）：很显然，DS 中存放的是数据段的段地址 。</p><p>但是这里不得不再点一下，那就是我们对段的支持是在 CPU 上体现的，而不是在内存中实现了段，所以事实上我们使用的段其实是一个逻辑概念，即是我们自己定义的，再说白了，我定义一个段，我说它是数据段那它就是数据段，我说它是代码段那么它就是代码段，它们其实都是一块连续的内存而已，至于为什么要区分为数据段和代码段，很明显，是用来给我们编程提供方便的，即我们在自己的思想上或者说是编码习惯上规定，</p><p>数据放数据段中，代码放代码段中 。而我们在使用数据段的时候，为了方便或者说是代码的编写方便起见，我们一般把数据段的段地址放在 DS 寄存器中，当然，如果你硬要觉得 DS 不顺眼，那你可以换个 ES 也是一样的，</p><p>至于 ES（Extra Segment） 段寄存器的话，自然，是一个附加段寄存器，如果再说得过分点，就当它是个扩展吧，当你发现，你几个段寄存器不够用的时候，你可以考虑使用 ES 段寄存器，在使用方式上，则和其他的段寄存器没什么区别 。</p><p>下面看一个介绍使用 DS 寄存器的 Demo：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">    MOV AX,1000H</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    MOV AL,1</span><br><span class="line">    MOV BX,0</span><br><span class="line">    </span><br><span class="line">    MOV CX,5;设计一个循环，让其循环 5 次</span><br><span class="line">    s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">       INC AL</span><br><span class="line">       INC BX</span><br><span class="line">       LOOP s            </span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><p>上面的代码所做的事情，就是循环将 1，2，3，4，5 写入到地址 1000H：0000H ，1000H：0001H，1000H：0002H，1000H：0003H，1000H：0004H 中，</p><p>语句的执行过程如下：<br>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img src="https://img-blog.csdnimg.cn/20200512122513469.png" alt="在这里插入图片描述"><br>而当循环执行完成以后，我们再来看内存 1000H：0000H 处的值：</p><p>在这里，我们可以看到确实达到了我们预期的效果，但是大家注意看代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">   INC AL</span><br><span class="line">   INC BX</span><br><span class="line">   LOOP s  </span><br></pre></td></tr></table></figure><p>这里可以看到，我们在 [BX] 中并没有给其指定段地址，而只有一个偏移地址，但是根据我们一开始的介绍，必须要有段地址和偏移地址才能够定位内存单元，</p><p>莫非这里出问题了？其实不是的，因为我们在最前面定义了段地址 DS 为 1000H，<strong>当我们定义好段地址后，每一次 CPU 执行到 [BX] 时，便会自动或者说是默认的从 DS 中取值</strong>，并且将取得的值作为段地址，因此，当 [BX] 为 0001H 时，CPU 会从 DS 中取得一个 1000H ，由这两个一合成即可以得到正确的物理地址 1000H：0000H 。</p><p>最后还提醒一点，那就是 8086 CPU <strong>不支持直接将一个数据送入段寄存器</strong>中，</p><p>也就是下面的做法是错误的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DS,1000H</span><br></pre></td></tr></table></figure><h5 id="标志寄存器-FLAG"><a href="#标志寄存器-FLAG" class="headerlink" title="标志寄存器 FLAG"></a>标志寄存器 FLAG</h5><p>前面呢，已经介绍了 8086 CPU 14 个寄存器中的 13 个了，下面我们将介绍最后一个寄存器也就是 FLAG 寄存器，FLAG 寄存器之所以放到最后一个介绍，是因为其和其他的一些寄存器不同，像 AX，BX，CX，DX 这些寄存器来说，它们都是用来存放数据的，当然 FLAG 中存放的也是数据啦，不过，AX，BX 这些寄存器中的数据是作为一个整体使用的，</p><p>最多也就分成一个 AL 和 AH 使用而已，<strong>但是在 FLAG 中，数据是按位起作用的，也就是说，FLAG 中的每一个位都表示不同的状态，由于一个位也就能表示 0 和 1</strong> ，自然，FLAG 中的每一个位就是用来描述状态的，而且 FLAG 寄存器中存储的信息通常又被称作程序状态字（PSW） 。</p><p>下面我给出一幅 FLAG 寄存器中各个位的示意图：<br><img src="https://img-blog.csdnimg.cn/20200512122743736.png" alt="在这里插入图片描述"><br>从上面这幅图中可以看出，FLAG 的第 0 个位表示的是 CF ，第 2 个位表示的是 PF ，与此类推 . . . .<br>首先，我们来看一个列表：<br><img src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的这个表怎么看呢？我们通过看下面一幅截图就知道了 。<br><img src="https://img-blog.csdnimg.cn/20200512122828929.png" alt="在这里插入图片描述"><br>从上面的标记中可以看出，从左到右依次代表 OF，DF，SF，ZF，PF，CF 标志位的值，</p><p>至于为什么我们在 Debug 模式下，使用 R 命令时，只会列出这几个标志位，我猜的话是因为相对来说，列出的这几个标志位更为常用，其他的几个标志位并不经常使用的缘故吧 。</p><p>下面我们就按不同的位来分别介绍这些位所描述的状态，以及它们代表的意义：  </p><p><strong>CF（Carry FLag） - 进位标志（第 0 位）：</strong></p><p>CF： 进位标志是用来反映计算时是否产生了由低位向高位的<strong>进位</strong>，或者产生了从高位到低位的<strong>借位</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算过程中产生了进位或者借位)</span><br><span class="line">        CF  =  1;</span><br><span class="line">else</span><br><span class="line">        CF  =  0;</span><br></pre></td></tr></table></figure><p><strong>PF（Parity FLag） - 奇偶标志（第 2 位）：</strong><br>PF： 奇偶标志是用来记录相关指令执行后，其结果的所有的 Bit 位中 1 的个数是否为偶数 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算结果中 1 的个数为偶数)</span><br><span class="line">        PF  =  1;</span><br><span class="line">else</span><br><span class="line">        PF  =  0;</span><br></pre></td></tr></table></figure><p><strong>AF（Auxiliary Carry FLag） - 辅助进位标志（第 4 位）：</strong><br>AF： 用来辅助进位标志 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(字节操作中发生低半个字节向高半个字节借位或者进位  ||  字操作中发生低字节向高字节借位或者进位)</span><br><span class="line">       AF = 1;</span><br><span class="line">else</span><br><span class="line">       AF = 0;</span><br></pre></td></tr></table></figure><p><strong>ZF（Zero FLag） – 零标志（第 6 位）：</strong><br>ZF： 记录的是相关的指令执行完毕后，其执行的结果是否为 0 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(执行的结果  ==  0)</span><br><span class="line">       ZF = 1;</span><br><span class="line">else</span><br><span class="line">       ZF = 0;</span><br></pre></td></tr></table></figure><p><strong>SF（Sign FLag） - 符号标志（第 7 位）：</strong><br>SF： 符号标志，其记录相关指令执行完以后，其结果是否为负数 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算结果为负数)</span><br><span class="line">        SF  =  1;</span><br><span class="line">else</span><br><span class="line">        SF  =  0;</span><br></pre></td></tr></table></figure><p><strong>TF（Trap FLag） - 追踪标志（第 8 位）：</strong></p><p>TF： 追踪标志，主要是用于调试时使用 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(TF  ==  1)</span><br><span class="line">       CPU 进入单步方式;</span><br></pre></td></tr></table></figure><p><strong>IF（Interrupt-Enable FLag） - 中断允许标志（第 9 位）：</strong></p><p>IF： 中断允许标志，其决定 CPU 是否能够响应外部可屏蔽中断请求（以后会做详细介绍） 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(IF  ==  1)</span><br><span class="line">        CPU 能够响应外部的可屏蔽中断请求;</span><br><span class="line">else</span><br><span class="line">        CPU 不能够响应外部的可屏蔽中断请求;</span><br></pre></td></tr></table></figure><p><strong>DF（Direction FLag） - 方向标志（第 10 位）：</strong></p><p>DF： 方向标志，其用于在串处理指令中，用来控制每次操作后 SI 和 DI 是自增还是自减 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(DF == 0)</span><br><span class="line">        SI++,DI++;</span><br><span class="line">else</span><br><span class="line">        SI--,DI--;</span><br></pre></td></tr></table></figure><p><strong>OF（OverFlow FLag） - 溢出标志（第 11 位）：</strong></p><p>OF： 溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算发生溢出)</span><br><span class="line">OF  =  1;</span><br><span class="line">else</span><br><span class="line">OF  =  0;</span><br></pre></td></tr></table></figure><h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>什么都不干顺下来就是顺序</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h3><p>利用Count寄存器CX存储循环次数，每次运行LOOP指令，将会执行：</p><ol><li>DEC CX（CX自减）</li><li>JUMP:MULTI</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS: CODESG</span><br><span class="line"></span><br><span class="line">CODESG SEGMENT</span><br><span class="line"></span><br><span class="line">    MAIN:  </span><br><span class="line">           MOV AX,2</span><br><span class="line">           MOV CX,11</span><br><span class="line">           MULTI:ADD AX,1</span><br><span class="line">           LOOP MULTI</span><br><span class="line">           </span><br><span class="line">           MOV AX,4C00H</span><br><span class="line">           INT 21H</span><br><span class="line"></span><br><span class="line">CODESG ENDS</span><br><span class="line"></span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure><p>利用分支和JUMP循环</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="PROC（中断跳转）"><a href="#PROC（中断跳转）" class="headerlink" title="PROC（中断跳转）"></a>PROC（中断跳转）</h3><h3 id="小心SP的变化！"><a href="#小心SP的变化！" class="headerlink" title="小心SP的变化！"></a>小心SP的变化！</h3><p>首先：<br>cpu执行call指令时，相当于执行了（push ip） 和 （jmp near ptr 标号）：<br>(sp)=(sp)−2<br>((ss)∗16+(sp))=(ip)<br>(ip)=(ip)+16位位移</p><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<br>cpu执行ret指令时，(相当于pop ip)：<br>(ip)=((ss)∗16+(sp))<br>(sp)=(sp)+2</p><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。<br>cpu执行retf指令时，(相当于pop ip 和 pop cs)：<br>(ip)=((ss)∗16+(sp))<br>(sp)=(sp)+2<br>(cs)=((ss)∗16+(sp))<br>(sp)=(sp)+2</p><p>注：<br>SS是堆栈段寄存器，SP是堆栈指针寄存器。<br>SS <em> 16表示堆栈段的段地址（即堆栈段的起始地址），SS </em> 16+SP则表示堆栈的栈顶位置（地址）。<br><img src="../../../assets/Pasted%20image%2020221201185743.png" alt=""></p><p>以上述代码段为例，调用过程为：<br>ip会指向下一条指令000E，<br><strong>将此时的000E推入push进栈，</strong><br>因为call指令 (ip)=(ip)+16位位移 修改了ip的值，<br>相当于实现了段内跳转，<br>此时的位移： mov ax,4c00h（3个字节） 和 int 21h（2个字节） 两条指令，共5个字节，<br>所以ip = 000Eh + 0005h = 0013h, 刚好是 标号s 处地址，成功实现跳转。</p><p>此时成功跳转后，ip先指向下一条指令0015，<br>然后执行add指令，<br>执行成功后ip再指向下一条指令，这时会发现程序段中没有可指向的指令，但是仍会有指向，<br><strong>之后就会执行ret指令，将栈顶的000E出栈并用ip接收，</strong><br>这时就会发现无论之前的ip是多少，执行完ret后都会被覆盖，成功实现了跳转。</p><p>原文链接：<a href="https://blog.csdn.net/orange_monkey/article/details/106380255">https://blog.csdn.net/orange_monkey/article/details/106380255</a></p><h3 id="伪代码（可传参）"><a href="#伪代码（可传参）" class="headerlink" title="伪代码（可传参）"></a>伪代码（可传参）</h3>]]></content>
    
    
    <summary type="html">到处收集的汇编语言教程</summary>
    
    
    
    <category term="Coding" scheme="https://floatdesu.github.io/categories/Coding/"/>
    
    
    <category term="ASM" scheme="https://floatdesu.github.io/tags/ASM/"/>
    
  </entry>
  
  <entry>
    <title>银之冠·碧之泪</title>
    <link href="https://floatdesu.github.io/Tavg/SakuraR/bc91ebd0.html"/>
    <id>https://floatdesu.github.io/Tavg/SakuraR/bc91ebd0.html</id>
    <published>2022-12-02T16:37:46.000Z</published>
    <updated>2023-01-02T14:07:00.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><p>总评：你在渴望着什么样的爱呢</p><ul><li>标签：R/现代/职场</li><li>篇幅：短篇</li><li>推荐：4/5</li><li>*故事强度：4+/5（5-清水 1-拔作）</li><li>*口味刺激性：2/5（5-离谱 1-清水）<strong>（高浓度 NTR 警告!!!）</strong></li></ul><p><strong>故事背景</strong>（<strong>プロローグ</strong>）：</p><blockquote><p>千岁是个独居女OL，在酒店前台工作，正在与公司职员慎一郎恋爱中。故事的起点即是慎一郎与千岁求婚、千岁在犹豫着是否进入婚姻。其实，她和慎一郎很少见面，两个人都在工作上非常认真，她的工作决定了她不规则的工作时间、慎一郎则需要频繁的不定期出差，这也是她犹豫的原因之一。不过，后来千岁还是答应了，二人过上一段时间非常温馨的婚后生活。然而，好景不长，之后意外之事频繁地发生……</p></blockquote><p><strong>简评</strong></p><p>说到NTR，这可能会牵扯到很复杂的伦理问题，比如说婚姻关系中又遇到恋爱对象、婚姻关系不和睦的情况遇到恋爱对象。。。之类的。。不能说一段不成功的婚姻一定就得绑定一辈子吧，，可是要是误会呢，要是有一方多想呢。。什么什么什么的。。。（）这里我就绕开这点谈，因为我也不是很明白……又或者说这种事情里好坏完全就是模糊集吧，就是特别好和特别坏能分清楚，剩下的话只能按有些好的有些坏的这么谈了……</p><p>有的事可能局外的人看起来是离谱的，可是局内的人这么行动可能又是完全合乎情理的（…）但是合乎情理和对错好坏也不是能混为一谈的概念……</p><p>尤其是玩完这个游戏以后加强了我这种想法……刚开始我也觉得基本上应该是能分得出好坏的，这可是（）这还行（）这怎么能（）感觉谁这个做的不好谁那个又做的不好，可是后来想想我又并不是谁，不同的人就是会有不同的对事情的感受、考虑和处理事情的办法，用好不好、对不对之类的说法简单去评价感觉很困难呢……（不过我私心还是主要站女主角啦xd）</p><p>好复杂哦。总之，故事里的人是差不多合乎情理的吧……没有很重的强行NTR的感觉……</p><p>==但是还是不建议感情洁癖的玩家去尝试了==（或者这个能某种程度上治疗感情洁癖。。吗。。。。）</p><p>关于人物情感的表现也非常出色和细腻~后面细说~~</p><p>只是在氛围感上，由于故事的很大一部分埋没在OL女主角有点枯燥的生活里，没有很特别的地方，使得这个游戏有点缺乏自己的特色，不过这何尝不是一种特色（？）或者说，故事最大的特点就是平凡，男女主全员都是有些特点的普通的人，故事的环境也是普通中的普通，而慎一郎所做的事情、一件Routine中的意外、设定了故事发生的背景。虽然不知道是不是这样的故事真能发生在现实中，但是我觉得它也不乏合理性，在爱与婚姻的方面或许能给我们带来一些特别的感想吧（或许）。</p><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><h3 id="1-分线写点想写的"><a href="#1-分线写点想写的" class="headerlink" title="1. 分线写点想写的"></a>1. 分线写点想写的</h3><h4 id="a-千岁-amp-慎一郎"><a href="#a-千岁-amp-慎一郎" class="headerlink" title="a. 千岁&amp;慎一郎"></a>a. 千岁&amp;慎一郎</h4><p>慎一郎确实做得过分吧，对千岁完全实施保密主义，在网络时代连个简讯都不怎么愿意发……</p><p>不排除这可能是我这种对方没有秒回就会焦虑得要死的地雷元素阿宅的想法，或许就是有人是不太喜欢表达的吧……（默默想了一下我爸，一种很喜欢一发信息发几十行的中年男子，摇了摇头….我身边好像还真没有，草）</p><p>还是说只有小孩子才会觉得恋爱就是要天天联系天天发消息天天贴贴……我不觉得啊！至少在这个环节里，千岁体现出来的对能确认亲密关系的行为的需求在正常范围内，可是远远比慎一郎提供的一星半点要多。</p><p>而且，就算不能贴贴不能频繁联系，我坚信恋爱这种亲密关系的维持是以真诚坦诚多交流为基础的，解释一下总是可以的吧！！明明知道千岁不安的原因是什么，为什么一句都不愿意多解释，就看着她在那里沉浸在幻想的恐惧终吗，你也会雇保镖去守护千岁的人身安全呀，为什么不能关心一下千岁的心理感受呢……</p><p>受不了你了绿帽哥！！你完全是自作自受——！你这样除非你老婆真的是个逆来顺受的洋娃娃，就像你的线里一样每天上班下班回家等你，无条件的爱你理解你等待你，即使不安也相信你，肯定是会失去你老婆的啊……白痴吗你是……</p><p>或者说，千岁会走上NTR的道路，首先就是慎一郎对千岁缺乏她所必须的关怀，然后才是千岁自己有点纤细敏感。虽然直接走歪的鬼畜线我有点不能接受，但是她在受到幻想敌的凝视和伤害、不被新婚的丈夫关心和爱的恐惧中变得很脆弱，让她变得很脆弱因此迫切地想要找到可以依赖也会爱她的存在（一种感觉很容易坏掉的状态……），这听上去完全合乎情理吧……</p><p>我根本就不觉得千岁和慎一郎合适啊……不合适得有点难受的婚姻还是早点结束掉吧。甚至没领证，更方便了（。）还有千岁，还是不要那么草率地进入一段婚姻比较好吧……而且我一直不理解千岁到底喜欢慎一郎哪里，鬼畜线即使有点神经质地、以有点扭曲地方式在身体上索求着被爱的证明，依然强调着、看起来不太像是向自己强调这自己爱着慎一郎……</p><p>NTR作品看得实在太少了，同样感情脆弱的对象我只能想起来安乐冈花火……好像喜欢描写女性因为对自己被爱的能力没有安全感而病急乱投医（似乎我也能理解的样子）但是这样写起来太难过了。不过，故事里其他的对象我觉得都比慎一郎看起来顺眼，千岁这个医投得好像问题也不大，嘿嘿，就是过程折磨了一点。</p><p>说点题外的，我同情千岁，但是说不上对千岁……。明明在职场上做得那么好，是大家都敬佩的前辈，但是在爱情里看起来太不安脆弱、委曲求全了一点……而且，千岁的生活太单调了，也可能成为了她的脆弱的原因之一吧……我感受不到她在生活中有什么很喜欢做的事情，（虽然她自己说网购，但这只能说是让人高兴但是说不上是爱好吧……），看不到她对自己的生活有什么热情和希望，而是在婚后下意识地就完全在心理上依附于家庭生活，所以慎一郎对她所期望的生活的每一点背离都是对她沉重的伤害……也看不到她有什么好朋友，和自己的好朋友们有什么开心的生活。</p><p>我还是希望女主角能靠自己就把自己的生活过好呢，即使没有爱情也要能够开开心心地生活下去的那种。如果我是千岁的朋友的话，就带她一起打乙女游戏吧！！（？）要是她也喜欢的话，说不定就好朋友（我）和爱好（乙女游戏）都有了！！（？？）</p><h4 id="b-榛名诚"><a href="#b-榛名诚" class="headerlink" title="b. 榛名诚"></a>b. 榛名诚</h4><p>超喜欢的角色！……啊啊啊！！</p><blockquote><p>榛名：那个，因为姐姐你并不是很想结婚，所以这么说可能也并非出于本意。不过有的事情不做做看就不会知道吧?<br>千岁：话虽如此，但万一结婚后却发现不行，不是就无法挽回了吗?<br>榛名：正常地生活，然后发生无法挽回的事情，有那么常见吗? 只要活着的话怎样都行。这种思考方式不是也有吗?</p><p>榛名：姐姐，好像对得不到帮助这种事习以为常了呢。<br>千岁：……<br>榛名：还是说害怕?害怕被拒绝?<br>千岁：……<br>榛名：他的话锋太过尖锐，我不由倒吸口冷气。<br>确实，是这样。相信能被理解，期待得到帮助，却始终落空。每次都失望，已经习惯了放弃。<br>太悲惨了。而且，很悲哀…..<br>榛名：我说，必须要做那么善解人意的女人吗？我并不认为姐姐是在胡闹。那种程度，可以看做是在撒娇。</p></blockquote><p>喜欢他每天元气满满地面对兼职的快递工作，和大家都关系很好，（虽然自来熟得有点轻浮……（大概是剧情安排吧2333））喜欢他敏锐地发现千岁的不安、陪伴在千岁身边却不索求任何东西（好难过啊，不要白给啊年轻人qwq），喜欢他拉起大提琴的时候眼里有光的样子（虽然我也没有直接看到）。喜欢他笑起来的时候清脆的声音，喜欢他（）的时候压低的声音。</p><blockquote><p>榛名：大提琴的声音啊，是和人的声音非常接近的。因此如果用心去演奏，这家伙就会代替我歌唱。刚才，是以请姐姐振作起来的心情来演奏的。感觉到了吗?<br>千岁：嗯，感觉到了。<br>榛名：还有，最喜欢姐姐了!这样的心情也放进去了…..</p></blockquote><p>以及他这个人……成长历程顺风顺水锋芒毕露，直到让人感觉不适以后才收敛一点，也为此离开了家（唉…）；想要挑战所以学了不擅长的大提琴，一直这样拉着琴进了音乐学院，毕业了以后一边打工一边找乐团里的工作（因为位置很少所以很难找），独自住在海边不通电的小屋。一直没意识到自己喜欢音乐，直到自己有可能失去音乐。</p><p>我有过这样的梦哦，中学的时候吧，那个时候学钢琴也学得挺痛苦的，感觉对钢琴就是毫无感情（），能弹而已，赶紧考完业余的最高级就不学了，但是有天晚上突然梦见自己的手臂（不说具体了，有点血/腥……），早上醒来感觉那个手都还是麻的，第一反应不是什么生活不便也不是什么不能写作业而是不能弹琴……那个时候我突然意识到可能我也还挺喜欢弹琴的。后来看了番剧四月谎，对钢琴的感觉更复杂了（）不过高中以后寄宿，到现在很久很久没有碰琴了，感觉也就慢慢淡了。</p><p>啊肯定没有诚的感触这么深啦，毕竟人家可是pro，不过这个故事让我想起了很有感慨的东西，不然我很久都不会想起来这件事了。还有顺风顺水什么的……我也谈不上一直很顺，大考唯一一次顺估计就是高考了，我的锋芒毕露都还没维持到被别人提醒要收敛的时候（。）但是不知道为什么我好像能理解诚的感受呢。</p><p>而且诚虽然很厉害但是看起来却很亲切！或者说，第一次认识诚就是从一个很亲切的角度，不是从他是个很会拉琴的人的角度，感觉他完全就是个普通的少年、不会有看到巨佬那种“啊、努力的天才！好厉害！不过我们的理解和感情可能存在巨大的鸿沟……”的又尊敬又有点想要退后的感觉。这样超棒的啊！</p><p>只是剧情里有个点比较难受。那天千岁在犹豫着留下他陪伴自己还是让他去尝试参加那个挺重要的比赛的时候。这并不是一个“要恋爱对象还是要追求梦想”的选择，其实感觉没那么严重，不陪女朋友女朋友也顶多就是不安一段时间（但是你们其实可以发消息的……），不去参加这个比赛的话以后也会有很多别的比赛，女朋友的选择就是一个可以刷好感（？）的地方……可是在这里却成为一个完全的转折点，明明只是一次性的选择却成为了一生的决定……</p><blockquote><p>我固执的将自己囚禁于寂寞之中，完全没有理会过榛名的事。正因为我什么都不管，榛名一定背负着许多痛苦和辛酸。<br>但是他却想要独自克服一切。<br>所以他演奏的音乐才如此坚强，因为懂得悲伤，所以才能这样温柔。<br>(……榛名)<br>我喜欢他的大提琴。喜欢他，喜欢到落泪。</p></blockquote><p>或者，希望他追求梦想的想法代表着一个愿意努力变得坚强的千岁，千岁会逐渐从失败的感情中恢复过来，然后两个人一起走向光明的未来；希望他留下来的想法代表着一个极端脆弱的千岁，即使留下来也无法缓解千岁的不安了，爱着千岁的诚放弃了一次比赛也就还会有下一次、一次又一次逐渐也就把对大提琴的爱也舍弃了……这份感情也就此背上了可能非常沉重的“代价”……</p><p><img src="assets/Pasted%20image%2020221218003529.png" alt=""></p><p>还是拉着琴的诚最帅啦！青春最美好的还是追求理想而闪闪发光的样子呀！！</p><p>c. 和泉亮</p><p>突然发现我喜欢的全是故事里的年下系（<em>嘿嘿地笑了</em>）可能我还是比较排斥“大人らしい”的恋爱吧……</p><p>但是亮也很可爱诶！虽然这个人设好像有点普通没很多好说的（感觉是现实中也会存在的类型呢？）认真得有点固执的清纯男大学生（来了，某博主的二次元xp），但是也不会令人讨厌的刻板，感觉恰到好处……</p><p>等等，开了这个头发现真的没什么好说的。放绿江文就是标准的年下小狼狗设定啊（）不过这是好多好多年前的作品，那个时候可能没这么烂大街吧（沉思）可是这个人设它就算再烂大街写好了也还是香啊！！！呜呜呜。</p><p>亮，和我什么时候一起去吃拉面吧！！那个拉面真的听上去好好吃，能让我嗦一口吗qwq</p><p>d. 浅野&amp;神尾</p><p>年上系二人~一个无条件温柔得有点吓人，另一个对恋爱的需求有点大人气得吓人（）我都不感冒！！因为我喜欢！小孩子的恋爱！（？）</p><p>还有神尾我是真的不懂，对已经动心的女主狠心拒绝，过了两个月又逮住街上偶遇的女主激情告白……知道你是和自己内心斗争了，好吧，但是神尾感觉是个纯渣男啊，回心转意的原因完全不明，只是可能对之前的女孩子没有激情告白而已吧……我不知道，呜呜，我不懂，我只是觉得痛哭的千岁好惨，刚跟前夫吵完，又被新喜欢的人甩掉……</p><h3 id="2-总评"><a href="#2-总评" class="headerlink" title="2. 总评"></a>2. 总评</h3><p>本来想写一篇认真的评价的，但是不知道为什么就写得欢脱起来（最近好像都没写什么特别欢脱的评价呢？）……</p><p>想了很久给3+还是4-还是4虽然这几个没什么大区别，就是我觉得格局还是一股经典乙女游戏调调，女主虽然写了职场OL人设依然是每天情啊爱啊没有这些就过不下去了的样子，不过它讨论的东西确实是得R18才比较适合去理解吧……或者说主题正在与婚姻和爱和NTR，所以女主也是一个这种典型的脆弱的例子才行，故事才能这样展开？好像也有合理性……不过，比起一些少女童话，这本显然是要实在很多了（）而且有一些剧情也合理得让我有点小感动，这个就很棒啦。而且如果是因为少女童话感觉乏味的话，玩一下这个应该也很有趣吧！（虽然我也喜欢看少女童话，但是随着看的数目逐渐增多我也开始有点审美疲劳了……）</p><p>说到最后还是，希望女主这样的女孩子能找到属于且只属于自己的生活吧。把生活都围绕着男人和家庭确实是一种选择，可是万一选错了，那也太难过了。（）能够完全互相托付的爱情和婚姻我相信是存在的，可是一下子押上这样的赌注感觉有点危险呢……还是确保自己就算是一个人也能把生活过得丰富精彩比较好吧。（我觉得）还有，碰到慎一郎这种讲不通道理又不关心人的，要么想办法努力撬开他嘴（？）然后磨合磨合继续过日子，要么认识到不合适不接受早点润吧……</p>]]></content>
    
    
    <summary type="html">4/5 你在渴望着什么样的爱呢</summary>
    
    
    
    <category term="Tavg" scheme="https://floatdesu.github.io/categories/Tavg/"/>
    
    <category term="SakuraR" scheme="https://floatdesu.github.io/categories/Tavg/SakuraR/"/>
    
    
  </entry>
  
  <entry>
    <title>黑蝶幻境</title>
    <link href="https://floatdesu.github.io/Tavg/Sakura/5c602a3a.html"/>
    <id>https://floatdesu.github.io/Tavg/Sakura/5c602a3a.html</id>
    <published>2022-11-24T05:20:02.000Z</published>
    <updated>2023-01-02T14:07:00.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无剧透篇"><a href="#无剧透篇" class="headerlink" title="无剧透篇"></a>无剧透篇</h2><p>总评：在幻境中寻找自我与真相</p><ul><li>标签：架空</li><li>推荐：4/5</li><li>篇幅：中短篇</li></ul><p><strong>故事背景</strong>（<strong>プロローグ</strong>）：</p><blockquote><p>不明原因使得几人在失去记忆的情况下在一栋小洋楼中苏醒，要面对的是在建筑中游荡的怪物群。在这里，情感和思想能够转化为实质，他们在路遇的狐狸面具少年的战斗方式的启发下也利用“幻想”的手枪开始战斗。战败的怪物会化作黑色的蝴蝶散去，留下一种&lt;碎片&gt;。根据他们随身携带的手机上的信息，只要收集足够的&lt;碎片&gt;修复&lt;万花筒&gt;就能回到原来的世界……</p></blockquote><p><strong>简评</strong></p><ol><li>总体上逻辑自洽，主线剧情节奏也相当不错</li><li>只是以flowchart为主导的系统除了主线也有很多琐碎的短篇，每一篇单独阅读比较破碎和繁琐（但是也不是很不好，就是一些音乐听的太多了感觉人比较麻……）</li><li>全都不分线地喜欢女主（）（）（也不是什么……就是有点怪不好意思的……（？））女主是那种典型的温柔博爱型（有点审美疲劳了x）</li></ol><h2 id="剧透篇"><a href="#剧透篇" class="headerlink" title="剧透篇"></a>剧透篇</h2><p>碎碎念：太好了，这游戏从打完到写repo又晾了大半个月，我的记忆正在快速褪色中……有的时候高密度打了很多个游戏，但是一时间又写不完repo，结果就像任务一样压在肩上让人很有排斥感（），现在还剩好多部（明明不是必须写的，可是，如果不写的话按我这个打的密度和忘的速度，会真正做到打过和没打过一样……）</p><h4 id="1-主线评价"><a href="#1-主线评价" class="headerlink" title="1. 主线评价"></a>1. 主线评价</h4><p>讲述了两次意外的故事。</p><p>黑蝶幻境是其中一次，让数年不愿相见或未能相见的几人重新相识、再次相聚，在探索的过程中逐渐发现另一次意外的真相，那几乎夺走了他们中两人的生命的一场意外，让剩下三个人自此背上不愿直面的&lt;罪&gt;，无法走出过去的阴影。</p><p>某种意义上，就好结局而论，可称为对余下三人的一种救赎吧……救赎的故事。</p><h4 id="2-写点想写的"><a href="#2-写点想写的" class="headerlink" title="2. 写点想写的"></a>2. 写点想写的</h4><h5 id="鉤翅-夏樹"><a href="#鉤翅-夏樹" class="headerlink" title="鉤翅 [夏樹]"></a>鉤翅 [夏樹]</h5><p>看上去是完美的温柔的青梅竹马…这种完美程度甚至会让人怀疑是否是那种游戏经典的切开黑……事实上，虽然说不上切开很黑，但是至少里面满满的是悲伤和痛苦吧。（声优太蛊了太蛊了，呜呜呜，好贴好贴！！）</p><p>他对绯影说，如果能够回到现实的话，他可以做一切能做的事情。在大家的背后，执着地追逐着所爱的身影，也因此与紋白分道……在有愿望又有希望（即使是虚假的）的情况下，封锁在这个洋楼里十多年，这样的执着怎么样能不变质啊。</p><p>能在所爱之人的面前维持最后的完美与温柔，并不是看上去那么轻松吧。花费多少自制力才能做得到呢。</p><p>可是游戏里，和已经死掉的人是没办法有真正意义上的好结局的。毕竟已经死掉的人，即使离开幻境，也没有归处了。要是那个雨天的夏树没有死在水里，他一定会和爱过上童话一样的幸福的生活的吧。IF线是真甜呀呜呜呜，可惜是IF……</p><p>真官配，也是真be…最让人叹惋的一条线。</p><h5 id="紋白-和也"><a href="#紋白-和也" class="headerlink" title="紋白 [和也]"></a>紋白 [和也]</h5><p>像是、实际上也是一簇连游荡的原因都已经忘却的游魂……拿着象征着执念的缎带，不知道从哪里来、也不知道是想要到哪里去。对爱孩子气的依恋并没有夏树那么重，也不愿意接受洋楼主人的约定，孤独地在洋楼里来去徘徊。</p><p>爱会伸手把他再次抱紧，接纳他的孤独与不安，接纳他再次展露的孩子气的依恋。作为友人也好，作为恋人也好。出于亏欠也好，出于同情也好，出于仍未消散的友情也好，还是出于爱恋，爱不在意，和也也不会在意了。只要此刻怀抱尚温，他就会像个孩子一样靠近过去。是啊，他本来也就是个孩子啊。和夏树一样，他们的时间早已在十多年前暂停了。</p><p>只是他的时间还能再续。他在现实还有归处，还能有一个与大家一同前进的未来。真好啊。（夏树：qaq）</p><h5 id="緋影"><a href="#緋影" class="headerlink" title="緋影"></a>緋影</h5><p>这位才是真疯皮（）关在这么个房子里！肯定是迟早会精神有点问题的啊！！！而且他关了那——么久啊（）</p><p>在这段漫长的时光开始之前，他就已经把自己的名字和样貌丢失了，也不再能想起，只记得要修复万花筒这件事。（虽然万花筒也是他自己打碎的……）连一直执念复活的妹妹就在身边也无法意识到。然后在漫长的时光里，一直把无辜的人拖下水替他寻找碎片……</p><p>怎么说…喜欢不起来啊（实在有点太疯了）再想想他和妹妹那段往事，妥妥的病娇啊（），惨是真的惨，狠也是真的狠，洗不白的那种（）我共情力下线了……</p><h5 id="山都-拓也-，鸦翅-明"><a href="#山都-拓也-，鸦翅-明" class="headerlink" title="山都[拓也]，鸦翅[明]"></a>山都[拓也]，鸦翅[明]</h5><p>二位我都不太有感（）虽然细谷和柿子都很萌是没错啦x</p><p>但是，被死掉的人完全绊住步伐十几年让我觉得很难受……那个事情是很难过，可是人总要往前看的呀。比起想着昨天做错了什么怎么做会更好，不如考虑怎么样弥补自己的错误、怎么样过好明天……（是我比较自私吗？）不去后悔应该算是我的一个强行设置的一个人生信条了……沉溺于后悔除了让人连第二天都过不好以外没有意义啊。</p><h3 id="3-和姐妹篇-lt-灰鹰幻境-gt"><a href="#3-和姐妹篇-lt-灰鹰幻境-gt" class="headerlink" title="3. 和姐妹篇&lt;灰鹰幻境&gt;"></a>3. 和姐妹篇&lt;灰鹰幻境&gt;</h3><p>感觉都是“人设 恋爱&lt;&lt;故事”的游戏，也是罕见的单线乙女游戏，游戏的设置就是让故事围绕探索主线去展开，而不是围绕着恋爱与人物展开。对人物的了解、恋爱关系的产生都是建立在故事的基础上的。</p><p>相比来说，黑蝶的故事更简单完整，灰鹰更复杂一点、只是半途加入很多魔幻设定让故事显得有点微妙。人设和恋爱上我觉得半斤八两，都是放了几个月就会让我几乎不记得多少的程度（……）但是灰鹰的女主朱德我更喜欢一点，感觉比爱的完美的博爱温柔更讨喜。</p><p>就是，还是觉得这两部在人设和恋爱上都没有做到很让人满意……不过，放眼到主流的人设与恋爱为主的众多乙女游戏，其中很多在主线的完整和自洽、以及探索主线的剧情节奏上都比不上黑蝶，女主每次都从头开始探索故事的内核，玩家明明有所了解却也要跟随女主的步伐，可是作为多视角游戏的优点（能够在不同的线里发掘不一样角度的真相，拼凑成一个完整的故事）由于对剧本要求比较高，也没有能体现出来，只不过是把同样的“真相”重复了一次又一次而已。</p><p>这里就体现出了单线乙女游戏的好处（）。不管怎么说，还是很希望看到各种各样的丰富形式的乙女游戏的~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;无剧透篇&quot;&gt;&lt;a href=&quot;#无剧透篇&quot; class=&quot;headerlink&quot; title=&quot;无剧透篇&quot;&gt;&lt;/a&gt;无剧透篇&lt;/h2&gt;&lt;p&gt;总评：在幻境中寻找自我与真相&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标签：架空&lt;/li&gt;
&lt;li&gt;推荐：4/5&lt;/li&gt;
&lt;li&gt;篇幅：</summary>
      
    
    
    
    <category term="Tavg" scheme="https://floatdesu.github.io/categories/Tavg/"/>
    
    <category term="Sakura" scheme="https://floatdesu.github.io/categories/Tavg/Sakura/"/>
    
    
  </entry>
  
</feed>
