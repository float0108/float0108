<!DOCTYPE html>
<html lang='zh-CN'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>汇编语言 全家桶 - 極楽浄土</title>

  
    <meta name="description" content="到处收集的汇编语言教程">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言 全家桶">
<meta property="og:url" content="https://float0108.github.io/Coding/5b511fc.html">
<meta property="og:site_name" content="極楽浄土">
<meta property="og:description" content="到处收集的汇编语言教程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/766f633834b54ba9b27566c5b45d0287.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/787cf3e1950f46f5b19fea11d0f62843.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/429434b7cb61433fa575ee970a227fff.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/361619e10b5645b8b89c055ae127ceaa.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7e5c84f72e60412c9c4955302fcee21a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/0848a6e92a9b4af09de93e2d80f3fa2d.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020221201161730.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020221201161736.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512104137989.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512111614952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512112128858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512112236713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512112423760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512112718487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512112848384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512113302361.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512113509221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020051211463534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512115455811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512115812990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512115902282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512120040942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512120435345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512120624853.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512121004851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202005121216254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512121658415.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512121714142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020051212201138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122055548.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122124897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020051212215010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122206915.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122513469.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122743736.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200512122828929.png">
<meta property="og:image" content="https://float0108.github.io/assets/Pasted%20image%2020221201185743.png">
<meta property="article:published_time" content="2022-12-06T06:40:15.000Z">
<meta property="article:modified_time" content="2023-01-02T14:07:00.666Z">
<meta property="article:author" content="AleryXiao">
<meta property="article:tag" content="ASM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/766f633834b54ba9b27566c5b45d0287.png">
  
  

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="極楽浄土" type="application/atom+xml">
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  
    <link rel="shortcut icon" href="/site_assets/favicon.jpg">
  

  

  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/site_assets/head.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">極楽浄土</div><div class="sub normal cap">フロトの理发店</div><div class="sub hover cap" style="opacity:0"> @AleryXiao</div></a></div>

<nav class="menu dis-select"><a class="nav-item active" href="/">posts</a><a class="nav-item" href="/wiki/">collection</a><a class="nav-item" href="/about/">about</a></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">汇编语言 全家桶</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Debug%E7%9A%84%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">1. Debug的常用功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-R%E5%91%BD%E4%BB%A4"><span class="toc-text">2. -R命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-D%E5%91%BD%E4%BB%A4"><span class="toc-text">3. -D命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-E%E5%91%BD%E4%BB%A4"><span class="toc-text">4. -E命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-U%E5%91%BD%E4%BB%A4"><span class="toc-text">5. -U命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-A%E5%91%BD%E4%BB%A4"><span class="toc-text">6. -A命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-T-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">7. -T 执行机器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-G-%E4%BB%8E%E6%8C%87%E5%AE%9A%E5%9C%B0%E5%9D%80%E5%BC%80%E5%A7%8B%E7%9B%B4%E5%88%B0%E6%96%AD%E7%82%B9%E6%88%96%E6%AD%A3%E5%B8%B8%E7%BB%93%E6%9D%9F"><span class="toc-text">8. -G 从指定地址开始直到断点或正常结束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%80%BB%E7%BA%BF"><span class="toc-text">1 总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CPU-%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">2 CPU 发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">3 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">通用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AX-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">AX 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DIV"><span class="toc-text">DIV</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MUL"><span class="toc-text">MUL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BX-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">BX 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CX-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">CX 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DX-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">DX 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88BP-SP%EF%BC%89"><span class="toc-text">指针寄存器（BP, SP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88SI%EF%BC%8CDI%EF%BC%89"><span class="toc-text">变址寄存器（SI，DI）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CS-IP-SS-SP-DS-ES-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">CS, IP, SS, SP, DS, ES 寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AE%B5"><span class="toc-text">段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CS-%E5%AF%84%E5%AD%98%E5%99%A8-%E5%92%8C-IP-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">CS 寄存器 和 IP 寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SS-%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C-SP-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">SS 寄存器和 SP 寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DS-%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C-ES-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">DS 寄存器和 ES 寄存器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8-FLAG"><span class="toc-text">标志寄存器 FLAG</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F"><span class="toc-text">顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-text">分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LOOP%E6%8C%87%E4%BB%A4"><span class="toc-text">LOOP指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PROC%EF%BC%88%E4%B8%AD%E6%96%AD%E8%B7%B3%E8%BD%AC%EF%BC%89"><span class="toc-text">PROC（中断跳转）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E5%BF%83SP%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%81"><span class="toc-text">小心SP的变化！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8F%AF%E4%BC%A0%E5%8F%82%EF%BC%89"><span class="toc-text">伪代码（可传参）</span></a></li></ol></li></ol></div></div></widget>




</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="http://wpa.qq.com/msgrd?v=3&uin=2498742177&site=qq&menu=yes" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="\site_assets\qqIcon.png"/></a><a class="social" href="https://space.bilibili.com/19610138" target="_blank" rel="external nofollow noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="\site_assets\bilibiliIcon.png"/></a><a class="social" href="mailto:aleryxiao@163.com" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="\site_assets\mailIcon.png"/></a></div></footer>

    </aside>
    <div class='l_main'>
      

      


<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a><span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/Coding/">Coding</a></div><div id="post-meta">发布于&nbsp;<time datetime="2022-12-06T06:40:15.000Z">2022-12-06</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>汇编语言 全家桶</span></h1>
<h1 id="VScode配置调试环境"><a href="#VScode配置调试环境" class="headerlink" title="VScode配置调试环境"></a>VScode配置调试环境</h1><ol>
<li>安装插件TASM/MASM</li>
<li>右键扩展设置</li>
<li>右键调试即可开始调试了！</li>
</ol>
<h1 id="debug-exe使用"><a href="#debug-exe使用" class="headerlink" title="debug.exe使用"></a>debug.exe使用</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38633659/article/details/125166093">https://blog.csdn.net/weixin_38633659/article/details/125166093</a></p>
<p>Debug是DOS、Windows都提供的实模式(8086方式)程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。  </p>
<h2 id="1-Debug的常用功能"><a href="#1-Debug的常用功能" class="headerlink" title="1. Debug的常用功能"></a>1. Debug的常用功能</h2><blockquote>
<p>==R命令：查看、改变CPU寄存器的内容；  ==<br>==D命令：查看内存中的内容；  ==<br>E命令：改写内存中的内容：<br>U命令：将内存中的机器指令翻译成汇编指令：<br>==T命令：执行一条机器指令；  ==<br>A命令：以汇编指令的格式在内存中写入一条机器指令。<br>Q命令：退出debug<br>P命令：类似于step over（“t”命令类似于step into），可用于跳过loop循环<br>==G命令：跳过前面的代码，运行到指定的代码位置==</p>
</blockquote>
<h2 id="2-R命令"><a href="#2-R命令" class="headerlink" title="2. -R命令"></a>2. -R命令</h2><p>输入<code>r</code>：查看所有寄存器的值<br>输入<code>r 寄存器名称</code>：修改寄存器的值<br>输入<code>r ax</code>：将ax寄存器的值改为0100H<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/766f633834b54ba9b27566c5b45d0287.png" alt="在这里插入图片描述"></p>
<h2 id="3-D命令"><a href="#3-D命令" class="headerlink" title="3. -D命令"></a>3. -D命令</h2><p>输入<code>d</code>：可以查看内存中的内容<br>输入<code>d 段地址:偏移地址</code>：查看特定位置的内存数据<br>输入<code>d 段地址:起始偏移地址 结尾偏移地址</code>：查看特定位置和特定范围的内存数据<br>输入<code>d 偏移地址</code>、 <code>d 起始偏移地址 结尾偏移地址</code>：会将DS的内容作为段地址  </p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/787cf3e1950f46f5b19fea11d0f62843.png" alt="在这里插入图片描述"></p>
<p>右边是每个内存单元中的数据对应的可显示的ASCII码字符，如果没有对应的ASCII字符，就显示“.”。</p>
<h2 id="4-E命令"><a href="#4-E命令" class="headerlink" title="4. -E命令"></a>4. -E命令</h2><p>1、输入<code>e 段地址:偏移地址 数据串</code>修改特定位置的内存数据：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/429434b7cb61433fa575ee970a227fff.png" alt="在这里插入图片描述"><br>2、输入<code>e 段地址:偏移地址</code>后按Enter也可以修改特定位置的内存数据，数据之间用空格隔开：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/361619e10b5645b8b89c055ae127ceaa.png" alt="在这里插入图片描述"></p>
<h2 id="5-U命令"><a href="#5-U命令" class="headerlink" title="5. -U命令"></a>5. -U命令</h2><p>输入<code>u</code>、<code>u 段地址:偏移地址</code>可以将内存中的内容翻译为对应的汇编指令：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/7e5c84f72e60412c9c4955302fcee21a.png" alt="在这里插入图片描述">由3部分组成</p>
<blockquote>
<p>1、最左边一列：是指令的地址<code>段地址:偏移地址</code><br>2、中间那一列：是指令对应的机器指令<br>3、最右边一列：是汇编指令</p>
</blockquote>
<h2 id="6-A命令"><a href="#6-A命令" class="headerlink" title="6. -A命令"></a>6. -A命令</h2><p>输入<code>a</code>、a 段地址:偏移地址<code>在这里插入代码片</code>可以从某位置开始写入汇编指令：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/0848a6e92a9b4af09de93e2d80f3fa2d.png" alt="在这里插入图片描述"></p>
<h2 id="7-T-执行机器指令"><a href="#7-T-执行机器指令" class="headerlink" title="7. -T 执行机器指令"></a>7. -T 执行机器指令</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020221201161730.png" alt=""></p>
<h2 id="8-G-从指定地址开始直到断点或正常结束"><a href="#8-G-从指定地址开始直到断点或正常结束" class="headerlink" title="8. -G 从指定地址开始直到断点或正常结束"></a>8. -G 从指定地址开始直到断点或正常结束</h2><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020221201161736.png" alt=""></p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>本篇文章转载自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html">https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html</a><br>结合文章做了一些小修改，使文章更完整。</p>
<h2 id="1-总线"><a href="#1-总线" class="headerlink" title="1 总线"></a>1 总线</h2><p>只是想了解寄存器知识的话，只要看这一段就好：CPU与内存之间的通信采用总线的方式，其中总线又分为三种：<strong>数据总线</strong>（用来传输数据）、<strong>地址总线</strong>（确定将数据传输到什么地方）、<strong>控制总线</strong>（确定哪个设备需要传输数据）</p>
<p>计算机五大组成部分是：<strong>控制器、运算器、存储器、输入设备和输出设备</strong>。CPU所代表的控制器和运算器需要和存储器（主内存），以及输入设备和输出设备进行通信。通信采用的方式就是总线。</p>
<p>总线，其实就是一条线路。CPU、内存、以及输入和输出设备，都是通过这组线路进行相互间通信的。总线的英文叫做Bus，就是一辆公交车。这个名字很好地描述了总线的含义。我们的公交车的各个站点，就是各个接入设备（键盘、鼠标、显示器、硬盘、乃至通过USB接口连接的外部设备）。想要向一个设备传输数据，我们只要把数据放在公交车，在对应的车站将数据放下就好。</p>
<p>现代 Intel CPU 的体系结构里面，通常有好几条总线。</p>
<p>首先，<strong>CPU 和内存</strong>以及 <strong>CPU 和高速缓存</strong>之间采用不同的总线进行通信。这种方式，我们称之为双独立总线（Dual Independent Bus,DIB)。CPU 内部，有一个快速的<strong>本地总线</strong>（Local Bus)，也称之为后端总线（Back-side Bus),是 CPU 用来 和 CPU 内部的高速缓存之间进行通信，另一个速度较慢的<strong>前端总线</strong>（Front-side Bus)，也称之为处理器总线（Processor Bus)或内存总线（Memory Bus), 是 CPU 用来和主内存以及输入输出设备进行通信。  </p>
<p>从 CPU 硬件架构图可以看出，CPU 里面的<strong>北桥芯片</strong>，把之前说的前端总线，一分为二，变成了三个总线。前端总线其实就是系统总线。CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器（I/O Bridge)。这个 I/O 桥接器，一边接入了我们的内存总线，使得我们的 CPU 和内存通信； 另一边又接入了一个 I/O 总线，用来连接 I/O 设备。</p>
<p>事实上，真实的计算机里，前端总线层面拆分得更细，根据不同的设备，还会分成独立的 PCI 总线、ISA 总线等等。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512104137989.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在物理层面，其实完全可以把总线看作一组”电线“。不过呢，这些电线之间也是有分工的，我们通常有三类线路。</p>
<ol>
<li><strong>数据线（Data Bus）</strong>，用来传输实际的数据,也就是公交车上实际坐的”人“。</li>
<li><strong>地址线（Address Bus)</strong>,用来确定到底把数据传输到哪里去，是内存的某个位置，还是某一个 I/O 设备。也即”人“要下车的站点。</li>
<li><strong>控制线（Control Bus)</strong>,用来控制对于总线的访问。虽然我们把总线比喻成了一辆公交车。那么有人想要做公交车的时候，需要告诉公交车司机，这就是我们的控制信号。</li>
</ol>
<h2 id="2-CPU-发展史"><a href="#2-CPU-发展史" class="headerlink" title="2 CPU 发展史"></a>2 CPU 发展史</h2><p>Intel CPU 系列，最初是 4 位微处理器 4004，然后到到 8 位微处理器的 8008 ，再到 8 位微处理器 8080,以及稍后的 16 位微处理器 8086，由 8086 开始，Intel 进入现在所谓的 <strong>x86</strong> 时代 。Intel 8086 为 16 位 CPU ，而因为在 8086 之前的 CPU 都是 8 位 CPU，这样也就造成了很多的外设也只支持 8 位，因此 Intel 紧接着就退出了 8 位的 8088 CPU，因此 Intel 8088 也就可以看做是 8086 的 8 位版本；如果是但从汇编语言的角度上来说，8086 和 8088 是没有区别的，即 8086 上跑的程序可以不加修改的移植到 8088 ，8088 上跑的程序也可以不加修改的移植到 8086 上，当然，还是有些特殊的地方是不同的，而这些基本上在这里可以忽略掉，</p>
<p>在 8088 CPU 之后，Intel 又推出了 80186 ，80286 ，这两款 CPU 均是 16 位 CPU ，而对于 80186 来说，其与 8086 的区别可以简单的看做是 80186 多了几条指令而已，而 80286 则不同，80286 的地址总线数目有了变化，在 8086 , 8088 , 80186 上，CPU 的地址总线都是 20 根，即可最大寻址 2^20 即达到 1MB 的寻址能力，而对于 80286 CPU 来说，其地址总线数目达到了 24 根，从而最大寻址能力为 2^24 即 16MB，由于支持更多的物理内存寻址，因此 80286 便开始成为了多任务，多用户系统的核心。</p>
<p>而后来，Intel 又推出了 80386 ，80386 为 32 位微处理器，Intel 80x86 家族的 32 位微处理器始于 80386；同时 80386 也完全兼容先前的 8086/8088，80186，80286，并且 80386 全面支持 32 位数据类型和 32 位操作，并且 80386 的数据总线根数和地址总线根数均达到了 32 根，从而可以最大物理寻址为 2^32 即 4GB 。</p>
<p>而之后的 80486 也是 32 位微处理器，而后又出来了 Pentium 和 Pentium Pro 等等第五代微处理器，这些处理器虽然也是 32 位微处理器，但是他们的数据总线和地址总线都有所扩展，比如 Pentium 的数据总线达到 64 位，而 Pentium Pro 的地址总线位数达到了 36 位 。</p>
<h2 id="3-寄存器"><a href="#3-寄存器" class="headerlink" title="3 寄存器"></a>3 寄存器</h2><p>寄存器是什么呢？其实很简单，寄存器就是个存储信息的单元或者说是器件又或者说是容器而已，<br>就比如内存也是一个存储介质或者说是存储单元而已，其实寄存器从理解上来说和内存差不多，</p>
<p>只不过寄存器（这里讨论的寄存器都是 CPU 中的寄存器，不包括外设上的寄存器）位于 CPU 内部，而内存位于 CPU 外部，</p>
<p>而且，寄存器比内存可是珍贵得多啊，就拿内存和硬盘来比，肯定是内存在使用上珍贵得多，是 PC 中的稀有资源，而寄存器是 CPU 中的稀有资源，内存和寄存器相比就像硬盘和内存相比一样。而对于一个汇编程序员来说，CPU 中主要可以使用的也就是寄存器而已，汇编程序员可以使用指令来读写 CPU 中的寄存器，</p>
<p>从而可以实现对于 CPU 的控制，当然，不同的 CPU ，寄存器的个数和结构都是不一样的，</p>
<p>8086 CPU 中寄存器总共为 14 个，且均为 16 位 。即 <strong>AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES</strong> 共 14 个。</p>
<p>而这==14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。==<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512110737331.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>1 通用寄存器</strong></p>
<p>AX，BX，CX，DX 称作为数据寄存器</p>
<p>AX (Accumulator)：累加寄存器，也称之为累加器；</p>
<p>BX (Base)：基地址寄存器；</p>
<p>CX (Count)：计数器寄存器；</p>
<p>DX (Data)：数据寄存器；</p>
<p>SP 和 BP 又称作为指针寄存器</p>
<p>SP (Stack Pointer)：堆栈指针寄存器；</p>
<p>BP (Base Pointer)：基指针寄存器；</p>
<p>SI 和 DI 又称作为变址寄存器</p>
<p>SI (Source Index)：源变址寄存器；</p>
<p>DI (Destination Index)：目的变址寄存器；</p>
<p><strong>2 控制寄存器</strong></p>
<p>IP (Instruction Pointer)：指令指针寄存器；</p>
<p>FLAG：标志寄存器；</p>
<p><strong>3 段寄存器</strong></p>
<p>CS (Code Segment)：代码段寄存器；</p>
<p>DS (Data Segment)：数据段寄存器；</p>
<p>SS (Stack Segment)：堆栈段寄存器；</p>
<p>ES (Extra Segment)：附加段寄存器；</p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>从上面可以知道，在 8086 CPU 中，通用寄存器有 8 个，分别是 AX，BX，CX，DX，SP，BP，SI，DI ，</p>
<p>至于为什么给它们取名做通用寄存器，那是因为，这些个寄存器多种用途，</p>
<p>比如 CX 作为计数寄存器，则是在使用 LOOP 指令循环时用来指定循环次数的寄存器，</p>
<p>如果它们每一个都只有一个专用的作用，那就它们只能称之为专用寄存器了，</p>
<p>正是因为这些个寄存器还可以用来传送数据和暂存数据，所以才称它们为通用寄存器 。</p>
<p>下面就按顺序来一一介绍这几个通用寄存器了：</p>
<p><strong>数据寄存器（AX，BX，CX，DX）：</strong></p>
<p>数据寄存器有 AX，BX，CX，DX 四个组成，</p>
<p>由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，</p>
<p>在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，</p>
<p>由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了 。</p>
<p>AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；</p>
<p>BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；</p>
<p>CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；</p>
<p>DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；</p>
<p>除了上面 4 个数据寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 ；</p>
<p>注意在上面标志中的“独立”二字，这两个字表明 AH 和 AL 作为 8 位寄存器使用时，</p>
<p>可以看做它们是互不相关的，也就是看做两个完全没有联系的寄存器 X 和 Y 即可，</p>
<p>比如指令 MOV AH , 12H ，CPU 在执行时根本就不会知道 AL 中是什么鬼东西，因为它只认识 AH 。</p>
<p>下面给出一幅 16 位数据寄存器的结构图：</p>
<p>表示 16 位 寄存器 AX 可以表示成两个 8 位寄存器，</p>
<p>其中 AH 表示高位的 8 位寄存器，AL 表示低位的 8 位寄存器 。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512111614952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p>
<h4 id="AX-寄存器"><a href="#AX-寄存器" class="headerlink" title="AX 寄存器"></a>AX 寄存器</h4><p>如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL</p>
<p>AX 寄存器具有的特殊用途是在使用 DIV 和 MUL 指令时使用，</p>
<h5 id="DIV"><a href="#DIV" class="headerlink" title="DIV"></a>DIV</h5><p>DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的，而且除数可以存放在寄存器中或者是内存单元中，而至于被除数的话，自然，应该由 AX 来代替了，当除数是 8 位时，被除数一定会是 16 位的，并且默认是放在 AX 寄存器中，<br>而当除数是 16 位时，被除数一定是 32 位的，因为 AX 是 16 位寄存器，自然，放不下 32 位的被除数，<br>所以，在这里还需要使用另一个 16 位寄存器 DX ，其中 DX 存放 32 位的被除数的高 16 位，而 AX 则存放 32 位的被除数的低 16 位，</p>
<p>同时，AX 的作用还不仅仅是用来保存被除数的，当除法指令执行完成以后，如果除数是 8 位的，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数，当然，如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。</p>
<h5 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h5><p>当使用 MUL 做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位，如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中，</p>
<p>而如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个 16 位的则是位于 16 的寄存器中或者是某个内存字单元中。</p>
<p>同时，当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中，而如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，</p>
<p>其中，高位默认保存在 DX 中，而低位则默认保存在 AX 中。</p>
<p>AX 寄存器在 DIV 指令中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,0H;设置 32 位被除数的高 16 位为 0H</span><br><span class="line">MOV AX,8H;设置 32 位被除数的低 16 位为 8H</span><br><span class="line">MOV BX,2H;设置 16 位除数为 2H</span><br><span class="line">DIV BX       ;执行计算</span><br></pre></td></tr></table></figure>
<p>4 条语句的执行过程如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512112128858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>AX 寄存器在 MUL 指令中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,800H;设置 16 位乘数为 800H</span><br><span class="line">MOV BX,100H;设置 16 位乘数为 100H</span><br><span class="line">MOV DX,0H;清空用来保存乘法结果的高 16 位    </span><br><span class="line">MUL BX       ;执行计算</span><br></pre></td></tr></table></figure>
<p>4 条语句的执行过程如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512112236713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p>
<h4 id="BX-寄存器"><a href="#BX-寄存器" class="headerlink" title="BX 寄存器"></a>BX 寄存器</h4><p>首先可以明确的是，BX 作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和 AX 可以暂存一般性数据的功能是一样的，其同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即有 BH 和 BL，除了暂存一般性数据的功能外，BX 作为通用寄存器的一种，BX 主要还是用于其专属功能 – 寻址（寻址物理内存地址）上，</p>
<p>BX 寄存器中存放的数据一般是用来作为<strong>偏移地址</strong>使用的，何为偏移地址呢？既然是偏移地址的话，当然得有一个基地址了，而这个基地址其实就是<strong>段地址</strong>，这里就涉及到了段寄存器，当然，在介绍 BX 寄存器的时候，我不会去介绍段寄存器，上面提到 BX 的主要功能是用在寻址上，那么，其是如何寻址的呢？</p>
<p>而这里，我只点一下，在 8086 CPU 中，CPU 是根据 &lt;段地址：偏移地址&gt; 来进行寻址操作的，而 BX 中存放的数据表示的是偏移地址的话，自然，便可以通过 &lt;段地址：[BX]&gt; 的方式来完成寻址操作了。</p>
<p>为了介绍 BX 在寻址当中的作用，下面我给出一副示意图：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512112423760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">  </p>
<p>上面的示意图表示：可以令 BX = 2，然后通过 DS : [BX] 来访问到内存中段地址为 DS，且偏移量为 2 的内存单元了。上面介绍的这种寻址方式是 BX 在寻址中最最简单的应用了，而对于稍微复杂的寻址方式，还可以依赖于 SI，DI，BP 等寄存器来一起完成。</p>
<p>BX 寄存器在寻址中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV BX,5H</span><br><span class="line">MOV AH,11H</span><br><span class="line">MOV AH,[BX];设置 AX 的值为偏移地址为 BX 中的值时所代表的内存单元</span><br></pre></td></tr></table></figure>
<p>3 条语句的执行过程如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512112718487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上图可以看出，在偏移地址为 5 时的内存单元中的数据位 BBH，<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512112848384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而从这幅图上面就可以看出，确实通过 [BX] 找到了偏移地址为 5 处的内存单元，并且将内存单元移入了 AH 中。</p>
<h4 id="CX-寄存器"><a href="#CX-寄存器" class="headerlink" title="CX 寄存器"></a>CX 寄存器</h4><p>CX 寄存器作为数据寄存器的一种呢，其同样具有和 AX，BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，即有 CH 和 CL 两个 8 位寄存器，</p>
<p>当然，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能，</p>
<p>当在汇编指令中使用<strong>循环 LOOP</strong> 指令时，可以通过 CX 来指定需要循环的次数，</p>
<p>而 CPU 在每一次执行 LOOP 指令的时候，都会做两件事：</p>
<p>一件就是令 CX = CX – 1，即令 CX 计数器自动减去 1；还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，</p>
<p>当然如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。</p>
<p>CX 寄存器在循环中的使用（输出 5 个白底蓝字的 A）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,0B800H</span><br><span class="line">MOV DS,AX;使用 80x25 彩色字符模式，内存地址 0xB8000 - 0xBFFFFF</span><br><span class="line">MOV BX,0;从 0xB8000 开始</span><br><span class="line">MOV CX,5H;循环 5 次</span><br><span class="line">MOV DX,41H;A 的16 进制为 41H</span><br><span class="line">MOV AX,01110001B;显示白底蓝字</span><br><span class="line">s:  MOV [BX],DX;显示 ASCII 字符</span><br><span class="line">    ADD BX,1</span><br><span class="line">    MOV [BX],AX;设置字符显示属性</span><br><span class="line">    ADD BX,1</span><br><span class="line">LOOP s</span><br></pre></td></tr></table></figure>
<p>语句的执行结果如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512113302361.png" alt="在这里插入图片描述">  </p>
<h4 id="DX-寄存器"><a href="#DX-寄存器" class="headerlink" title="DX 寄存器"></a>DX 寄存器</h4><p>DX 寄存器作为数据寄存器的一种，同样具有和 AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，极有 DH 和 DL，同时，DX 作为一个通用寄存器的话，自然其还有其他的用途，而关于 DX 在其他方面的用途，</p>
<p>其实在前面介绍 AX 寄存器时便已经有所介绍了，即当在使用 DIV 指令进行除法运算时，如果除数为 16 位时，被除数将会是 32 位，而被除数的高 16 位就是存放在 DX 中，而且执行完 DIV 指令后，本次除法运算所产生的余数将会保存在 DX 中，同时，在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，那么相乘后产生的结果显然需要 32 位来保存，而这 32 位的结果的高 16 位就是存放在 DX 寄存器中。</p>
<p>DX 寄存器在 DIV 指令中的使用（即 2293812 / 256 = 8960 余数为 52）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DX,0023H;32 位被除数的高 16 位</span><br><span class="line">MOV AX,0034H;32 位被除数的低 16 位</span><br><span class="line">MOV BX,100H;16 的除数</span><br><span class="line">DIV BX  </span><br></pre></td></tr></table></figure>
<p>语句的执行过程如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512113509221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p>
<p>可以看到在语句结束以后，AX = 2300H 即十进制的 8960，而 DX = 34H即十进制的 52 和我们的结果是一致的。DX 寄存器在 MUL 指令中的使用则各位可以参考在 AX 中 MUL 运算的使用，这里就不贴出来了。</p>
<h4 id="指针寄存器（BP-SP）"><a href="#指针寄存器（BP-SP）" class="headerlink" title="指针寄存器（BP, SP）"></a>指针寄存器（BP, SP）</h4><p>8086 CPU 中的指针寄存器包括两个，即 SP 和 BP ，在这里呢，我先只对 BP 寄存器做介绍，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，我将会把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。</p>
<p>BP (Base Pointer)也就是==基指针寄存器==，它和其他的几个用来进行寻址操作所使用的寄存器（还有 BX，SI，DI）没有太大的区别。</p>
<p>首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用，</p>
<p>而后当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，那么如果在指令中没有明确或者说是显示的给出段地址时，段地址则使用默认的 SS 寄存器中的值（BX，SI，DI 会默认使用 DS 段寄存器），</p>
<p>比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，</p>
<p>所以，这里代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元，而如果单单是使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。</p>
<p>并且 <strong>BP 寄存器主要适用于给出堆栈中数据区的偏移，从而可以方便的实现直接存取堆栈中的数据</strong></p>
<p>在 8086 CPU 中，只有 4 个寄存器可以以 […] 的方式使用，这四个寄存器分别是 BX，SI，DI，BP。</p>
<p>下面的 Demo 是 BP 寄存器在寻址中的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV BP,0</span><br><span class="line">MOV AX,[BP]         ;将 SS:[BP] 代表的内存单元移入 AX 中</span><br><span class="line">MOV AX,CS:[BP]      ;将 CS:[BP] 代表的内存单元移入 AX 中</span><br></pre></td></tr></table></figure>
<p>语句的执行过程如下：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/2020051211463534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p>
<h4 id="变址寄存器（SI，DI）"><a href="#变址寄存器（SI，DI）" class="headerlink" title="变址寄存器（SI，DI）"></a>变址寄存器（SI，DI）</h4><p>首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。</p>
<p>SI (Source Index) 是源变址寄存器，DI (Destination Index) 即是目的变址寄存器，</p>
<p>8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器，而这也就是 SI 寄存器和 DI 寄存器与BX 寄存器所不同的地方，既然，SI，DI 两个寄存器的功能和 BX 差不多，自然，SI 和 DI 中也是可以暂存一般性数据的，同时，通过使用 SI 和 DI 寄存器也是可以用来完成寻址操作的。<br>比如下面的代码就是可行的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV SI,0;初始化偏移地址为 0</span><br><span class="line">MOV AX,[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[SI];将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[SI];将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DI,0    ;初始化偏移地址为 0</span><br><span class="line">MOV AX,[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,DS:[DI];将段地址为 DS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br><span class="line">MOV AX,SS:[DI];将段地址为 SS 偏移地址为 DI 的内存单元中的值移入 AX 中</span><br></pre></td></tr></table></figure>
<h3 id="CS-IP-SS-SP-DS-ES-寄存器"><a href="#CS-IP-SS-SP-DS-ES-寄存器" class="headerlink" title="CS, IP, SS, SP, DS, ES 寄存器"></a>CS, IP, SS, SP, DS, ES 寄存器</h3><p>由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，我并不会单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍 。由于下面的介绍中会涉及到很多关于段和栈的概念，而段和栈的介绍又都必须关系到物理内存，所以在介绍段寄存器以及其他一些呈协作关系的寄存器之前，还是先来介绍一下这几个基本的概念比较好。</p>
<p><strong>8086 CPU 访问内存（物理地址）：</strong></p>
<p>当 CPU 需要访问一个内存单元时，需要给出内存单元的地址，而每一个内存单元在物理内存空间中都有一个唯一的地址，即可以通过这个地址定位到内存单元，而这个地址即为物理地址。CPU 通过地址总线将一个内存单元的物理地址送入存储器，而后 CPU 便可以通过这个物理地址来访问这个物理地址所指向的内存单元了。那么这个物理地址在 CPU 中是如何形成的呢？</p>
<p>首先，我们知道 8086 CPU 的地址总线是 20 根，即每次都可以传输 20 位的地址，从而寻址能力有 2^20 也就是 1MB 的大小，但是 8086 CPU 的寄存器只有 16 位，也就是在 8086 CPU 的内部，一次性处理，传输，暂存的地址都只能是 16 位，即 8086 CPU 不能完整的保存下一个物理地址（物理地址为 20 位），</p>
<p>如果单单以最简单的方式（即直接用 16 位寄存器来保存物理地址）的话，那么，寻址能力只有 2^16 ，也就是 64KB，如果真以如此简单的方式的话，那么地址总线还需要 20 根干嘛呢？而且，难不成我们以后的内存就是 64KB 了吗？</p>
<p>当然不是的，8086 CPU 在这里采取了一定的措施从而使其寻址能力达到 1MB 。8086 CPU 在内部通过<strong>两个 16 位的地址进行合成从而形成一个 20 位的物理地址</strong>，由此，8086 CPU 的寻址能力便可以达到 1MB 。</p>
<p>那么 8086 CPU 又是如何将两个 16 位的地址合成为一个20 位的物理地址的呢？当 CPU 在访问内存时，其会使用一个 <strong>16 位的基地址</strong>，然后再使用一个<strong>16 位的偏移地址</strong></p>
<p>通过将基地址和偏移地址传入 8086 CPU 的地址加法器中进行合成即可以构造出 20 位的物理地址。至于合成的方式如下：</p>
<p>基地址其实是通过一个 16 位的段地址来形成的，将一个段地址左移 4 位即形成了基地址，而至于偏移地址的话，自然不必多说，为 16 位，通过将基地址和偏移地址相加便形成了 20 位的物理地址 。</p>
<p>下面给出一幅示意图来表示物理地址的合成：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512115455811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p>
<h5 id="段"><a href="#段" class="headerlink" title="段"></a>段</h5><p>至于段的话，其实在物理内存中是没有段这一概念的，事实上，段的概念来自于 CPU ，因为 CPU 拥有段寄存器，既然在 CPU 中拥有了段寄存器，自然，在 CPU 中就肯定有段的概念了，其实段也就是在编程时，我们将若干个地址连续的内存单元看做是一个段，然后通过将一个段地址左移 4 位形成基地址，再通过这个基地址来定位这个段的起始地址，然后，再通过偏移地址便可以精确定位到段中的内存单元了，由于段的起始地址是一个段地址左移 4 位，</p>
<p>所以很明显，段的起始地址肯定是 16 的倍数，而且由于一个段内部，只能通过偏移地址来定位，而偏移地址为 16 位，所以一个段的长度也就是 2^16 也就是 64KB 的大小。</p>
<p>在编程时，可以讲一段内存定义成为一个段，而这里，我们又可以引出数据段，代码段，栈段这三种类型的段。何为数据段呢？其实就是我们自个儿定义一段内存（当然段起始地址肯定是 16 的倍数，并且段长度 &lt;= 64KB），</p>
<p>然后我们在这个段里头存放我们所需要使用的数据，这就是数据段；何为代码段呢？其实也很简单，也是我们自己在编程的时候定义一段内存，然后这段内存用来存放我们的代码（也就是指令），既然是存放的代码，自然就称之为代码段；</p>
<p>何为栈段呢？至于栈段的话，有接触过数据结构的朋友应该是很清楚栈的，而这里我们也就是在内存中分配出一个段，然后将这个段当做栈来使用。</p>
<p>首先，对于任何一个段来说，均有段地址，而这些段地址是存放在段寄存器中（段寄存器的作用也在于此），但是对于不同的段，它们默认的段地址存放在不同的段寄存器中，像数据段来说，它的段地址存放在 DS （Data Segment）寄存器中，代码段的段地址存放在 CS （Code Segment）寄存器中，栈段的段地址存放在 SS （Stack Segment）寄存器中 。</p>
<p>下面给出一幅在段中寻址的示意图：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512115812990.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的示意图中，通过将段地址左移四位，然后与偏移地址相加便可以得到 20 位的物理地址了 。</p>
<h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><p>8086 CPU 中提供了对栈的支持，并且其还提供了相应的指令来以栈的方式访问内存空间 。</p>
<p>什么是栈？通过上面在段中的介绍，栈其实就是一个段，再说白一点，也就是一块内存，当然，这块内存是一块连续的内存 。</p>
<p>既然栈是一个段的话，那么当然就可以以使用段的方式来使用栈，当然，除了像段一样的使用栈以外，栈还提供了其特殊的访问方式。</p>
<p>众所周知，栈是先进后出类型的数据结构，在 8086 CPU 中也是如此，可以通过==PUSH==指令将数据压入栈中，然后再通过==POP==指令将栈顶的元素取出来 。</p>
<p>下面给出一幅示意图来描述栈：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512115902282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">  </p>
<p>即通过 PUSH 10 来将元素 10 放入栈中，因为，先前栈中没有任何数据，所以，10 就会作为栈顶元素存在，然后再在栈中压入元素 20 ，此时，栈顶中的元素就是 20 了，然后再使用 POP 指令将栈顶元素取出，此时取出的栈顶元素是 20 ，取出 20 后，栈中便只剩下 10 了，自然 10 就成为了栈顶，最后再通过 POP 指令将栈顶 10 取出，此时，栈便变成了空栈了 。</p>
<p>好了，在介绍段寄存器之前的基础知识介绍就到这里了，下面开始正式介绍段寄存器以及与它们协作使用的寄存器。</p>
<h5 id="CS-寄存器-和-IP-寄存器"><a href="#CS-寄存器-和-IP-寄存器" class="headerlink" title="CS 寄存器 和 IP 寄存器"></a>CS 寄存器 和 IP 寄存器</h5><p>经过前面对段的介绍，相信各位朋友对段寄存器应该也有一定的了解了，下面将要介绍的是一组非常非常重要的寄存器，即 CS:IP 。CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而 IP 为指令指针寄存器 。</p>
<p>什么叫做指示了 CPU 当前将要读取的指令呢？在 8086 CPU 中，为什么 CPU 会自动的执行指令呢？这些指令肯定是存放在内存中的，但是 CPU 怎么知道这些指令存放在内存的那个位置呢？</p>
<p>比如，我有下面的两条指令要执行：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX,1234H</span><br><span class="line">MOV BX,AX</span><br></pre></td></tr></table></figure></p>
<p>而假设这两条指令在内存中存放为：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512120040942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很显然， 1000H:0000H 指向的是 MOV AX，1234H 的首地址，如果 CPU 要读取到我的指令的话，很显然，必须要知道地址 1000H:0000H ，然后 CPU 就可以根据这个首地址，将汇编指令 MOV AX，1234H 所对应的机器码读入到 CPU 的指令寄存器中，最后便可以在 CPU 中进行处理了。</p>
<p>但关键是 CPU 如何知道我的 1000H:0000H 这个首地址？其实这就需要使用到 CS:IP 这个寄存器组了 。</p>
<p>当我们运行一个可执行文件时，很明显，我们需要另外一个程序来将这个可执行文件加载到内存当中，关于这个加载可执行文件的程序，我们在这里不管他，点一下即可，一般是通过操作系统的外壳程序（也就是传说中的 Shell 程序），Shell 将可执行文件加载到内存中以后，就会设置 CPU 中的两个寄存器，即设置 CS:IP 两个寄存器指向可执行文件的起始地址，此后 CPU 便从这个起始地址开始读取内存中的指令，并且执行，</p>
<p>比如我们在写汇编程序时，通常会使用 START 标记，其实这个标记就是用来标记起始地址的，当将一个汇编程序编译，连接成可执行文件以后，再通过操作系统的 Shell 程序将可执行文件加载到内存中以后，这个 START 所标记处的地址就是整个可执行文件的起始地址了 。</p>
<p>也就是说，当一个可执行文件加载到内存中以后，CS:IP 两个寄存器便指向了这个可执行文件的起始地址，然后 CPU 就可以从这个起始地址开始往下读取指令，<strong>当读取完指令后，CS:IP 将会自动的改变，基本上是改变 IP ，从而指向下一条要读取的指令</strong>，这样就可以执行这个可执行文件了 。</p>
<p>最后再对 CS:IP 总结一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.你想让  CPU  执行哪行指令，你就让  CS:IP  指向保存有指令的那块内存即可。</span><br><span class="line">2.任何时候，CS:IP  指向的地址中的内容都是  CPU  当前执行的指令。</span><br></pre></td></tr></table></figure>
<p>下面我们来看一个 Demo，并详细观察其执行的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,1234H</span><br><span class="line">    MOV BX,AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512120435345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面的截图中可以看出，当我使用 Shell （在 DOS 下也就是 Command 命令解释器）将可执行文件加载进内存后，可以看到，整个程序的起始地址为 0C54H : 0000 H ，并且，可以看到 CS 的地址为 0C54H ，IP 的地址为 0000H，这正好吻合我们上面对 CS:IP 的分析，很明显，CPU 将会读取 <code>MOV AX ，1234H</code> 到 CPU 中并且执行 ，</p>
<p>然后我们继续向下看：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512120624853.png" alt="在这里插入图片描述"><br>可以看到，我们单步执行后，AX 中的值编成了 1234H ，而 IP 寄存器中的值变成了 0003H，对于 AX 中的值的改变，我们是能够理解的，但是 IP 中的值为什么会从 0000H 变到 0003H 呢？</p>
<p>从最上面的一幅关于指令在内存中的存放可以看出 <code>MOV AX ，1234H</code> 在内存中需要 3 个内存单元存放，也就是 CPU 为了执行 <code>MOV AX ，1234H</code> 这条指令，已经将内存中相对应的 3 个内存单元读入内存中了，执行完这条指令后，自然，CPU 就要将偏移地址向下移动 3 个单元，从而使得 CS:IP 指向下一条需要执行的指令了 ，</p>
<p>为了更深刻的理解，我们再来继续看执行过程，<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512121004851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从最上面的一幅关于指令在内存中的存放可以看出 <code>MOV BX ，AX</code> 在内存中只占 2 个内存单元，</p>
<p>这也就是为什么 IP 这一次只向下移动了 2 个单元的缘故 。</p>
<p>关于 CS: IP 的遐想：</p>
<p>从上面关于 CS:IP 的介绍中，我们可以大胆的猜想，我们<strong>只需要通过手动的改变 CS:IP 所指向的内存地址，让 CS:IP 指向我们另外的代码，那么我们就可以让 CPU 执行我们自己指定的代码了</strong>。即可以通过修改 CS:IP 来达到我们想要让 CPU 干什么它就干什么的目的 。</p>
<p>上面的虽然是遐想，但是大家要相信，我们写的是汇编，不是 JAVA 也不是 NET ，所以我们还真的可以达到上面的目的，也就是说我们的遐想其实是可以实现的，当然这还是有一定的限制的 ，</p>
<h5 id="SS-寄存器和-SP-寄存器"><a href="#SS-寄存器和-SP-寄存器" class="headerlink" title="SS 寄存器和 SP 寄存器"></a>SS 寄存器和 SP 寄存器</h5><p>在底层涉及的是栈在内存中的具体实现 。</p>
<p>不知道，大伙有没有注意笔者在本篇博文的上面介绍关于栈的知识时，我并没有提到如何找到这个栈，我只提到了一个栈就是先进后出操作，同时可以使用 ”PUSH“ 和 ”POP“ 指令，然后就是稍微带了一下 SS 这个寄存器的介绍，</p>
<p>我们虽然在内存中是可以方便的定义一个栈了，但是，我们为什么要定义这么一个栈呢？自然，是为了操作方便，同时提供给 CPU 使用的，既然 CPU 要使用的话，自然，CPU 又必须根据一定的方式找到这个栈，而这就需要使用 SS 和 SP 寄存器了 。</p>
<p>同时，一个栈也就是一块内存区域，通过上面的介绍，我们也知道了如果要在一块内存中精确地定位到内存单元的话（寻址），我们必须要有<strong>基地址（也就是段地址左移 4 位）和偏移地址</strong>，自然，要在一个栈中寻址的话，也需要段地址和偏移地址，</p>
<p>而对于一个栈来说，我们使用的最多的是什么呢？</p>
<p>当然是==栈顶==了，因为只有栈顶可以用来存取数据，所以对于一个栈来说，我们只需要有栈顶的段地址和偏移地址即可，而对于栈顶的段地址，其是存放在段寄存器 SS 中的，而对于栈顶的偏移地址，其则是存放在 SP 寄存器中的 。</p>
<p>==在任何时刻，SS:SP 都是指向栈顶元素==。</p>
<p>其实关于栈的使用还是比较简单的，但是要注意的是 8086 CPU 并不会保证我们对栈的操作会不会越界 。所以我们在使用栈的时候需要特别注意栈的越界问题 。</p>
<p>当使用 <code>PUSH</code> 指令向栈中压入 1 个字节单元时，SP = SP - 1；即栈顶元素会发生变化；</p>
<p>而当使用 <code>PUSH</code> 指令向栈中压入 2 个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；</p>
<p>当使用 <code>POP</code> 指令从栈中弹出 1 个字节单元时， SP = SP + 1；即栈顶元素会发生变化；</p>
<p>当使用 <code>POP</code> 指令从栈中弹出 2 个字节单元的字单元时， SP = SP + 2 ；即栈顶元素会发生变化；</p>
<p>下面通过一个 Demo 来介绍栈的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    </span><br><span class="line">    MOV AX,1000H;首先是定义好栈的段地址</span><br><span class="line">    MOV SS,AX    </span><br><span class="line">    MOV AX,10H;再定义好栈的长度（初始时刻的栈顶偏移地址即栈的长度）</span><br><span class="line">    MOV SP,AX</span><br><span class="line">    </span><br><span class="line">    MOV AX,0001H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0002H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0003H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0004H</span><br><span class="line">    PUSH AX</span><br><span class="line">    MOV AX,0005H</span><br><span class="line">    PUSH AX</span><br><span class="line">    </span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    POP AX</span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p>然后我们来看栈在内存中的结构图：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/202005121216254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>语句的执行过程如下：<br>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512121658415.png" alt="在这里插入图片描述"><br>然后我们再来依次执行上述指令：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512121714142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上副截图中可以看出已经设置好了 SS:SP ，也就是栈已经设置 OK 了，</p>
<p>下面开始往栈中压入数据了，<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/2020051212201138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于我们压入栈中的数据为字数据，即占 2 个内存单元，所以，每次 SP = SP – 2 ；</p>
<p>将 5 个字型数据压入栈中后，我们可以来查看栈中的数据了，<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122055548.png" alt="在这里插入图片描述"><br>因此，在内存中的一个好看点的结构图如下所示：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122124897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面开始进行出栈操作了<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/2020051212215010.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于我们弹出栈时的数据为字数据，即占 2 个内存单元，所以，每次 SP = SP + 2 ；</p>
<p>将 5 个字型数据全部弹出栈中后，我们可以来查看栈中的数据了，<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122206915.png" alt="在这里插入图片描述"><br>可以看到 SP 变成了初始状态了，也就是说栈中所有的数据已经全部弹出了，虽然我们查看内存时看到的不是 0 ，</p>
<p>但是我们看到的这些数据都是无效的，我们这里不理会 。</p>
<h5 id="DS-寄存器和-ES-寄存器"><a href="#DS-寄存器和-ES-寄存器" class="headerlink" title="DS 寄存器和 ES 寄存器"></a>DS 寄存器和 ES 寄存器</h5><p>DS 寄存器和 ES 寄存器都属于段寄存器，其实它们和 CS 寄存器以及 SS 寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了 。</p>
<p>通过上面对基础知识的介绍呢，我们已经知道，如果 CPU 要访问一个内存单元时，我们必须要提供一个指向这个内存单元的物理地址给 CPU，而我们也知道在 8086 CPU 中，物理地址是由段地址左移 4 位，然后加上偏移地址形成的，所以，我们也就只需要提供段地址和偏移地址即 OK 。8086 CPU 呢，提供了一个 DS 寄存器，并且通常都是通过这个 DS 段寄存器来存放要访问的数据的段地址 。</p>
<p>DS（Data Segment）：很显然，DS 中存放的是数据段的段地址 。</p>
<p>但是这里不得不再点一下，那就是我们对段的支持是在 CPU 上体现的，而不是在内存中实现了段，所以事实上我们使用的段其实是一个逻辑概念，即是我们自己定义的，再说白了，我定义一个段，我说它是数据段那它就是数据段，我说它是代码段那么它就是代码段，它们其实都是一块连续的内存而已，至于为什么要区分为数据段和代码段，很明显，是用来给我们编程提供方便的，即我们在自己的思想上或者说是编码习惯上规定，</p>
<p>数据放数据段中，代码放代码段中 。而我们在使用数据段的时候，为了方便或者说是代码的编写方便起见，我们一般把数据段的段地址放在 DS 寄存器中，当然，如果你硬要觉得 DS 不顺眼，那你可以换个 ES 也是一样的，</p>
<p>至于 ES（Extra Segment） 段寄存器的话，自然，是一个附加段寄存器，如果再说得过分点，就当它是个扩展吧，当你发现，你几个段寄存器不够用的时候，你可以考虑使用 ES 段寄存器，在使用方式上，则和其他的段寄存器没什么区别 。</p>
<p>下面看一个介绍使用 DS 寄存器的 Demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">    MOV AX,1000H</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    MOV AL,1</span><br><span class="line">    MOV BX,0</span><br><span class="line">    </span><br><span class="line">    MOV CX,5;设计一个循环，让其循环 5 次</span><br><span class="line">    s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">       INC AL</span><br><span class="line">       INC BX</span><br><span class="line">       LOOP s            </span><br><span class="line">    </span><br><span class="line">    MOV AH,4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<p>上面的代码所做的事情，就是循环将 1，2，3，4，5 写入到地址 1000H：0000H ，1000H：0001H，1000H：0002H，1000H：0003H，1000H：0004H 中，</p>
<p>语句的执行过程如下：<br>首先我们来看尚未执行上述任何指令时栈中的数据情况：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122513469.png" alt="在这里插入图片描述"><br>而当循环执行完成以后，我们再来看内存 1000H：0000H 处的值：</p>
<p>在这里，我们可以看到确实达到了我们预期的效果，但是大家注意看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s: MOV [BX],AL;这里 [BX] 并没有指定段地址哦</span><br><span class="line">   INC AL</span><br><span class="line">   INC BX</span><br><span class="line">   LOOP s  </span><br></pre></td></tr></table></figure>
<p>这里可以看到，我们在 [BX] 中并没有给其指定段地址，而只有一个偏移地址，但是根据我们一开始的介绍，必须要有段地址和偏移地址才能够定位内存单元，</p>
<p>莫非这里出问题了？其实不是的，因为我们在最前面定义了段地址 DS 为 1000H，<strong>当我们定义好段地址后，每一次 CPU 执行到 [BX] 时，便会自动或者说是默认的从 DS 中取值</strong>，并且将取得的值作为段地址，因此，当 [BX] 为 0001H 时，CPU 会从 DS 中取得一个 1000H ，由这两个一合成即可以得到正确的物理地址 1000H：0000H 。</p>
<p>最后还提醒一点，那就是 8086 CPU <strong>不支持直接将一个数据送入段寄存器</strong>中，</p>
<p>也就是下面的做法是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DS,1000H</span><br></pre></td></tr></table></figure>
<h5 id="标志寄存器-FLAG"><a href="#标志寄存器-FLAG" class="headerlink" title="标志寄存器 FLAG"></a>标志寄存器 FLAG</h5><p>前面呢，已经介绍了 8086 CPU 14 个寄存器中的 13 个了，下面我们将介绍最后一个寄存器也就是 FLAG 寄存器，FLAG 寄存器之所以放到最后一个介绍，是因为其和其他的一些寄存器不同，像 AX，BX，CX，DX 这些寄存器来说，它们都是用来存放数据的，当然 FLAG 中存放的也是数据啦，不过，AX，BX 这些寄存器中的数据是作为一个整体使用的，</p>
<p>最多也就分成一个 AL 和 AH 使用而已，<strong>但是在 FLAG 中，数据是按位起作用的，也就是说，FLAG 中的每一个位都表示不同的状态，由于一个位也就能表示 0 和 1</strong> ，自然，FLAG 中的每一个位就是用来描述状态的，而且 FLAG 寄存器中存储的信息通常又被称作程序状态字（PSW） 。</p>
<p>下面我给出一幅 FLAG 寄存器中各个位的示意图：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122743736.png" alt="在这里插入图片描述"><br>从上面这幅图中可以看出，FLAG 的第 0 个位表示的是 CF ，第 2 个位表示的是 PF ，与此类推 . . . .<br>首先，我们来看一个列表：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122803832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的这个表怎么看呢？我们通过看下面一幅截图就知道了 。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://img-blog.csdnimg.cn/20200512122828929.png" alt="在这里插入图片描述"><br>从上面的标记中可以看出，从左到右依次代表 OF，DF，SF，ZF，PF，CF 标志位的值，</p>
<p>至于为什么我们在 Debug 模式下，使用 R 命令时，只会列出这几个标志位，我猜的话是因为相对来说，列出的这几个标志位更为常用，其他的几个标志位并不经常使用的缘故吧 。</p>
<p>下面我们就按不同的位来分别介绍这些位所描述的状态，以及它们代表的意义：  </p>
<p><strong>CF（Carry FLag） - 进位标志（第 0 位）：</strong></p>
<p>CF： 进位标志是用来反映计算时是否产生了由低位向高位的<strong>进位</strong>，或者产生了从高位到低位的<strong>借位</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算过程中产生了进位或者借位)</span><br><span class="line">        CF  =  1;</span><br><span class="line">else</span><br><span class="line">        CF  =  0;</span><br></pre></td></tr></table></figure>
<p><strong>PF（Parity FLag） - 奇偶标志（第 2 位）：</strong><br>PF： 奇偶标志是用来记录相关指令执行后，其结果的所有的 Bit 位中 1 的个数是否为偶数 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算结果中 1 的个数为偶数)</span><br><span class="line">        PF  =  1;</span><br><span class="line">else</span><br><span class="line">        PF  =  0;</span><br></pre></td></tr></table></figure>
<p><strong>AF（Auxiliary Carry FLag） - 辅助进位标志（第 4 位）：</strong><br>AF： 用来辅助进位标志 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(字节操作中发生低半个字节向高半个字节借位或者进位  ||  字操作中发生低字节向高字节借位或者进位)</span><br><span class="line">       AF = 1;</span><br><span class="line">else</span><br><span class="line">       AF = 0;</span><br></pre></td></tr></table></figure>
<p><strong>ZF（Zero FLag） – 零标志（第 6 位）：</strong><br>ZF： 记录的是相关的指令执行完毕后，其执行的结果是否为 0 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(执行的结果  ==  0)</span><br><span class="line">       ZF = 1;</span><br><span class="line">else</span><br><span class="line">       ZF = 0;</span><br></pre></td></tr></table></figure>
<p><strong>SF（Sign FLag） - 符号标志（第 7 位）：</strong><br>SF： 符号标志，其记录相关指令执行完以后，其结果是否为负数 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算结果为负数)</span><br><span class="line">        SF  =  1;</span><br><span class="line">else</span><br><span class="line">        SF  =  0;</span><br></pre></td></tr></table></figure>
<p><strong>TF（Trap FLag） - 追踪标志（第 8 位）：</strong></p>
<p>TF： 追踪标志，主要是用于调试时使用 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(TF  ==  1)</span><br><span class="line">       CPU 进入单步方式;</span><br></pre></td></tr></table></figure>
<p><strong>IF（Interrupt-Enable FLag） - 中断允许标志（第 9 位）：</strong></p>
<p>IF： 中断允许标志，其决定 CPU 是否能够响应外部可屏蔽中断请求（以后会做详细介绍） 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(IF  ==  1)</span><br><span class="line">        CPU 能够响应外部的可屏蔽中断请求;</span><br><span class="line">else</span><br><span class="line">        CPU 不能够响应外部的可屏蔽中断请求;</span><br></pre></td></tr></table></figure>
<p><strong>DF（Direction FLag） - 方向标志（第 10 位）：</strong></p>
<p>DF： 方向标志，其用于在串处理指令中，用来控制每次操作后 SI 和 DI 是自增还是自减 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(DF == 0)</span><br><span class="line">        SI++,DI++;</span><br><span class="line">else</span><br><span class="line">        SI--,DI--;</span><br></pre></td></tr></table></figure>
<p><strong>OF（OverFlow FLag） - 溢出标志（第 11 位）：</strong></p>
<p>OF： 溢出标志，其通常记录了有符号数运算的结果是否发生了溢出 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(运算发生溢出)</span><br><span class="line">	OF  =  1;</span><br><span class="line">else</span><br><span class="line">	OF  =  0;</span><br></pre></td></tr></table></figure>
<h1 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h1><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>什么都不干顺下来就是顺序</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="LOOP指令"><a href="#LOOP指令" class="headerlink" title="LOOP指令"></a>LOOP指令</h3><p>利用Count寄存器CX存储循环次数，每次运行LOOP指令，将会执行：</p>
<ol>
<li>DEC CX（CX自减）</li>
<li>JUMP:MULTI</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS: CODESG</span><br><span class="line"></span><br><span class="line">CODESG SEGMENT</span><br><span class="line"></span><br><span class="line">    MAIN:  </span><br><span class="line">           MOV AX,2</span><br><span class="line">           MOV CX,11</span><br><span class="line">           MULTI:ADD AX,1</span><br><span class="line">           LOOP MULTI</span><br><span class="line">           </span><br><span class="line">           MOV AX,4C00H</span><br><span class="line">           INT 21H</span><br><span class="line"></span><br><span class="line">CODESG ENDS</span><br><span class="line"></span><br><span class="line">END MAIN</span><br></pre></td></tr></table></figure>
<p>利用分支和JUMP循环</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="PROC（中断跳转）"><a href="#PROC（中断跳转）" class="headerlink" title="PROC（中断跳转）"></a>PROC（中断跳转）</h3><h3 id="小心SP的变化！"><a href="#小心SP的变化！" class="headerlink" title="小心SP的变化！"></a>小心SP的变化！</h3><p>首先：<br>cpu执行call指令时，相当于执行了（push ip） 和 （jmp near ptr 标号）：<br>(sp)=(sp)−2<br>((ss)∗16+(sp))=(ip)<br>(ip)=(ip)+16位位移</p>
<p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<br>cpu执行ret指令时，(相当于pop ip)：<br>(ip)=((ss)∗16+(sp))<br>(sp)=(sp)+2</p>
<p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。<br>cpu执行retf指令时，(相当于pop ip 和 pop cs)：<br>(ip)=((ss)∗16+(sp))<br>(sp)=(sp)+2<br>(cs)=((ss)∗16+(sp))<br>(sp)=(sp)+2</p>
<p>注：<br>SS是堆栈段寄存器，SP是堆栈指针寄存器。<br>SS <em> 16表示堆栈段的段地址（即堆栈段的起始地址），SS </em> 16+SP则表示堆栈的栈顶位置（地址）。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="../../../assets/Pasted%20image%2020221201185743.png" alt=""></p>
<p>以上述代码段为例，调用过程为：<br>ip会指向下一条指令000E，<br><strong>将此时的000E推入push进栈，</strong><br>因为call指令 (ip)=(ip)+16位位移 修改了ip的值，<br>相当于实现了段内跳转，<br>此时的位移： mov ax,4c00h（3个字节） 和 int 21h（2个字节） 两条指令，共5个字节，<br>所以ip = 000Eh + 0005h = 0013h, 刚好是 标号s 处地址，成功实现跳转。</p>
<p>此时成功跳转后，ip先指向下一条指令0015，<br>然后执行add指令，<br>执行成功后ip再指向下一条指令，这时会发现程序段中没有可指向的指令，但是仍会有指向，<br><strong>之后就会执行ret指令，将栈顶的000E出栈并用ip接收，</strong><br>这时就会发现无论之前的ip是多少，执行完ret后都会被覆盖，成功实现了跳转。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/orange_monkey/article/details/106380255">https://blog.csdn.net/orange_monkey/article/details/106380255</a></p>
<h3 id="伪代码（可传参）"><a href="#伪代码（可传参）" class="headerlink" title="伪代码（可传参）"></a>伪代码（可传参）</h3>

<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>许可协议</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/Tavg/Sakura/2655f8cd.html">逢魔が刻 ～かくりよの縁～</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/Tavg/SakuraR/bc91ebd0.html">银之冠·碧之泪</a></div></section></div>






  <div class='related-wrap md-text reveal' id="comments">
    <section class='header cmt-title cap theme'>
      快来参与讨论吧
    </section>
    <section class='body cmt-body giscus'>
      

<svg class="loading" style="vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg>

<div id="giscus" data-repo="aleryxiao/aleryxiao.github.io" data-repo-id="R_kgDOIdw0jw" data-category="Announcements" data-category-id="DIC_kwDOIdw0j84CTXeH" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous"></div>

    </section>
  </div>



      
<footer class="page-footer reveal fs12"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs14">博客</span><a href="/">近期</a><a href="/categories">分类</a><a href="/tags">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs14">整理</span><a href="/wiki">文件夹</a></div><div class="sitemap-group"><span class="fs14">社交</span><a href="/friend">友链</a><a href="/guestbook">留言板</a></div><div class="sitemap-group"><span class="fs14">更多</span><a href="/about">关于</a><a target="_blank" rel="noopener" href="https://github.com/aleryxiao">GitHub</a></div></div><div class="text"><p>本站由 <a target="_blank" rel="noopener" href="https://space.bilibili.com/19610138">@AleryXiao</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.18.5';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.18.5';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->

  <script>
  function loadJS() {
    const els = document.querySelectorAll("#comments #giscus");
    if (els.length === 0) return;
    els.forEach((el, i) => {
      try {
        el.innerHTML = '';
      } catch (error) {
        console.log(error);
      }
      var script = document.createElement('script');
      script.src = 'https://giscus.app/client.js';
      script.async = true;
      for (let key of Object.keys(el.attributes)) {
        let attr = el.attributes[key];
        if (['class', 'id'].includes(attr.name) === false) {
          script.setAttribute(attr.name, attr.value);
        }
      }
      el.appendChild(script);
    });
  }
  window.addEventListener('DOMContentLoaded', (event) => {
    loadJS();
  });
</script>




<!-- inject -->


  </div>
</body>
</html>
